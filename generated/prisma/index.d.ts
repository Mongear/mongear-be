
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Color
 * 
 */
export type Color = $Result.DefaultSelection<Prisma.$ColorPayload>
/**
 * Model Keyboard
 * 
 */
export type Keyboard = $Result.DefaultSelection<Prisma.$KeyboardPayload>
/**
 * Model Layout
 * 
 */
export type Layout = $Result.DefaultSelection<Prisma.$LayoutPayload>
/**
 * Model ConnectionType
 * 
 */
export type ConnectionType = $Result.DefaultSelection<Prisma.$ConnectionTypePayload>
/**
 * Model Switch
 * 
 */
export type Switch = $Result.DefaultSelection<Prisma.$SwitchPayload>
/**
 * Model SwitchType
 * 
 */
export type SwitchType = $Result.DefaultSelection<Prisma.$SwitchTypePayload>
/**
 * Model Keycap
 * 
 */
export type Keycap = $Result.DefaultSelection<Prisma.$KeycapPayload>
/**
 * Model KeycapProfile
 * 
 */
export type KeycapProfile = $Result.DefaultSelection<Prisma.$KeycapProfilePayload>
/**
 * Model KeycapMaterial
 * 
 */
export type KeycapMaterial = $Result.DefaultSelection<Prisma.$KeycapMaterialPayload>
/**
 * Model Accessory
 * 
 */
export type Accessory = $Result.DefaultSelection<Prisma.$AccessoryPayload>
/**
 * Model AccessoryType
 * 
 */
export type AccessoryType = $Result.DefaultSelection<Prisma.$AccessoryTypePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model Wishlist
 * 
 */
export type Wishlist = $Result.DefaultSelection<Prisma.$WishlistPayload>
/**
 * Model WishlistItem
 * 
 */
export type WishlistItem = $Result.DefaultSelection<Prisma.$WishlistItemPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model BillItem
 * 
 */
export type BillItem = $Result.DefaultSelection<Prisma.$BillItemPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model UserCoupon
 * 
 */
export type UserCoupon = $Result.DefaultSelection<Prisma.$UserCouponPayload>
/**
 * Model UserBuild
 * 
 */
export type UserBuild = $Result.DefaultSelection<Prisma.$UserBuildPayload>
/**
 * Model UserBuildComponent
 * 
 */
export type UserBuildComponent = $Result.DefaultSelection<Prisma.$UserBuildComponentPayload>
/**
 * Model ComponentType
 * 
 */
export type ComponentType = $Result.DefaultSelection<Prisma.$ComponentTypePayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BillStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  REFUNDED: 'REFUNDED'
};

export type BillStatus = (typeof BillStatus)[keyof typeof BillStatus]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const TransactionMethod: {
  CASH: 'CASH',
  CREDIT: 'CREDIT',
  QR: 'QR',
  AMORTIZATION: 'AMORTIZATION'
};

export type TransactionMethod = (typeof TransactionMethod)[keyof typeof TransactionMethod]

}

export type BillStatus = $Enums.BillStatus

export const BillStatus: typeof $Enums.BillStatus

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type TransactionMethod = $Enums.TransactionMethod

export const TransactionMethod: typeof $Enums.TransactionMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Products
 * const products = await prisma.product.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.color`: Exposes CRUD operations for the **Color** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colors
    * const colors = await prisma.color.findMany()
    * ```
    */
  get color(): Prisma.ColorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyboard`: Exposes CRUD operations for the **Keyboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keyboards
    * const keyboards = await prisma.keyboard.findMany()
    * ```
    */
  get keyboard(): Prisma.KeyboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.layout`: Exposes CRUD operations for the **Layout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Layouts
    * const layouts = await prisma.layout.findMany()
    * ```
    */
  get layout(): Prisma.LayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connectionType`: Exposes CRUD operations for the **ConnectionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectionTypes
    * const connectionTypes = await prisma.connectionType.findMany()
    * ```
    */
  get connectionType(): Prisma.ConnectionTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.switch`: Exposes CRUD operations for the **Switch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Switches
    * const switches = await prisma.switch.findMany()
    * ```
    */
  get switch(): Prisma.SwitchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.switchType`: Exposes CRUD operations for the **SwitchType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SwitchTypes
    * const switchTypes = await prisma.switchType.findMany()
    * ```
    */
  get switchType(): Prisma.SwitchTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keycap`: Exposes CRUD operations for the **Keycap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keycaps
    * const keycaps = await prisma.keycap.findMany()
    * ```
    */
  get keycap(): Prisma.KeycapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keycapProfile`: Exposes CRUD operations for the **KeycapProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeycapProfiles
    * const keycapProfiles = await prisma.keycapProfile.findMany()
    * ```
    */
  get keycapProfile(): Prisma.KeycapProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keycapMaterial`: Exposes CRUD operations for the **KeycapMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeycapMaterials
    * const keycapMaterials = await prisma.keycapMaterial.findMany()
    * ```
    */
  get keycapMaterial(): Prisma.KeycapMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessory`: Exposes CRUD operations for the **Accessory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accessories
    * const accessories = await prisma.accessory.findMany()
    * ```
    */
  get accessory(): Prisma.AccessoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessoryType`: Exposes CRUD operations for the **AccessoryType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessoryTypes
    * const accessoryTypes = await prisma.accessoryType.findMany()
    * ```
    */
  get accessoryType(): Prisma.AccessoryTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.WishlistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistItems
    * const wishlistItems = await prisma.wishlistItem.findMany()
    * ```
    */
  get wishlistItem(): Prisma.WishlistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billItem`: Exposes CRUD operations for the **BillItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillItems
    * const billItems = await prisma.billItem.findMany()
    * ```
    */
  get billItem(): Prisma.BillItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCoupon`: Exposes CRUD operations for the **UserCoupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCoupons
    * const userCoupons = await prisma.userCoupon.findMany()
    * ```
    */
  get userCoupon(): Prisma.UserCouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBuild`: Exposes CRUD operations for the **UserBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBuilds
    * const userBuilds = await prisma.userBuild.findMany()
    * ```
    */
  get userBuild(): Prisma.UserBuildDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBuildComponent`: Exposes CRUD operations for the **UserBuildComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBuildComponents
    * const userBuildComponents = await prisma.userBuildComponent.findMany()
    * ```
    */
  get userBuildComponent(): Prisma.UserBuildComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.componentType`: Exposes CRUD operations for the **ComponentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComponentTypes
    * const componentTypes = await prisma.componentType.findMany()
    * ```
    */
  get componentType(): Prisma.ComponentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Product: 'Product',
    Color: 'Color',
    Keyboard: 'Keyboard',
    Layout: 'Layout',
    ConnectionType: 'ConnectionType',
    Switch: 'Switch',
    SwitchType: 'SwitchType',
    Keycap: 'Keycap',
    KeycapProfile: 'KeycapProfile',
    KeycapMaterial: 'KeycapMaterial',
    Accessory: 'Accessory',
    AccessoryType: 'AccessoryType',
    Category: 'Category',
    ProductCategory: 'ProductCategory',
    User: 'User',
    Role: 'Role',
    Cart: 'Cart',
    CartItem: 'CartItem',
    Wishlist: 'Wishlist',
    WishlistItem: 'WishlistItem',
    Bill: 'Bill',
    BillItem: 'BillItem',
    Transaction: 'Transaction',
    Coupon: 'Coupon',
    UserCoupon: 'UserCoupon',
    UserBuild: 'UserBuild',
    UserBuildComponent: 'UserBuildComponent',
    ComponentType: 'ComponentType',
    ProductImage: 'ProductImage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "product" | "color" | "keyboard" | "layout" | "connectionType" | "switch" | "switchType" | "keycap" | "keycapProfile" | "keycapMaterial" | "accessory" | "accessoryType" | "category" | "productCategory" | "user" | "role" | "cart" | "cartItem" | "wishlist" | "wishlistItem" | "bill" | "billItem" | "transaction" | "coupon" | "userCoupon" | "userBuild" | "userBuildComponent" | "componentType" | "productImage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Color: {
        payload: Prisma.$ColorPayload<ExtArgs>
        fields: Prisma.ColorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          findFirst: {
            args: Prisma.ColorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          findMany: {
            args: Prisma.ColorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          create: {
            args: Prisma.ColorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          createMany: {
            args: Prisma.ColorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          delete: {
            args: Prisma.ColorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          update: {
            args: Prisma.ColorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          deleteMany: {
            args: Prisma.ColorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          upsert: {
            args: Prisma.ColorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          aggregate: {
            args: Prisma.ColorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColor>
          }
          groupBy: {
            args: Prisma.ColorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColorCountArgs<ExtArgs>
            result: $Utils.Optional<ColorCountAggregateOutputType> | number
          }
        }
      }
      Keyboard: {
        payload: Prisma.$KeyboardPayload<ExtArgs>
        fields: Prisma.KeyboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>
          }
          findFirst: {
            args: Prisma.KeyboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>
          }
          findMany: {
            args: Prisma.KeyboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>[]
          }
          create: {
            args: Prisma.KeyboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>
          }
          createMany: {
            args: Prisma.KeyboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeyboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>[]
          }
          delete: {
            args: Prisma.KeyboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>
          }
          update: {
            args: Prisma.KeyboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>
          }
          deleteMany: {
            args: Prisma.KeyboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeyboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeyboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>[]
          }
          upsert: {
            args: Prisma.KeyboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyboardPayload>
          }
          aggregate: {
            args: Prisma.KeyboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyboard>
          }
          groupBy: {
            args: Prisma.KeyboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeyboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeyboardCountArgs<ExtArgs>
            result: $Utils.Optional<KeyboardCountAggregateOutputType> | number
          }
        }
      }
      Layout: {
        payload: Prisma.$LayoutPayload<ExtArgs>
        fields: Prisma.LayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          findFirst: {
            args: Prisma.LayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          findMany: {
            args: Prisma.LayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>[]
          }
          create: {
            args: Prisma.LayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          createMany: {
            args: Prisma.LayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>[]
          }
          delete: {
            args: Prisma.LayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          update: {
            args: Prisma.LayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          deleteMany: {
            args: Prisma.LayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>[]
          }
          upsert: {
            args: Prisma.LayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          aggregate: {
            args: Prisma.LayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLayout>
          }
          groupBy: {
            args: Prisma.LayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<LayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.LayoutCountArgs<ExtArgs>
            result: $Utils.Optional<LayoutCountAggregateOutputType> | number
          }
        }
      }
      ConnectionType: {
        payload: Prisma.$ConnectionTypePayload<ExtArgs>
        fields: Prisma.ConnectionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>
          }
          findFirst: {
            args: Prisma.ConnectionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>
          }
          findMany: {
            args: Prisma.ConnectionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>[]
          }
          create: {
            args: Prisma.ConnectionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>
          }
          createMany: {
            args: Prisma.ConnectionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectionTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>[]
          }
          delete: {
            args: Prisma.ConnectionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>
          }
          update: {
            args: Prisma.ConnectionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>
          }
          deleteMany: {
            args: Prisma.ConnectionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectionTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>[]
          }
          upsert: {
            args: Prisma.ConnectionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionTypePayload>
          }
          aggregate: {
            args: Prisma.ConnectionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectionType>
          }
          groupBy: {
            args: Prisma.ConnectionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionTypeCountAggregateOutputType> | number
          }
        }
      }
      Switch: {
        payload: Prisma.$SwitchPayload<ExtArgs>
        fields: Prisma.SwitchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SwitchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SwitchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>
          }
          findFirst: {
            args: Prisma.SwitchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SwitchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>
          }
          findMany: {
            args: Prisma.SwitchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>[]
          }
          create: {
            args: Prisma.SwitchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>
          }
          createMany: {
            args: Prisma.SwitchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SwitchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>[]
          }
          delete: {
            args: Prisma.SwitchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>
          }
          update: {
            args: Prisma.SwitchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>
          }
          deleteMany: {
            args: Prisma.SwitchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SwitchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SwitchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>[]
          }
          upsert: {
            args: Prisma.SwitchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchPayload>
          }
          aggregate: {
            args: Prisma.SwitchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSwitch>
          }
          groupBy: {
            args: Prisma.SwitchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SwitchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SwitchCountArgs<ExtArgs>
            result: $Utils.Optional<SwitchCountAggregateOutputType> | number
          }
        }
      }
      SwitchType: {
        payload: Prisma.$SwitchTypePayload<ExtArgs>
        fields: Prisma.SwitchTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SwitchTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SwitchTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>
          }
          findFirst: {
            args: Prisma.SwitchTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SwitchTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>
          }
          findMany: {
            args: Prisma.SwitchTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>[]
          }
          create: {
            args: Prisma.SwitchTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>
          }
          createMany: {
            args: Prisma.SwitchTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SwitchTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>[]
          }
          delete: {
            args: Prisma.SwitchTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>
          }
          update: {
            args: Prisma.SwitchTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>
          }
          deleteMany: {
            args: Prisma.SwitchTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SwitchTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SwitchTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>[]
          }
          upsert: {
            args: Prisma.SwitchTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwitchTypePayload>
          }
          aggregate: {
            args: Prisma.SwitchTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSwitchType>
          }
          groupBy: {
            args: Prisma.SwitchTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SwitchTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SwitchTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SwitchTypeCountAggregateOutputType> | number
          }
        }
      }
      Keycap: {
        payload: Prisma.$KeycapPayload<ExtArgs>
        fields: Prisma.KeycapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeycapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeycapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>
          }
          findFirst: {
            args: Prisma.KeycapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeycapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>
          }
          findMany: {
            args: Prisma.KeycapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>[]
          }
          create: {
            args: Prisma.KeycapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>
          }
          createMany: {
            args: Prisma.KeycapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeycapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>[]
          }
          delete: {
            args: Prisma.KeycapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>
          }
          update: {
            args: Prisma.KeycapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>
          }
          deleteMany: {
            args: Prisma.KeycapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeycapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeycapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>[]
          }
          upsert: {
            args: Prisma.KeycapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapPayload>
          }
          aggregate: {
            args: Prisma.KeycapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeycap>
          }
          groupBy: {
            args: Prisma.KeycapGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeycapGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeycapCountArgs<ExtArgs>
            result: $Utils.Optional<KeycapCountAggregateOutputType> | number
          }
        }
      }
      KeycapProfile: {
        payload: Prisma.$KeycapProfilePayload<ExtArgs>
        fields: Prisma.KeycapProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeycapProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeycapProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>
          }
          findFirst: {
            args: Prisma.KeycapProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeycapProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>
          }
          findMany: {
            args: Prisma.KeycapProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>[]
          }
          create: {
            args: Prisma.KeycapProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>
          }
          createMany: {
            args: Prisma.KeycapProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeycapProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>[]
          }
          delete: {
            args: Prisma.KeycapProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>
          }
          update: {
            args: Prisma.KeycapProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>
          }
          deleteMany: {
            args: Prisma.KeycapProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeycapProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeycapProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>[]
          }
          upsert: {
            args: Prisma.KeycapProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapProfilePayload>
          }
          aggregate: {
            args: Prisma.KeycapProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeycapProfile>
          }
          groupBy: {
            args: Prisma.KeycapProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeycapProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeycapProfileCountArgs<ExtArgs>
            result: $Utils.Optional<KeycapProfileCountAggregateOutputType> | number
          }
        }
      }
      KeycapMaterial: {
        payload: Prisma.$KeycapMaterialPayload<ExtArgs>
        fields: Prisma.KeycapMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeycapMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeycapMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>
          }
          findFirst: {
            args: Prisma.KeycapMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeycapMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>
          }
          findMany: {
            args: Prisma.KeycapMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>[]
          }
          create: {
            args: Prisma.KeycapMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>
          }
          createMany: {
            args: Prisma.KeycapMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeycapMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>[]
          }
          delete: {
            args: Prisma.KeycapMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>
          }
          update: {
            args: Prisma.KeycapMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>
          }
          deleteMany: {
            args: Prisma.KeycapMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeycapMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeycapMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>[]
          }
          upsert: {
            args: Prisma.KeycapMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeycapMaterialPayload>
          }
          aggregate: {
            args: Prisma.KeycapMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeycapMaterial>
          }
          groupBy: {
            args: Prisma.KeycapMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeycapMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeycapMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<KeycapMaterialCountAggregateOutputType> | number
          }
        }
      }
      Accessory: {
        payload: Prisma.$AccessoryPayload<ExtArgs>
        fields: Prisma.AccessoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>
          }
          findFirst: {
            args: Prisma.AccessoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>
          }
          findMany: {
            args: Prisma.AccessoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>[]
          }
          create: {
            args: Prisma.AccessoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>
          }
          createMany: {
            args: Prisma.AccessoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>[]
          }
          delete: {
            args: Prisma.AccessoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>
          }
          update: {
            args: Prisma.AccessoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>
          }
          deleteMany: {
            args: Prisma.AccessoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>[]
          }
          upsert: {
            args: Prisma.AccessoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryPayload>
          }
          aggregate: {
            args: Prisma.AccessoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessory>
          }
          groupBy: {
            args: Prisma.AccessoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessoryCountArgs<ExtArgs>
            result: $Utils.Optional<AccessoryCountAggregateOutputType> | number
          }
        }
      }
      AccessoryType: {
        payload: Prisma.$AccessoryTypePayload<ExtArgs>
        fields: Prisma.AccessoryTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessoryTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessoryTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          findFirst: {
            args: Prisma.AccessoryTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessoryTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          findMany: {
            args: Prisma.AccessoryTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>[]
          }
          create: {
            args: Prisma.AccessoryTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          createMany: {
            args: Prisma.AccessoryTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessoryTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>[]
          }
          delete: {
            args: Prisma.AccessoryTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          update: {
            args: Prisma.AccessoryTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          deleteMany: {
            args: Prisma.AccessoryTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessoryTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessoryTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>[]
          }
          upsert: {
            args: Prisma.AccessoryTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessoryTypePayload>
          }
          aggregate: {
            args: Prisma.AccessoryTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessoryType>
          }
          groupBy: {
            args: Prisma.AccessoryTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessoryTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessoryTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AccessoryTypeCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      Wishlist: {
        payload: Prisma.$WishlistPayload<ExtArgs>
        fields: Prisma.WishlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WishlistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlist>
          }
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number
          }
        }
      }
      WishlistItem: {
        payload: Prisma.$WishlistItemPayload<ExtArgs>
        fields: Prisma.WishlistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WishlistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlistItem>
          }
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      BillItem: {
        payload: Prisma.$BillItemPayload<ExtArgs>
        fields: Prisma.BillItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          findFirst: {
            args: Prisma.BillItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          findMany: {
            args: Prisma.BillItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>[]
          }
          create: {
            args: Prisma.BillItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          createMany: {
            args: Prisma.BillItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>[]
          }
          delete: {
            args: Prisma.BillItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          update: {
            args: Prisma.BillItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          deleteMany: {
            args: Prisma.BillItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>[]
          }
          upsert: {
            args: Prisma.BillItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillItemPayload>
          }
          aggregate: {
            args: Prisma.BillItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillItem>
          }
          groupBy: {
            args: Prisma.BillItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillItemCountArgs<ExtArgs>
            result: $Utils.Optional<BillItemCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      UserCoupon: {
        payload: Prisma.$UserCouponPayload<ExtArgs>
        fields: Prisma.UserCouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          findFirst: {
            args: Prisma.UserCouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          findMany: {
            args: Prisma.UserCouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[]
          }
          create: {
            args: Prisma.UserCouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          createMany: {
            args: Prisma.UserCouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[]
          }
          delete: {
            args: Prisma.UserCouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          update: {
            args: Prisma.UserCouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          deleteMany: {
            args: Prisma.UserCouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>[]
          }
          upsert: {
            args: Prisma.UserCouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCouponPayload>
          }
          aggregate: {
            args: Prisma.UserCouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCoupon>
          }
          groupBy: {
            args: Prisma.UserCouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCouponCountArgs<ExtArgs>
            result: $Utils.Optional<UserCouponCountAggregateOutputType> | number
          }
        }
      }
      UserBuild: {
        payload: Prisma.$UserBuildPayload<ExtArgs>
        fields: Prisma.UserBuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBuildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBuildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>
          }
          findFirst: {
            args: Prisma.UserBuildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBuildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>
          }
          findMany: {
            args: Prisma.UserBuildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>[]
          }
          create: {
            args: Prisma.UserBuildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>
          }
          createMany: {
            args: Prisma.UserBuildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBuildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>[]
          }
          delete: {
            args: Prisma.UserBuildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>
          }
          update: {
            args: Prisma.UserBuildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>
          }
          deleteMany: {
            args: Prisma.UserBuildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBuildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBuildUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>[]
          }
          upsert: {
            args: Prisma.UserBuildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildPayload>
          }
          aggregate: {
            args: Prisma.UserBuildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBuild>
          }
          groupBy: {
            args: Prisma.UserBuildGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBuildCountArgs<ExtArgs>
            result: $Utils.Optional<UserBuildCountAggregateOutputType> | number
          }
        }
      }
      UserBuildComponent: {
        payload: Prisma.$UserBuildComponentPayload<ExtArgs>
        fields: Prisma.UserBuildComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBuildComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBuildComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>
          }
          findFirst: {
            args: Prisma.UserBuildComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBuildComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>
          }
          findMany: {
            args: Prisma.UserBuildComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>[]
          }
          create: {
            args: Prisma.UserBuildComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>
          }
          createMany: {
            args: Prisma.UserBuildComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBuildComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>[]
          }
          delete: {
            args: Prisma.UserBuildComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>
          }
          update: {
            args: Prisma.UserBuildComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>
          }
          deleteMany: {
            args: Prisma.UserBuildComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBuildComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBuildComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>[]
          }
          upsert: {
            args: Prisma.UserBuildComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBuildComponentPayload>
          }
          aggregate: {
            args: Prisma.UserBuildComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBuildComponent>
          }
          groupBy: {
            args: Prisma.UserBuildComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBuildComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBuildComponentCountArgs<ExtArgs>
            result: $Utils.Optional<UserBuildComponentCountAggregateOutputType> | number
          }
        }
      }
      ComponentType: {
        payload: Prisma.$ComponentTypePayload<ExtArgs>
        fields: Prisma.ComponentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>
          }
          findFirst: {
            args: Prisma.ComponentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>
          }
          findMany: {
            args: Prisma.ComponentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>[]
          }
          create: {
            args: Prisma.ComponentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>
          }
          createMany: {
            args: Prisma.ComponentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>[]
          }
          delete: {
            args: Prisma.ComponentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>
          }
          update: {
            args: Prisma.ComponentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>
          }
          deleteMany: {
            args: Prisma.ComponentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComponentTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>[]
          }
          upsert: {
            args: Prisma.ComponentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentTypePayload>
          }
          aggregate: {
            args: Prisma.ComponentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponentType>
          }
          groupBy: {
            args: Prisma.ComponentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentTypeCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    product?: ProductOmit
    color?: ColorOmit
    keyboard?: KeyboardOmit
    layout?: LayoutOmit
    connectionType?: ConnectionTypeOmit
    switch?: SwitchOmit
    switchType?: SwitchTypeOmit
    keycap?: KeycapOmit
    keycapProfile?: KeycapProfileOmit
    keycapMaterial?: KeycapMaterialOmit
    accessory?: AccessoryOmit
    accessoryType?: AccessoryTypeOmit
    category?: CategoryOmit
    productCategory?: ProductCategoryOmit
    user?: UserOmit
    role?: RoleOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    wishlist?: WishlistOmit
    wishlistItem?: WishlistItemOmit
    bill?: BillOmit
    billItem?: BillItemOmit
    transaction?: TransactionOmit
    coupon?: CouponOmit
    userCoupon?: UserCouponOmit
    userBuild?: UserBuildOmit
    userBuildComponent?: UserBuildComponentOmit
    componentType?: ComponentTypeOmit
    productImage?: ProductImageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    ProductCategory: number
    WishlistItem: number
    BillItem: number
    UserBuildComponent: number
    ProductImage: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCountOutputTypeCountProductCategoryArgs
    WishlistItem?: boolean | ProductCountOutputTypeCountWishlistItemArgs
    BillItem?: boolean | ProductCountOutputTypeCountBillItemArgs
    UserBuildComponent?: boolean | ProductCountOutputTypeCountUserBuildComponentArgs
    ProductImage?: boolean | ProductCountOutputTypeCountProductImageArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBillItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountUserBuildComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBuildComponentWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }


  /**
   * Count Type KeyboardCountOutputType
   */

  export type KeyboardCountOutputType = {
    Color: number
  }

  export type KeyboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Color?: boolean | KeyboardCountOutputTypeCountColorArgs
  }

  // Custom InputTypes
  /**
   * KeyboardCountOutputType without action
   */
  export type KeyboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyboardCountOutputType
     */
    select?: KeyboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeyboardCountOutputType without action
   */
  export type KeyboardCountOutputTypeCountColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorWhereInput
  }


  /**
   * Count Type LayoutCountOutputType
   */

  export type LayoutCountOutputType = {
    Keyboard: number
  }

  export type LayoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keyboard?: boolean | LayoutCountOutputTypeCountKeyboardArgs
  }

  // Custom InputTypes
  /**
   * LayoutCountOutputType without action
   */
  export type LayoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutCountOutputType
     */
    select?: LayoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LayoutCountOutputType without action
   */
  export type LayoutCountOutputTypeCountKeyboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyboardWhereInput
  }


  /**
   * Count Type ConnectionTypeCountOutputType
   */

  export type ConnectionTypeCountOutputType = {
    Keyboard: number
  }

  export type ConnectionTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keyboard?: boolean | ConnectionTypeCountOutputTypeCountKeyboardArgs
  }

  // Custom InputTypes
  /**
   * ConnectionTypeCountOutputType without action
   */
  export type ConnectionTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionTypeCountOutputType
     */
    select?: ConnectionTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConnectionTypeCountOutputType without action
   */
  export type ConnectionTypeCountOutputTypeCountKeyboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyboardWhereInput
  }


  /**
   * Count Type SwitchTypeCountOutputType
   */

  export type SwitchTypeCountOutputType = {
    Switch: number
  }

  export type SwitchTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Switch?: boolean | SwitchTypeCountOutputTypeCountSwitchArgs
  }

  // Custom InputTypes
  /**
   * SwitchTypeCountOutputType without action
   */
  export type SwitchTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchTypeCountOutputType
     */
    select?: SwitchTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SwitchTypeCountOutputType without action
   */
  export type SwitchTypeCountOutputTypeCountSwitchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwitchWhereInput
  }


  /**
   * Count Type KeycapProfileCountOutputType
   */

  export type KeycapProfileCountOutputType = {
    Keycap: number
  }

  export type KeycapProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keycap?: boolean | KeycapProfileCountOutputTypeCountKeycapArgs
  }

  // Custom InputTypes
  /**
   * KeycapProfileCountOutputType without action
   */
  export type KeycapProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfileCountOutputType
     */
    select?: KeycapProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeycapProfileCountOutputType without action
   */
  export type KeycapProfileCountOutputTypeCountKeycapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeycapWhereInput
  }


  /**
   * Count Type KeycapMaterialCountOutputType
   */

  export type KeycapMaterialCountOutputType = {
    Keycap: number
  }

  export type KeycapMaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keycap?: boolean | KeycapMaterialCountOutputTypeCountKeycapArgs
  }

  // Custom InputTypes
  /**
   * KeycapMaterialCountOutputType without action
   */
  export type KeycapMaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterialCountOutputType
     */
    select?: KeycapMaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeycapMaterialCountOutputType without action
   */
  export type KeycapMaterialCountOutputTypeCountKeycapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeycapWhereInput
  }


  /**
   * Count Type AccessoryTypeCountOutputType
   */

  export type AccessoryTypeCountOutputType = {
    Accessory: number
  }

  export type AccessoryTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Accessory?: boolean | AccessoryTypeCountOutputTypeCountAccessoryArgs
  }

  // Custom InputTypes
  /**
   * AccessoryTypeCountOutputType without action
   */
  export type AccessoryTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryTypeCountOutputType
     */
    select?: AccessoryTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccessoryTypeCountOutputType without action
   */
  export type AccessoryTypeCountOutputTypeCountAccessoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    ProductCategory: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | CategoryCountOutputTypeCountProductCategoryArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Cart: number
    Wishlist: number
    Bill: number
    UserCoupon: number
    UserBuild: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cart?: boolean | UserCountOutputTypeCountCartArgs
    Wishlist?: boolean | UserCountOutputTypeCountWishlistArgs
    Bill?: boolean | UserCountOutputTypeCountBillArgs
    UserCoupon?: boolean | UserCountOutputTypeCountUserCouponArgs
    UserBuild?: boolean | UserCountOutputTypeCountUserBuildArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCouponWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBuildWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    CartItem: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | CartCountOutputTypeCountCartItemArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type WishlistCountOutputType
   */

  export type WishlistCountOutputType = {
    WishlistItem: number
  }

  export type WishlistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WishlistItem?: boolean | WishlistCountOutputTypeCountWishlistItemArgs
  }

  // Custom InputTypes
  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistCountOutputType
     */
    select?: WishlistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeCountWishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }


  /**
   * Count Type BillCountOutputType
   */

  export type BillCountOutputType = {
    BillItem: number
    Transaction: number
  }

  export type BillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillItem?: boolean | BillCountOutputTypeCountBillItemArgs
    Transaction?: boolean | BillCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillCountOutputType
     */
    select?: BillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountBillItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillItemWhereInput
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    UserCoupon: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserCoupon?: boolean | CouponCountOutputTypeCountUserCouponArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountUserCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCouponWhereInput
  }


  /**
   * Count Type UserBuildCountOutputType
   */

  export type UserBuildCountOutputType = {
    UserBuildComponent: number
  }

  export type UserBuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserBuildComponent?: boolean | UserBuildCountOutputTypeCountUserBuildComponentArgs
  }

  // Custom InputTypes
  /**
   * UserBuildCountOutputType without action
   */
  export type UserBuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildCountOutputType
     */
    select?: UserBuildCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserBuildCountOutputType without action
   */
  export type UserBuildCountOutputTypeCountUserBuildComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBuildComponentWhereInput
  }


  /**
   * Count Type ComponentTypeCountOutputType
   */

  export type ComponentTypeCountOutputType = {
    UserBuildComponent: number
  }

  export type ComponentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserBuildComponent?: boolean | ComponentTypeCountOutputTypeCountUserBuildComponentArgs
  }

  // Custom InputTypes
  /**
   * ComponentTypeCountOutputType without action
   */
  export type ComponentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentTypeCountOutputType
     */
    select?: ComponentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComponentTypeCountOutputType without action
   */
  export type ComponentTypeCountOutputTypeCountUserBuildComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBuildComponentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    sku: string | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    sku: string | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    sku: number
    stock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    sku?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    sku?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    sku?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string
    price: Decimal
    sku: string
    stock: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Keyboard?: boolean | Product$KeyboardArgs<ExtArgs>
    Switch?: boolean | Product$SwitchArgs<ExtArgs>
    Keycap?: boolean | Product$KeycapArgs<ExtArgs>
    Accessory?: boolean | Product$AccessoryArgs<ExtArgs>
    ProductCategory?: boolean | Product$ProductCategoryArgs<ExtArgs>
    WishlistItem?: boolean | Product$WishlistItemArgs<ExtArgs>
    BillItem?: boolean | Product$BillItemArgs<ExtArgs>
    UserBuildComponent?: boolean | Product$UserBuildComponentArgs<ExtArgs>
    ProductImage?: boolean | Product$ProductImageArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "sku" | "stock" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keyboard?: boolean | Product$KeyboardArgs<ExtArgs>
    Switch?: boolean | Product$SwitchArgs<ExtArgs>
    Keycap?: boolean | Product$KeycapArgs<ExtArgs>
    Accessory?: boolean | Product$AccessoryArgs<ExtArgs>
    ProductCategory?: boolean | Product$ProductCategoryArgs<ExtArgs>
    WishlistItem?: boolean | Product$WishlistItemArgs<ExtArgs>
    BillItem?: boolean | Product$BillItemArgs<ExtArgs>
    UserBuildComponent?: boolean | Product$UserBuildComponentArgs<ExtArgs>
    ProductImage?: boolean | Product$ProductImageArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      Keyboard: Prisma.$KeyboardPayload<ExtArgs> | null
      Switch: Prisma.$SwitchPayload<ExtArgs> | null
      Keycap: Prisma.$KeycapPayload<ExtArgs> | null
      Accessory: Prisma.$AccessoryPayload<ExtArgs> | null
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>[]
      WishlistItem: Prisma.$WishlistItemPayload<ExtArgs>[]
      BillItem: Prisma.$BillItemPayload<ExtArgs>[]
      UserBuildComponent: Prisma.$UserBuildComponentPayload<ExtArgs>[]
      ProductImage: Prisma.$ProductImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      price: Prisma.Decimal
      sku: string
      stock: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Keyboard<T extends Product$KeyboardArgs<ExtArgs> = {}>(args?: Subset<T, Product$KeyboardArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Switch<T extends Product$SwitchArgs<ExtArgs> = {}>(args?: Subset<T, Product$SwitchArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Keycap<T extends Product$KeycapArgs<ExtArgs> = {}>(args?: Subset<T, Product$KeycapArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Accessory<T extends Product$AccessoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$AccessoryArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProductCategory<T extends Product$ProductCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WishlistItem<T extends Product$WishlistItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$WishlistItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BillItem<T extends Product$BillItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$BillItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserBuildComponent<T extends Product$UserBuildComponentArgs<ExtArgs> = {}>(args?: Subset<T, Product$UserBuildComponentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductImage<T extends Product$ProductImageArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.Keyboard
   */
  export type Product$KeyboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    where?: KeyboardWhereInput
  }

  /**
   * Product.Switch
   */
  export type Product$SwitchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    where?: SwitchWhereInput
  }

  /**
   * Product.Keycap
   */
  export type Product$KeycapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    where?: KeycapWhereInput
  }

  /**
   * Product.Accessory
   */
  export type Product$AccessoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    where?: AccessoryWhereInput
  }

  /**
   * Product.ProductCategory
   */
  export type Product$ProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Product.WishlistItem
   */
  export type Product$WishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * Product.BillItem
   */
  export type Product$BillItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    where?: BillItemWhereInput
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    cursor?: BillItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * Product.UserBuildComponent
   */
  export type Product$UserBuildComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    where?: UserBuildComponentWhereInput
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    cursor?: UserBuildComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBuildComponentScalarFieldEnum | UserBuildComponentScalarFieldEnum[]
  }

  /**
   * Product.ProductImage
   */
  export type Product$ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Color
   */

  export type AggregateColor = {
    _count: ColorCountAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  export type ColorMinAggregateOutputType = {
    id: string | null
    keyboardId: string | null
    hex: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColorMaxAggregateOutputType = {
    id: string | null
    keyboardId: string | null
    hex: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColorCountAggregateOutputType = {
    id: number
    keyboardId: number
    hex: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ColorMinAggregateInputType = {
    id?: true
    keyboardId?: true
    hex?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColorMaxAggregateInputType = {
    id?: true
    keyboardId?: true
    hex?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColorCountAggregateInputType = {
    id?: true
    keyboardId?: true
    hex?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ColorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Color to aggregate.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colors
    **/
    _count?: true | ColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorMaxAggregateInputType
  }

  export type GetColorAggregateType<T extends ColorAggregateArgs> = {
        [P in keyof T & keyof AggregateColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColor[P]>
      : GetScalarType<T[P], AggregateColor[P]>
  }




  export type ColorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorWhereInput
    orderBy?: ColorOrderByWithAggregationInput | ColorOrderByWithAggregationInput[]
    by: ColorScalarFieldEnum[] | ColorScalarFieldEnum
    having?: ColorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorCountAggregateInputType | true
    _min?: ColorMinAggregateInputType
    _max?: ColorMaxAggregateInputType
  }

  export type ColorGroupByOutputType = {
    id: string
    keyboardId: string
    hex: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ColorCountAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  type GetColorGroupByPayload<T extends ColorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorGroupByOutputType[P]>
            : GetScalarType<T[P], ColorGroupByOutputType[P]>
        }
      >
    >


  export type ColorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyboardId?: boolean
    hex?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keyboard?: boolean | KeyboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyboardId?: boolean
    hex?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keyboard?: boolean | KeyboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyboardId?: boolean
    hex?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keyboard?: boolean | KeyboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectScalar = {
    id?: boolean
    keyboardId?: boolean
    hex?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ColorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyboardId" | "hex" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["color"]>
  export type ColorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyboard?: boolean | KeyboardDefaultArgs<ExtArgs>
  }
  export type ColorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyboard?: boolean | KeyboardDefaultArgs<ExtArgs>
  }
  export type ColorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyboard?: boolean | KeyboardDefaultArgs<ExtArgs>
  }

  export type $ColorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Color"
    objects: {
      keyboard: Prisma.$KeyboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyboardId: string
      hex: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["color"]>
    composites: {}
  }

  type ColorGetPayload<S extends boolean | null | undefined | ColorDefaultArgs> = $Result.GetResult<Prisma.$ColorPayload, S>

  type ColorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColorCountAggregateInputType | true
    }

  export interface ColorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Color'], meta: { name: 'Color' } }
    /**
     * Find zero or one Color that matches the filter.
     * @param {ColorFindUniqueArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColorFindUniqueArgs>(args: SelectSubset<T, ColorFindUniqueArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Color that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColorFindUniqueOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColorFindUniqueOrThrowArgs>(args: SelectSubset<T, ColorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Color that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindFirstArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColorFindFirstArgs>(args?: SelectSubset<T, ColorFindFirstArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Color that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindFirstOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColorFindFirstOrThrowArgs>(args?: SelectSubset<T, ColorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colors
     * const colors = await prisma.color.findMany()
     * 
     * // Get first 10 Colors
     * const colors = await prisma.color.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colorWithIdOnly = await prisma.color.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColorFindManyArgs>(args?: SelectSubset<T, ColorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Color.
     * @param {ColorCreateArgs} args - Arguments to create a Color.
     * @example
     * // Create one Color
     * const Color = await prisma.color.create({
     *   data: {
     *     // ... data to create a Color
     *   }
     * })
     * 
     */
    create<T extends ColorCreateArgs>(args: SelectSubset<T, ColorCreateArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Colors.
     * @param {ColorCreateManyArgs} args - Arguments to create many Colors.
     * @example
     * // Create many Colors
     * const color = await prisma.color.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColorCreateManyArgs>(args?: SelectSubset<T, ColorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Colors and returns the data saved in the database.
     * @param {ColorCreateManyAndReturnArgs} args - Arguments to create many Colors.
     * @example
     * // Create many Colors
     * const color = await prisma.color.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Colors and only return the `id`
     * const colorWithIdOnly = await prisma.color.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColorCreateManyAndReturnArgs>(args?: SelectSubset<T, ColorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Color.
     * @param {ColorDeleteArgs} args - Arguments to delete one Color.
     * @example
     * // Delete one Color
     * const Color = await prisma.color.delete({
     *   where: {
     *     // ... filter to delete one Color
     *   }
     * })
     * 
     */
    delete<T extends ColorDeleteArgs>(args: SelectSubset<T, ColorDeleteArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Color.
     * @param {ColorUpdateArgs} args - Arguments to update one Color.
     * @example
     * // Update one Color
     * const color = await prisma.color.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColorUpdateArgs>(args: SelectSubset<T, ColorUpdateArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Colors.
     * @param {ColorDeleteManyArgs} args - Arguments to filter Colors to delete.
     * @example
     * // Delete a few Colors
     * const { count } = await prisma.color.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColorDeleteManyArgs>(args?: SelectSubset<T, ColorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColorUpdateManyArgs>(args: SelectSubset<T, ColorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors and returns the data updated in the database.
     * @param {ColorUpdateManyAndReturnArgs} args - Arguments to update many Colors.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Colors and only return the `id`
     * const colorWithIdOnly = await prisma.color.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColorUpdateManyAndReturnArgs>(args: SelectSubset<T, ColorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Color.
     * @param {ColorUpsertArgs} args - Arguments to update or create a Color.
     * @example
     * // Update or create a Color
     * const color = await prisma.color.upsert({
     *   create: {
     *     // ... data to create a Color
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Color we want to update
     *   }
     * })
     */
    upsert<T extends ColorUpsertArgs>(args: SelectSubset<T, ColorUpsertArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorCountArgs} args - Arguments to filter Colors to count.
     * @example
     * // Count the number of Colors
     * const count = await prisma.color.count({
     *   where: {
     *     // ... the filter for the Colors we want to count
     *   }
     * })
    **/
    count<T extends ColorCountArgs>(
      args?: Subset<T, ColorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorAggregateArgs>(args: Subset<T, ColorAggregateArgs>): Prisma.PrismaPromise<GetColorAggregateType<T>>

    /**
     * Group by Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColorGroupByArgs['orderBy'] }
        : { orderBy?: ColorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Color model
   */
  readonly fields: ColorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Color.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keyboard<T extends KeyboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KeyboardDefaultArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Color model
   */
  interface ColorFieldRefs {
    readonly id: FieldRef<"Color", 'String'>
    readonly keyboardId: FieldRef<"Color", 'String'>
    readonly hex: FieldRef<"Color", 'String'>
    readonly name: FieldRef<"Color", 'String'>
    readonly createdAt: FieldRef<"Color", 'DateTime'>
    readonly updatedAt: FieldRef<"Color", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Color findUnique
   */
  export type ColorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color findUniqueOrThrow
   */
  export type ColorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color findFirst
   */
  export type ColorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color findFirstOrThrow
   */
  export type ColorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color findMany
   */
  export type ColorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color create
   */
  export type ColorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The data needed to create a Color.
     */
    data: XOR<ColorCreateInput, ColorUncheckedCreateInput>
  }

  /**
   * Color createMany
   */
  export type ColorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colors.
     */
    data: ColorCreateManyInput | ColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Color createManyAndReturn
   */
  export type ColorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * The data used to create many Colors.
     */
    data: ColorCreateManyInput | ColorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Color update
   */
  export type ColorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The data needed to update a Color.
     */
    data: XOR<ColorUpdateInput, ColorUncheckedUpdateInput>
    /**
     * Choose, which Color to update.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color updateMany
   */
  export type ColorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to update.
     */
    limit?: number
  }

  /**
   * Color updateManyAndReturn
   */
  export type ColorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Color upsert
   */
  export type ColorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The filter to search for the Color to update in case it exists.
     */
    where: ColorWhereUniqueInput
    /**
     * In case the Color found by the `where` argument doesn't exist, create a new Color with this data.
     */
    create: XOR<ColorCreateInput, ColorUncheckedCreateInput>
    /**
     * In case the Color was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColorUpdateInput, ColorUncheckedUpdateInput>
  }

  /**
   * Color delete
   */
  export type ColorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter which Color to delete.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color deleteMany
   */
  export type ColorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colors to delete
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to delete.
     */
    limit?: number
  }

  /**
   * Color without action
   */
  export type ColorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
  }


  /**
   * Model Keyboard
   */

  export type AggregateKeyboard = {
    _count: KeyboardCountAggregateOutputType | null
    _min: KeyboardMinAggregateOutputType | null
    _max: KeyboardMaxAggregateOutputType | null
  }

  export type KeyboardMinAggregateOutputType = {
    id: string | null
    productId: string | null
    layoutId: string | null
    connectionTypeId: string | null
    isHotswapable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeyboardMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    layoutId: string | null
    connectionTypeId: string | null
    isHotswapable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeyboardCountAggregateOutputType = {
    id: number
    productId: number
    layoutId: number
    connectionTypeId: number
    isHotswapable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeyboardMinAggregateInputType = {
    id?: true
    productId?: true
    layoutId?: true
    connectionTypeId?: true
    isHotswapable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeyboardMaxAggregateInputType = {
    id?: true
    productId?: true
    layoutId?: true
    connectionTypeId?: true
    isHotswapable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeyboardCountAggregateInputType = {
    id?: true
    productId?: true
    layoutId?: true
    connectionTypeId?: true
    isHotswapable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeyboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keyboard to aggregate.
     */
    where?: KeyboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keyboards to fetch.
     */
    orderBy?: KeyboardOrderByWithRelationInput | KeyboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keyboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keyboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Keyboards
    **/
    _count?: true | KeyboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyboardMaxAggregateInputType
  }

  export type GetKeyboardAggregateType<T extends KeyboardAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyboard[P]>
      : GetScalarType<T[P], AggregateKeyboard[P]>
  }




  export type KeyboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyboardWhereInput
    orderBy?: KeyboardOrderByWithAggregationInput | KeyboardOrderByWithAggregationInput[]
    by: KeyboardScalarFieldEnum[] | KeyboardScalarFieldEnum
    having?: KeyboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyboardCountAggregateInputType | true
    _min?: KeyboardMinAggregateInputType
    _max?: KeyboardMaxAggregateInputType
  }

  export type KeyboardGroupByOutputType = {
    id: string
    productId: string
    layoutId: string
    connectionTypeId: string
    isHotswapable: boolean
    createdAt: Date
    updatedAt: Date
    _count: KeyboardCountAggregateOutputType | null
    _min: KeyboardMinAggregateOutputType | null
    _max: KeyboardMaxAggregateOutputType | null
  }

  type GetKeyboardGroupByPayload<T extends KeyboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyboardGroupByOutputType[P]>
            : GetScalarType<T[P], KeyboardGroupByOutputType[P]>
        }
      >
    >


  export type KeyboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    layoutId?: boolean
    connectionTypeId?: boolean
    isHotswapable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    connectionType?: boolean | ConnectionTypeDefaultArgs<ExtArgs>
    Color?: boolean | Keyboard$ColorArgs<ExtArgs>
    _count?: boolean | KeyboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyboard"]>

  export type KeyboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    layoutId?: boolean
    connectionTypeId?: boolean
    isHotswapable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    connectionType?: boolean | ConnectionTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyboard"]>

  export type KeyboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    layoutId?: boolean
    connectionTypeId?: boolean
    isHotswapable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    connectionType?: boolean | ConnectionTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyboard"]>

  export type KeyboardSelectScalar = {
    id?: boolean
    productId?: boolean
    layoutId?: boolean
    connectionTypeId?: boolean
    isHotswapable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeyboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "layoutId" | "connectionTypeId" | "isHotswapable" | "createdAt" | "updatedAt", ExtArgs["result"]["keyboard"]>
  export type KeyboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    connectionType?: boolean | ConnectionTypeDefaultArgs<ExtArgs>
    Color?: boolean | Keyboard$ColorArgs<ExtArgs>
    _count?: boolean | KeyboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeyboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    connectionType?: boolean | ConnectionTypeDefaultArgs<ExtArgs>
  }
  export type KeyboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    connectionType?: boolean | ConnectionTypeDefaultArgs<ExtArgs>
  }

  export type $KeyboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keyboard"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      layout: Prisma.$LayoutPayload<ExtArgs>
      connectionType: Prisma.$ConnectionTypePayload<ExtArgs>
      Color: Prisma.$ColorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      layoutId: string
      connectionTypeId: string
      isHotswapable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keyboard"]>
    composites: {}
  }

  type KeyboardGetPayload<S extends boolean | null | undefined | KeyboardDefaultArgs> = $Result.GetResult<Prisma.$KeyboardPayload, S>

  type KeyboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeyboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeyboardCountAggregateInputType | true
    }

  export interface KeyboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keyboard'], meta: { name: 'Keyboard' } }
    /**
     * Find zero or one Keyboard that matches the filter.
     * @param {KeyboardFindUniqueArgs} args - Arguments to find a Keyboard
     * @example
     * // Get one Keyboard
     * const keyboard = await prisma.keyboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyboardFindUniqueArgs>(args: SelectSubset<T, KeyboardFindUniqueArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Keyboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeyboardFindUniqueOrThrowArgs} args - Arguments to find a Keyboard
     * @example
     * // Get one Keyboard
     * const keyboard = await prisma.keyboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyboardFindUniqueOrThrowArgs>(args: SelectSubset<T, KeyboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keyboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardFindFirstArgs} args - Arguments to find a Keyboard
     * @example
     * // Get one Keyboard
     * const keyboard = await prisma.keyboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyboardFindFirstArgs>(args?: SelectSubset<T, KeyboardFindFirstArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keyboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardFindFirstOrThrowArgs} args - Arguments to find a Keyboard
     * @example
     * // Get one Keyboard
     * const keyboard = await prisma.keyboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyboardFindFirstOrThrowArgs>(args?: SelectSubset<T, KeyboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keyboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keyboards
     * const keyboards = await prisma.keyboard.findMany()
     * 
     * // Get first 10 Keyboards
     * const keyboards = await prisma.keyboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyboardWithIdOnly = await prisma.keyboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeyboardFindManyArgs>(args?: SelectSubset<T, KeyboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Keyboard.
     * @param {KeyboardCreateArgs} args - Arguments to create a Keyboard.
     * @example
     * // Create one Keyboard
     * const Keyboard = await prisma.keyboard.create({
     *   data: {
     *     // ... data to create a Keyboard
     *   }
     * })
     * 
     */
    create<T extends KeyboardCreateArgs>(args: SelectSubset<T, KeyboardCreateArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Keyboards.
     * @param {KeyboardCreateManyArgs} args - Arguments to create many Keyboards.
     * @example
     * // Create many Keyboards
     * const keyboard = await prisma.keyboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeyboardCreateManyArgs>(args?: SelectSubset<T, KeyboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keyboards and returns the data saved in the database.
     * @param {KeyboardCreateManyAndReturnArgs} args - Arguments to create many Keyboards.
     * @example
     * // Create many Keyboards
     * const keyboard = await prisma.keyboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keyboards and only return the `id`
     * const keyboardWithIdOnly = await prisma.keyboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeyboardCreateManyAndReturnArgs>(args?: SelectSubset<T, KeyboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Keyboard.
     * @param {KeyboardDeleteArgs} args - Arguments to delete one Keyboard.
     * @example
     * // Delete one Keyboard
     * const Keyboard = await prisma.keyboard.delete({
     *   where: {
     *     // ... filter to delete one Keyboard
     *   }
     * })
     * 
     */
    delete<T extends KeyboardDeleteArgs>(args: SelectSubset<T, KeyboardDeleteArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Keyboard.
     * @param {KeyboardUpdateArgs} args - Arguments to update one Keyboard.
     * @example
     * // Update one Keyboard
     * const keyboard = await prisma.keyboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeyboardUpdateArgs>(args: SelectSubset<T, KeyboardUpdateArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Keyboards.
     * @param {KeyboardDeleteManyArgs} args - Arguments to filter Keyboards to delete.
     * @example
     * // Delete a few Keyboards
     * const { count } = await prisma.keyboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeyboardDeleteManyArgs>(args?: SelectSubset<T, KeyboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keyboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keyboards
     * const keyboard = await prisma.keyboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeyboardUpdateManyArgs>(args: SelectSubset<T, KeyboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keyboards and returns the data updated in the database.
     * @param {KeyboardUpdateManyAndReturnArgs} args - Arguments to update many Keyboards.
     * @example
     * // Update many Keyboards
     * const keyboard = await prisma.keyboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Keyboards and only return the `id`
     * const keyboardWithIdOnly = await prisma.keyboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeyboardUpdateManyAndReturnArgs>(args: SelectSubset<T, KeyboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Keyboard.
     * @param {KeyboardUpsertArgs} args - Arguments to update or create a Keyboard.
     * @example
     * // Update or create a Keyboard
     * const keyboard = await prisma.keyboard.upsert({
     *   create: {
     *     // ... data to create a Keyboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyboard we want to update
     *   }
     * })
     */
    upsert<T extends KeyboardUpsertArgs>(args: SelectSubset<T, KeyboardUpsertArgs<ExtArgs>>): Prisma__KeyboardClient<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Keyboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardCountArgs} args - Arguments to filter Keyboards to count.
     * @example
     * // Count the number of Keyboards
     * const count = await prisma.keyboard.count({
     *   where: {
     *     // ... the filter for the Keyboards we want to count
     *   }
     * })
    **/
    count<T extends KeyboardCountArgs>(
      args?: Subset<T, KeyboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyboardAggregateArgs>(args: Subset<T, KeyboardAggregateArgs>): Prisma.PrismaPromise<GetKeyboardAggregateType<T>>

    /**
     * Group by Keyboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyboardGroupByArgs['orderBy'] }
        : { orderBy?: KeyboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keyboard model
   */
  readonly fields: KeyboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keyboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    layout<T extends LayoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LayoutDefaultArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    connectionType<T extends ConnectionTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConnectionTypeDefaultArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Color<T extends Keyboard$ColorArgs<ExtArgs> = {}>(args?: Subset<T, Keyboard$ColorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keyboard model
   */
  interface KeyboardFieldRefs {
    readonly id: FieldRef<"Keyboard", 'String'>
    readonly productId: FieldRef<"Keyboard", 'String'>
    readonly layoutId: FieldRef<"Keyboard", 'String'>
    readonly connectionTypeId: FieldRef<"Keyboard", 'String'>
    readonly isHotswapable: FieldRef<"Keyboard", 'Boolean'>
    readonly createdAt: FieldRef<"Keyboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Keyboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Keyboard findUnique
   */
  export type KeyboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * Filter, which Keyboard to fetch.
     */
    where: KeyboardWhereUniqueInput
  }

  /**
   * Keyboard findUniqueOrThrow
   */
  export type KeyboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * Filter, which Keyboard to fetch.
     */
    where: KeyboardWhereUniqueInput
  }

  /**
   * Keyboard findFirst
   */
  export type KeyboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * Filter, which Keyboard to fetch.
     */
    where?: KeyboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keyboards to fetch.
     */
    orderBy?: KeyboardOrderByWithRelationInput | KeyboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keyboards.
     */
    cursor?: KeyboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keyboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keyboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keyboards.
     */
    distinct?: KeyboardScalarFieldEnum | KeyboardScalarFieldEnum[]
  }

  /**
   * Keyboard findFirstOrThrow
   */
  export type KeyboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * Filter, which Keyboard to fetch.
     */
    where?: KeyboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keyboards to fetch.
     */
    orderBy?: KeyboardOrderByWithRelationInput | KeyboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keyboards.
     */
    cursor?: KeyboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keyboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keyboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keyboards.
     */
    distinct?: KeyboardScalarFieldEnum | KeyboardScalarFieldEnum[]
  }

  /**
   * Keyboard findMany
   */
  export type KeyboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * Filter, which Keyboards to fetch.
     */
    where?: KeyboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keyboards to fetch.
     */
    orderBy?: KeyboardOrderByWithRelationInput | KeyboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Keyboards.
     */
    cursor?: KeyboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keyboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keyboards.
     */
    skip?: number
    distinct?: KeyboardScalarFieldEnum | KeyboardScalarFieldEnum[]
  }

  /**
   * Keyboard create
   */
  export type KeyboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Keyboard.
     */
    data: XOR<KeyboardCreateInput, KeyboardUncheckedCreateInput>
  }

  /**
   * Keyboard createMany
   */
  export type KeyboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Keyboards.
     */
    data: KeyboardCreateManyInput | KeyboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keyboard createManyAndReturn
   */
  export type KeyboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * The data used to create many Keyboards.
     */
    data: KeyboardCreateManyInput | KeyboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyboard update
   */
  export type KeyboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Keyboard.
     */
    data: XOR<KeyboardUpdateInput, KeyboardUncheckedUpdateInput>
    /**
     * Choose, which Keyboard to update.
     */
    where: KeyboardWhereUniqueInput
  }

  /**
   * Keyboard updateMany
   */
  export type KeyboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Keyboards.
     */
    data: XOR<KeyboardUpdateManyMutationInput, KeyboardUncheckedUpdateManyInput>
    /**
     * Filter which Keyboards to update
     */
    where?: KeyboardWhereInput
    /**
     * Limit how many Keyboards to update.
     */
    limit?: number
  }

  /**
   * Keyboard updateManyAndReturn
   */
  export type KeyboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * The data used to update Keyboards.
     */
    data: XOR<KeyboardUpdateManyMutationInput, KeyboardUncheckedUpdateManyInput>
    /**
     * Filter which Keyboards to update
     */
    where?: KeyboardWhereInput
    /**
     * Limit how many Keyboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyboard upsert
   */
  export type KeyboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Keyboard to update in case it exists.
     */
    where: KeyboardWhereUniqueInput
    /**
     * In case the Keyboard found by the `where` argument doesn't exist, create a new Keyboard with this data.
     */
    create: XOR<KeyboardCreateInput, KeyboardUncheckedCreateInput>
    /**
     * In case the Keyboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyboardUpdateInput, KeyboardUncheckedUpdateInput>
  }

  /**
   * Keyboard delete
   */
  export type KeyboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    /**
     * Filter which Keyboard to delete.
     */
    where: KeyboardWhereUniqueInput
  }

  /**
   * Keyboard deleteMany
   */
  export type KeyboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keyboards to delete
     */
    where?: KeyboardWhereInput
    /**
     * Limit how many Keyboards to delete.
     */
    limit?: number
  }

  /**
   * Keyboard.Color
   */
  export type Keyboard$ColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    cursor?: ColorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Keyboard without action
   */
  export type KeyboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
  }


  /**
   * Model Layout
   */

  export type AggregateLayout = {
    _count: LayoutCountAggregateOutputType | null
    _min: LayoutMinAggregateOutputType | null
    _max: LayoutMaxAggregateOutputType | null
  }

  export type LayoutMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayoutMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayoutCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LayoutMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayoutMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayoutCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Layout to aggregate.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Layouts
    **/
    _count?: true | LayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LayoutMaxAggregateInputType
  }

  export type GetLayoutAggregateType<T extends LayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateLayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLayout[P]>
      : GetScalarType<T[P], AggregateLayout[P]>
  }




  export type LayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayoutWhereInput
    orderBy?: LayoutOrderByWithAggregationInput | LayoutOrderByWithAggregationInput[]
    by: LayoutScalarFieldEnum[] | LayoutScalarFieldEnum
    having?: LayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LayoutCountAggregateInputType | true
    _min?: LayoutMinAggregateInputType
    _max?: LayoutMaxAggregateInputType
  }

  export type LayoutGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LayoutCountAggregateOutputType | null
    _min: LayoutMinAggregateOutputType | null
    _max: LayoutMaxAggregateOutputType | null
  }

  type GetLayoutGroupByPayload<T extends LayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LayoutGroupByOutputType[P]>
            : GetScalarType<T[P], LayoutGroupByOutputType[P]>
        }
      >
    >


  export type LayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Keyboard?: boolean | Layout$KeyboardArgs<ExtArgs>
    _count?: boolean | LayoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layout"]>

  export type LayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["layout"]>

  export type LayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["layout"]>

  export type LayoutSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["layout"]>
  export type LayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keyboard?: boolean | Layout$KeyboardArgs<ExtArgs>
    _count?: boolean | LayoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Layout"
    objects: {
      Keyboard: Prisma.$KeyboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["layout"]>
    composites: {}
  }

  type LayoutGetPayload<S extends boolean | null | undefined | LayoutDefaultArgs> = $Result.GetResult<Prisma.$LayoutPayload, S>

  type LayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LayoutCountAggregateInputType | true
    }

  export interface LayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Layout'], meta: { name: 'Layout' } }
    /**
     * Find zero or one Layout that matches the filter.
     * @param {LayoutFindUniqueArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LayoutFindUniqueArgs>(args: SelectSubset<T, LayoutFindUniqueArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Layout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LayoutFindUniqueOrThrowArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, LayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Layout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutFindFirstArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LayoutFindFirstArgs>(args?: SelectSubset<T, LayoutFindFirstArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Layout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutFindFirstOrThrowArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, LayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Layouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Layouts
     * const layouts = await prisma.layout.findMany()
     * 
     * // Get first 10 Layouts
     * const layouts = await prisma.layout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const layoutWithIdOnly = await prisma.layout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LayoutFindManyArgs>(args?: SelectSubset<T, LayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Layout.
     * @param {LayoutCreateArgs} args - Arguments to create a Layout.
     * @example
     * // Create one Layout
     * const Layout = await prisma.layout.create({
     *   data: {
     *     // ... data to create a Layout
     *   }
     * })
     * 
     */
    create<T extends LayoutCreateArgs>(args: SelectSubset<T, LayoutCreateArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Layouts.
     * @param {LayoutCreateManyArgs} args - Arguments to create many Layouts.
     * @example
     * // Create many Layouts
     * const layout = await prisma.layout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LayoutCreateManyArgs>(args?: SelectSubset<T, LayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Layouts and returns the data saved in the database.
     * @param {LayoutCreateManyAndReturnArgs} args - Arguments to create many Layouts.
     * @example
     * // Create many Layouts
     * const layout = await prisma.layout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Layouts and only return the `id`
     * const layoutWithIdOnly = await prisma.layout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, LayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Layout.
     * @param {LayoutDeleteArgs} args - Arguments to delete one Layout.
     * @example
     * // Delete one Layout
     * const Layout = await prisma.layout.delete({
     *   where: {
     *     // ... filter to delete one Layout
     *   }
     * })
     * 
     */
    delete<T extends LayoutDeleteArgs>(args: SelectSubset<T, LayoutDeleteArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Layout.
     * @param {LayoutUpdateArgs} args - Arguments to update one Layout.
     * @example
     * // Update one Layout
     * const layout = await prisma.layout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LayoutUpdateArgs>(args: SelectSubset<T, LayoutUpdateArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Layouts.
     * @param {LayoutDeleteManyArgs} args - Arguments to filter Layouts to delete.
     * @example
     * // Delete a few Layouts
     * const { count } = await prisma.layout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LayoutDeleteManyArgs>(args?: SelectSubset<T, LayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Layouts
     * const layout = await prisma.layout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LayoutUpdateManyArgs>(args: SelectSubset<T, LayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layouts and returns the data updated in the database.
     * @param {LayoutUpdateManyAndReturnArgs} args - Arguments to update many Layouts.
     * @example
     * // Update many Layouts
     * const layout = await prisma.layout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Layouts and only return the `id`
     * const layoutWithIdOnly = await prisma.layout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, LayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Layout.
     * @param {LayoutUpsertArgs} args - Arguments to update or create a Layout.
     * @example
     * // Update or create a Layout
     * const layout = await prisma.layout.upsert({
     *   create: {
     *     // ... data to create a Layout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Layout we want to update
     *   }
     * })
     */
    upsert<T extends LayoutUpsertArgs>(args: SelectSubset<T, LayoutUpsertArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Layouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutCountArgs} args - Arguments to filter Layouts to count.
     * @example
     * // Count the number of Layouts
     * const count = await prisma.layout.count({
     *   where: {
     *     // ... the filter for the Layouts we want to count
     *   }
     * })
    **/
    count<T extends LayoutCountArgs>(
      args?: Subset<T, LayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Layout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LayoutAggregateArgs>(args: Subset<T, LayoutAggregateArgs>): Prisma.PrismaPromise<GetLayoutAggregateType<T>>

    /**
     * Group by Layout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LayoutGroupByArgs['orderBy'] }
        : { orderBy?: LayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Layout model
   */
  readonly fields: LayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Layout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Keyboard<T extends Layout$KeyboardArgs<ExtArgs> = {}>(args?: Subset<T, Layout$KeyboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Layout model
   */
  interface LayoutFieldRefs {
    readonly id: FieldRef<"Layout", 'String'>
    readonly name: FieldRef<"Layout", 'String'>
    readonly createdAt: FieldRef<"Layout", 'DateTime'>
    readonly updatedAt: FieldRef<"Layout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Layout findUnique
   */
  export type LayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout findUniqueOrThrow
   */
  export type LayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout findFirst
   */
  export type LayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Layouts.
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Layouts.
     */
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Layout findFirstOrThrow
   */
  export type LayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Layouts.
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Layouts.
     */
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Layout findMany
   */
  export type LayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layouts to fetch.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Layouts.
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Layout create
   */
  export type LayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Layout.
     */
    data: XOR<LayoutCreateInput, LayoutUncheckedCreateInput>
  }

  /**
   * Layout createMany
   */
  export type LayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Layouts.
     */
    data: LayoutCreateManyInput | LayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Layout createManyAndReturn
   */
  export type LayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * The data used to create many Layouts.
     */
    data: LayoutCreateManyInput | LayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Layout update
   */
  export type LayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Layout.
     */
    data: XOR<LayoutUpdateInput, LayoutUncheckedUpdateInput>
    /**
     * Choose, which Layout to update.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout updateMany
   */
  export type LayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Layouts.
     */
    data: XOR<LayoutUpdateManyMutationInput, LayoutUncheckedUpdateManyInput>
    /**
     * Filter which Layouts to update
     */
    where?: LayoutWhereInput
    /**
     * Limit how many Layouts to update.
     */
    limit?: number
  }

  /**
   * Layout updateManyAndReturn
   */
  export type LayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * The data used to update Layouts.
     */
    data: XOR<LayoutUpdateManyMutationInput, LayoutUncheckedUpdateManyInput>
    /**
     * Filter which Layouts to update
     */
    where?: LayoutWhereInput
    /**
     * Limit how many Layouts to update.
     */
    limit?: number
  }

  /**
   * Layout upsert
   */
  export type LayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Layout to update in case it exists.
     */
    where: LayoutWhereUniqueInput
    /**
     * In case the Layout found by the `where` argument doesn't exist, create a new Layout with this data.
     */
    create: XOR<LayoutCreateInput, LayoutUncheckedCreateInput>
    /**
     * In case the Layout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LayoutUpdateInput, LayoutUncheckedUpdateInput>
  }

  /**
   * Layout delete
   */
  export type LayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter which Layout to delete.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout deleteMany
   */
  export type LayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Layouts to delete
     */
    where?: LayoutWhereInput
    /**
     * Limit how many Layouts to delete.
     */
    limit?: number
  }

  /**
   * Layout.Keyboard
   */
  export type Layout$KeyboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    where?: KeyboardWhereInput
    orderBy?: KeyboardOrderByWithRelationInput | KeyboardOrderByWithRelationInput[]
    cursor?: KeyboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeyboardScalarFieldEnum | KeyboardScalarFieldEnum[]
  }

  /**
   * Layout without action
   */
  export type LayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
  }


  /**
   * Model ConnectionType
   */

  export type AggregateConnectionType = {
    _count: ConnectionTypeCountAggregateOutputType | null
    _min: ConnectionTypeMinAggregateOutputType | null
    _max: ConnectionTypeMaxAggregateOutputType | null
  }

  export type ConnectionTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConnectionTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConnectionTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConnectionTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConnectionTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConnectionTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConnectionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectionType to aggregate.
     */
    where?: ConnectionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionTypes to fetch.
     */
    orderBy?: ConnectionTypeOrderByWithRelationInput | ConnectionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectionTypes
    **/
    _count?: true | ConnectionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionTypeMaxAggregateInputType
  }

  export type GetConnectionTypeAggregateType<T extends ConnectionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectionType[P]>
      : GetScalarType<T[P], AggregateConnectionType[P]>
  }




  export type ConnectionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionTypeWhereInput
    orderBy?: ConnectionTypeOrderByWithAggregationInput | ConnectionTypeOrderByWithAggregationInput[]
    by: ConnectionTypeScalarFieldEnum[] | ConnectionTypeScalarFieldEnum
    having?: ConnectionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionTypeCountAggregateInputType | true
    _min?: ConnectionTypeMinAggregateInputType
    _max?: ConnectionTypeMaxAggregateInputType
  }

  export type ConnectionTypeGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ConnectionTypeCountAggregateOutputType | null
    _min: ConnectionTypeMinAggregateOutputType | null
    _max: ConnectionTypeMaxAggregateOutputType | null
  }

  type GetConnectionTypeGroupByPayload<T extends ConnectionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionTypeGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Keyboard?: boolean | ConnectionType$KeyboardArgs<ExtArgs>
    _count?: boolean | ConnectionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectionType"]>

  export type ConnectionTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["connectionType"]>

  export type ConnectionTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["connectionType"]>

  export type ConnectionTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConnectionTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["connectionType"]>
  export type ConnectionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keyboard?: boolean | ConnectionType$KeyboardArgs<ExtArgs>
    _count?: boolean | ConnectionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConnectionTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ConnectionTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConnectionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectionType"
    objects: {
      Keyboard: Prisma.$KeyboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["connectionType"]>
    composites: {}
  }

  type ConnectionTypeGetPayload<S extends boolean | null | undefined | ConnectionTypeDefaultArgs> = $Result.GetResult<Prisma.$ConnectionTypePayload, S>

  type ConnectionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectionTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectionTypeCountAggregateInputType | true
    }

  export interface ConnectionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectionType'], meta: { name: 'ConnectionType' } }
    /**
     * Find zero or one ConnectionType that matches the filter.
     * @param {ConnectionTypeFindUniqueArgs} args - Arguments to find a ConnectionType
     * @example
     * // Get one ConnectionType
     * const connectionType = await prisma.connectionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionTypeFindUniqueArgs>(args: SelectSubset<T, ConnectionTypeFindUniqueArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConnectionType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectionTypeFindUniqueOrThrowArgs} args - Arguments to find a ConnectionType
     * @example
     * // Get one ConnectionType
     * const connectionType = await prisma.connectionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeFindFirstArgs} args - Arguments to find a ConnectionType
     * @example
     * // Get one ConnectionType
     * const connectionType = await prisma.connectionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionTypeFindFirstArgs>(args?: SelectSubset<T, ConnectionTypeFindFirstArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeFindFirstOrThrowArgs} args - Arguments to find a ConnectionType
     * @example
     * // Get one ConnectionType
     * const connectionType = await prisma.connectionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConnectionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectionTypes
     * const connectionTypes = await prisma.connectionType.findMany()
     * 
     * // Get first 10 ConnectionTypes
     * const connectionTypes = await prisma.connectionType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionTypeWithIdOnly = await prisma.connectionType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionTypeFindManyArgs>(args?: SelectSubset<T, ConnectionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConnectionType.
     * @param {ConnectionTypeCreateArgs} args - Arguments to create a ConnectionType.
     * @example
     * // Create one ConnectionType
     * const ConnectionType = await prisma.connectionType.create({
     *   data: {
     *     // ... data to create a ConnectionType
     *   }
     * })
     * 
     */
    create<T extends ConnectionTypeCreateArgs>(args: SelectSubset<T, ConnectionTypeCreateArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConnectionTypes.
     * @param {ConnectionTypeCreateManyArgs} args - Arguments to create many ConnectionTypes.
     * @example
     * // Create many ConnectionTypes
     * const connectionType = await prisma.connectionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionTypeCreateManyArgs>(args?: SelectSubset<T, ConnectionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConnectionTypes and returns the data saved in the database.
     * @param {ConnectionTypeCreateManyAndReturnArgs} args - Arguments to create many ConnectionTypes.
     * @example
     * // Create many ConnectionTypes
     * const connectionType = await prisma.connectionType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConnectionTypes and only return the `id`
     * const connectionTypeWithIdOnly = await prisma.connectionType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectionTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectionTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConnectionType.
     * @param {ConnectionTypeDeleteArgs} args - Arguments to delete one ConnectionType.
     * @example
     * // Delete one ConnectionType
     * const ConnectionType = await prisma.connectionType.delete({
     *   where: {
     *     // ... filter to delete one ConnectionType
     *   }
     * })
     * 
     */
    delete<T extends ConnectionTypeDeleteArgs>(args: SelectSubset<T, ConnectionTypeDeleteArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConnectionType.
     * @param {ConnectionTypeUpdateArgs} args - Arguments to update one ConnectionType.
     * @example
     * // Update one ConnectionType
     * const connectionType = await prisma.connectionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionTypeUpdateArgs>(args: SelectSubset<T, ConnectionTypeUpdateArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConnectionTypes.
     * @param {ConnectionTypeDeleteManyArgs} args - Arguments to filter ConnectionTypes to delete.
     * @example
     * // Delete a few ConnectionTypes
     * const { count } = await prisma.connectionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionTypeDeleteManyArgs>(args?: SelectSubset<T, ConnectionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectionTypes
     * const connectionType = await prisma.connectionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionTypeUpdateManyArgs>(args: SelectSubset<T, ConnectionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectionTypes and returns the data updated in the database.
     * @param {ConnectionTypeUpdateManyAndReturnArgs} args - Arguments to update many ConnectionTypes.
     * @example
     * // Update many ConnectionTypes
     * const connectionType = await prisma.connectionType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConnectionTypes and only return the `id`
     * const connectionTypeWithIdOnly = await prisma.connectionType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectionTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectionTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConnectionType.
     * @param {ConnectionTypeUpsertArgs} args - Arguments to update or create a ConnectionType.
     * @example
     * // Update or create a ConnectionType
     * const connectionType = await prisma.connectionType.upsert({
     *   create: {
     *     // ... data to create a ConnectionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectionType we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionTypeUpsertArgs>(args: SelectSubset<T, ConnectionTypeUpsertArgs<ExtArgs>>): Prisma__ConnectionTypeClient<$Result.GetResult<Prisma.$ConnectionTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConnectionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeCountArgs} args - Arguments to filter ConnectionTypes to count.
     * @example
     * // Count the number of ConnectionTypes
     * const count = await prisma.connectionType.count({
     *   where: {
     *     // ... the filter for the ConnectionTypes we want to count
     *   }
     * })
    **/
    count<T extends ConnectionTypeCountArgs>(
      args?: Subset<T, ConnectionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionTypeAggregateArgs>(args: Subset<T, ConnectionTypeAggregateArgs>): Prisma.PrismaPromise<GetConnectionTypeAggregateType<T>>

    /**
     * Group by ConnectionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionTypeGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectionType model
   */
  readonly fields: ConnectionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Keyboard<T extends ConnectionType$KeyboardArgs<ExtArgs> = {}>(args?: Subset<T, ConnectionType$KeyboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectionType model
   */
  interface ConnectionTypeFieldRefs {
    readonly id: FieldRef<"ConnectionType", 'String'>
    readonly name: FieldRef<"ConnectionType", 'String'>
    readonly createdAt: FieldRef<"ConnectionType", 'DateTime'>
    readonly updatedAt: FieldRef<"ConnectionType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConnectionType findUnique
   */
  export type ConnectionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionType to fetch.
     */
    where: ConnectionTypeWhereUniqueInput
  }

  /**
   * ConnectionType findUniqueOrThrow
   */
  export type ConnectionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionType to fetch.
     */
    where: ConnectionTypeWhereUniqueInput
  }

  /**
   * ConnectionType findFirst
   */
  export type ConnectionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionType to fetch.
     */
    where?: ConnectionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionTypes to fetch.
     */
    orderBy?: ConnectionTypeOrderByWithRelationInput | ConnectionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectionTypes.
     */
    cursor?: ConnectionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectionTypes.
     */
    distinct?: ConnectionTypeScalarFieldEnum | ConnectionTypeScalarFieldEnum[]
  }

  /**
   * ConnectionType findFirstOrThrow
   */
  export type ConnectionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionType to fetch.
     */
    where?: ConnectionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionTypes to fetch.
     */
    orderBy?: ConnectionTypeOrderByWithRelationInput | ConnectionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectionTypes.
     */
    cursor?: ConnectionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectionTypes.
     */
    distinct?: ConnectionTypeScalarFieldEnum | ConnectionTypeScalarFieldEnum[]
  }

  /**
   * ConnectionType findMany
   */
  export type ConnectionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionTypes to fetch.
     */
    where?: ConnectionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionTypes to fetch.
     */
    orderBy?: ConnectionTypeOrderByWithRelationInput | ConnectionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectionTypes.
     */
    cursor?: ConnectionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionTypes.
     */
    skip?: number
    distinct?: ConnectionTypeScalarFieldEnum | ConnectionTypeScalarFieldEnum[]
  }

  /**
   * ConnectionType create
   */
  export type ConnectionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ConnectionType.
     */
    data: XOR<ConnectionTypeCreateInput, ConnectionTypeUncheckedCreateInput>
  }

  /**
   * ConnectionType createMany
   */
  export type ConnectionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectionTypes.
     */
    data: ConnectionTypeCreateManyInput | ConnectionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConnectionType createManyAndReturn
   */
  export type ConnectionTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ConnectionTypes.
     */
    data: ConnectionTypeCreateManyInput | ConnectionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConnectionType update
   */
  export type ConnectionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ConnectionType.
     */
    data: XOR<ConnectionTypeUpdateInput, ConnectionTypeUncheckedUpdateInput>
    /**
     * Choose, which ConnectionType to update.
     */
    where: ConnectionTypeWhereUniqueInput
  }

  /**
   * ConnectionType updateMany
   */
  export type ConnectionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectionTypes.
     */
    data: XOR<ConnectionTypeUpdateManyMutationInput, ConnectionTypeUncheckedUpdateManyInput>
    /**
     * Filter which ConnectionTypes to update
     */
    where?: ConnectionTypeWhereInput
    /**
     * Limit how many ConnectionTypes to update.
     */
    limit?: number
  }

  /**
   * ConnectionType updateManyAndReturn
   */
  export type ConnectionTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * The data used to update ConnectionTypes.
     */
    data: XOR<ConnectionTypeUpdateManyMutationInput, ConnectionTypeUncheckedUpdateManyInput>
    /**
     * Filter which ConnectionTypes to update
     */
    where?: ConnectionTypeWhereInput
    /**
     * Limit how many ConnectionTypes to update.
     */
    limit?: number
  }

  /**
   * ConnectionType upsert
   */
  export type ConnectionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ConnectionType to update in case it exists.
     */
    where: ConnectionTypeWhereUniqueInput
    /**
     * In case the ConnectionType found by the `where` argument doesn't exist, create a new ConnectionType with this data.
     */
    create: XOR<ConnectionTypeCreateInput, ConnectionTypeUncheckedCreateInput>
    /**
     * In case the ConnectionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionTypeUpdateInput, ConnectionTypeUncheckedUpdateInput>
  }

  /**
   * ConnectionType delete
   */
  export type ConnectionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
    /**
     * Filter which ConnectionType to delete.
     */
    where: ConnectionTypeWhereUniqueInput
  }

  /**
   * ConnectionType deleteMany
   */
  export type ConnectionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectionTypes to delete
     */
    where?: ConnectionTypeWhereInput
    /**
     * Limit how many ConnectionTypes to delete.
     */
    limit?: number
  }

  /**
   * ConnectionType.Keyboard
   */
  export type ConnectionType$KeyboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyboard
     */
    select?: KeyboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyboard
     */
    omit?: KeyboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyboardInclude<ExtArgs> | null
    where?: KeyboardWhereInput
    orderBy?: KeyboardOrderByWithRelationInput | KeyboardOrderByWithRelationInput[]
    cursor?: KeyboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeyboardScalarFieldEnum | KeyboardScalarFieldEnum[]
  }

  /**
   * ConnectionType without action
   */
  export type ConnectionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionType
     */
    select?: ConnectionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionType
     */
    omit?: ConnectionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionTypeInclude<ExtArgs> | null
  }


  /**
   * Model Switch
   */

  export type AggregateSwitch = {
    _count: SwitchCountAggregateOutputType | null
    _avg: SwitchAvgAggregateOutputType | null
    _sum: SwitchSumAggregateOutputType | null
    _min: SwitchMinAggregateOutputType | null
    _max: SwitchMaxAggregateOutputType | null
  }

  export type SwitchAvgAggregateOutputType = {
    actuationForce: Decimal | null
    actuationPoint: Decimal | null
    totalTravel: Decimal | null
    keystrokeLifespan: number | null
  }

  export type SwitchSumAggregateOutputType = {
    actuationForce: Decimal | null
    actuationPoint: Decimal | null
    totalTravel: Decimal | null
    keystrokeLifespan: number | null
  }

  export type SwitchMinAggregateOutputType = {
    id: string | null
    productId: string | null
    typeId: string | null
    actuationForce: Decimal | null
    actuationPoint: Decimal | null
    totalTravel: Decimal | null
    keystrokeLifespan: number | null
    isFactoryLubed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwitchMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    typeId: string | null
    actuationForce: Decimal | null
    actuationPoint: Decimal | null
    totalTravel: Decimal | null
    keystrokeLifespan: number | null
    isFactoryLubed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwitchCountAggregateOutputType = {
    id: number
    productId: number
    typeId: number
    actuationForce: number
    actuationPoint: number
    totalTravel: number
    keystrokeLifespan: number
    isFactoryLubed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SwitchAvgAggregateInputType = {
    actuationForce?: true
    actuationPoint?: true
    totalTravel?: true
    keystrokeLifespan?: true
  }

  export type SwitchSumAggregateInputType = {
    actuationForce?: true
    actuationPoint?: true
    totalTravel?: true
    keystrokeLifespan?: true
  }

  export type SwitchMinAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    actuationForce?: true
    actuationPoint?: true
    totalTravel?: true
    keystrokeLifespan?: true
    isFactoryLubed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwitchMaxAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    actuationForce?: true
    actuationPoint?: true
    totalTravel?: true
    keystrokeLifespan?: true
    isFactoryLubed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwitchCountAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    actuationForce?: true
    actuationPoint?: true
    totalTravel?: true
    keystrokeLifespan?: true
    isFactoryLubed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SwitchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Switch to aggregate.
     */
    where?: SwitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Switches to fetch.
     */
    orderBy?: SwitchOrderByWithRelationInput | SwitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SwitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Switches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Switches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Switches
    **/
    _count?: true | SwitchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SwitchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SwitchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SwitchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SwitchMaxAggregateInputType
  }

  export type GetSwitchAggregateType<T extends SwitchAggregateArgs> = {
        [P in keyof T & keyof AggregateSwitch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSwitch[P]>
      : GetScalarType<T[P], AggregateSwitch[P]>
  }




  export type SwitchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwitchWhereInput
    orderBy?: SwitchOrderByWithAggregationInput | SwitchOrderByWithAggregationInput[]
    by: SwitchScalarFieldEnum[] | SwitchScalarFieldEnum
    having?: SwitchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SwitchCountAggregateInputType | true
    _avg?: SwitchAvgAggregateInputType
    _sum?: SwitchSumAggregateInputType
    _min?: SwitchMinAggregateInputType
    _max?: SwitchMaxAggregateInputType
  }

  export type SwitchGroupByOutputType = {
    id: string
    productId: string
    typeId: string
    actuationForce: Decimal
    actuationPoint: Decimal
    totalTravel: Decimal
    keystrokeLifespan: number
    isFactoryLubed: boolean
    createdAt: Date
    updatedAt: Date
    _count: SwitchCountAggregateOutputType | null
    _avg: SwitchAvgAggregateOutputType | null
    _sum: SwitchSumAggregateOutputType | null
    _min: SwitchMinAggregateOutputType | null
    _max: SwitchMaxAggregateOutputType | null
  }

  type GetSwitchGroupByPayload<T extends SwitchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SwitchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SwitchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SwitchGroupByOutputType[P]>
            : GetScalarType<T[P], SwitchGroupByOutputType[P]>
        }
      >
    >


  export type SwitchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    actuationForce?: boolean
    actuationPoint?: boolean
    totalTravel?: boolean
    keystrokeLifespan?: boolean
    isFactoryLubed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    switchType?: boolean | SwitchTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["switch"]>

  export type SwitchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    actuationForce?: boolean
    actuationPoint?: boolean
    totalTravel?: boolean
    keystrokeLifespan?: boolean
    isFactoryLubed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    switchType?: boolean | SwitchTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["switch"]>

  export type SwitchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    actuationForce?: boolean
    actuationPoint?: boolean
    totalTravel?: boolean
    keystrokeLifespan?: boolean
    isFactoryLubed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    switchType?: boolean | SwitchTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["switch"]>

  export type SwitchSelectScalar = {
    id?: boolean
    productId?: boolean
    typeId?: boolean
    actuationForce?: boolean
    actuationPoint?: boolean
    totalTravel?: boolean
    keystrokeLifespan?: boolean
    isFactoryLubed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SwitchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "typeId" | "actuationForce" | "actuationPoint" | "totalTravel" | "keystrokeLifespan" | "isFactoryLubed" | "createdAt" | "updatedAt", ExtArgs["result"]["switch"]>
  export type SwitchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    switchType?: boolean | SwitchTypeDefaultArgs<ExtArgs>
  }
  export type SwitchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    switchType?: boolean | SwitchTypeDefaultArgs<ExtArgs>
  }
  export type SwitchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    switchType?: boolean | SwitchTypeDefaultArgs<ExtArgs>
  }

  export type $SwitchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Switch"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      switchType: Prisma.$SwitchTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      typeId: string
      actuationForce: Prisma.Decimal
      actuationPoint: Prisma.Decimal
      totalTravel: Prisma.Decimal
      keystrokeLifespan: number
      isFactoryLubed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["switch"]>
    composites: {}
  }

  type SwitchGetPayload<S extends boolean | null | undefined | SwitchDefaultArgs> = $Result.GetResult<Prisma.$SwitchPayload, S>

  type SwitchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SwitchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SwitchCountAggregateInputType | true
    }

  export interface SwitchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Switch'], meta: { name: 'Switch' } }
    /**
     * Find zero or one Switch that matches the filter.
     * @param {SwitchFindUniqueArgs} args - Arguments to find a Switch
     * @example
     * // Get one Switch
     * const switch = await prisma.switch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SwitchFindUniqueArgs>(args: SelectSubset<T, SwitchFindUniqueArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Switch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SwitchFindUniqueOrThrowArgs} args - Arguments to find a Switch
     * @example
     * // Get one Switch
     * const switch = await prisma.switch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SwitchFindUniqueOrThrowArgs>(args: SelectSubset<T, SwitchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Switch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchFindFirstArgs} args - Arguments to find a Switch
     * @example
     * // Get one Switch
     * const switch = await prisma.switch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SwitchFindFirstArgs>(args?: SelectSubset<T, SwitchFindFirstArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Switch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchFindFirstOrThrowArgs} args - Arguments to find a Switch
     * @example
     * // Get one Switch
     * const switch = await prisma.switch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SwitchFindFirstOrThrowArgs>(args?: SelectSubset<T, SwitchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Switches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Switches
     * const switches = await prisma.switch.findMany()
     * 
     * // Get first 10 Switches
     * const switches = await prisma.switch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const switchWithIdOnly = await prisma.switch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SwitchFindManyArgs>(args?: SelectSubset<T, SwitchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Switch.
     * @param {SwitchCreateArgs} args - Arguments to create a Switch.
     * @example
     * // Create one Switch
     * const Switch = await prisma.switch.create({
     *   data: {
     *     // ... data to create a Switch
     *   }
     * })
     * 
     */
    create<T extends SwitchCreateArgs>(args: SelectSubset<T, SwitchCreateArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Switches.
     * @param {SwitchCreateManyArgs} args - Arguments to create many Switches.
     * @example
     * // Create many Switches
     * const switch = await prisma.switch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SwitchCreateManyArgs>(args?: SelectSubset<T, SwitchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Switches and returns the data saved in the database.
     * @param {SwitchCreateManyAndReturnArgs} args - Arguments to create many Switches.
     * @example
     * // Create many Switches
     * const switch = await prisma.switch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Switches and only return the `id`
     * const switchWithIdOnly = await prisma.switch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SwitchCreateManyAndReturnArgs>(args?: SelectSubset<T, SwitchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Switch.
     * @param {SwitchDeleteArgs} args - Arguments to delete one Switch.
     * @example
     * // Delete one Switch
     * const Switch = await prisma.switch.delete({
     *   where: {
     *     // ... filter to delete one Switch
     *   }
     * })
     * 
     */
    delete<T extends SwitchDeleteArgs>(args: SelectSubset<T, SwitchDeleteArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Switch.
     * @param {SwitchUpdateArgs} args - Arguments to update one Switch.
     * @example
     * // Update one Switch
     * const switch = await prisma.switch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SwitchUpdateArgs>(args: SelectSubset<T, SwitchUpdateArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Switches.
     * @param {SwitchDeleteManyArgs} args - Arguments to filter Switches to delete.
     * @example
     * // Delete a few Switches
     * const { count } = await prisma.switch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SwitchDeleteManyArgs>(args?: SelectSubset<T, SwitchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Switches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Switches
     * const switch = await prisma.switch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SwitchUpdateManyArgs>(args: SelectSubset<T, SwitchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Switches and returns the data updated in the database.
     * @param {SwitchUpdateManyAndReturnArgs} args - Arguments to update many Switches.
     * @example
     * // Update many Switches
     * const switch = await prisma.switch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Switches and only return the `id`
     * const switchWithIdOnly = await prisma.switch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SwitchUpdateManyAndReturnArgs>(args: SelectSubset<T, SwitchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Switch.
     * @param {SwitchUpsertArgs} args - Arguments to update or create a Switch.
     * @example
     * // Update or create a Switch
     * const switch = await prisma.switch.upsert({
     *   create: {
     *     // ... data to create a Switch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Switch we want to update
     *   }
     * })
     */
    upsert<T extends SwitchUpsertArgs>(args: SelectSubset<T, SwitchUpsertArgs<ExtArgs>>): Prisma__SwitchClient<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Switches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchCountArgs} args - Arguments to filter Switches to count.
     * @example
     * // Count the number of Switches
     * const count = await prisma.switch.count({
     *   where: {
     *     // ... the filter for the Switches we want to count
     *   }
     * })
    **/
    count<T extends SwitchCountArgs>(
      args?: Subset<T, SwitchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SwitchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Switch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SwitchAggregateArgs>(args: Subset<T, SwitchAggregateArgs>): Prisma.PrismaPromise<GetSwitchAggregateType<T>>

    /**
     * Group by Switch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SwitchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SwitchGroupByArgs['orderBy'] }
        : { orderBy?: SwitchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SwitchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSwitchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Switch model
   */
  readonly fields: SwitchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Switch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SwitchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    switchType<T extends SwitchTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SwitchTypeDefaultArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Switch model
   */
  interface SwitchFieldRefs {
    readonly id: FieldRef<"Switch", 'String'>
    readonly productId: FieldRef<"Switch", 'String'>
    readonly typeId: FieldRef<"Switch", 'String'>
    readonly actuationForce: FieldRef<"Switch", 'Decimal'>
    readonly actuationPoint: FieldRef<"Switch", 'Decimal'>
    readonly totalTravel: FieldRef<"Switch", 'Decimal'>
    readonly keystrokeLifespan: FieldRef<"Switch", 'Int'>
    readonly isFactoryLubed: FieldRef<"Switch", 'Boolean'>
    readonly createdAt: FieldRef<"Switch", 'DateTime'>
    readonly updatedAt: FieldRef<"Switch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Switch findUnique
   */
  export type SwitchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * Filter, which Switch to fetch.
     */
    where: SwitchWhereUniqueInput
  }

  /**
   * Switch findUniqueOrThrow
   */
  export type SwitchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * Filter, which Switch to fetch.
     */
    where: SwitchWhereUniqueInput
  }

  /**
   * Switch findFirst
   */
  export type SwitchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * Filter, which Switch to fetch.
     */
    where?: SwitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Switches to fetch.
     */
    orderBy?: SwitchOrderByWithRelationInput | SwitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Switches.
     */
    cursor?: SwitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Switches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Switches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Switches.
     */
    distinct?: SwitchScalarFieldEnum | SwitchScalarFieldEnum[]
  }

  /**
   * Switch findFirstOrThrow
   */
  export type SwitchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * Filter, which Switch to fetch.
     */
    where?: SwitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Switches to fetch.
     */
    orderBy?: SwitchOrderByWithRelationInput | SwitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Switches.
     */
    cursor?: SwitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Switches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Switches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Switches.
     */
    distinct?: SwitchScalarFieldEnum | SwitchScalarFieldEnum[]
  }

  /**
   * Switch findMany
   */
  export type SwitchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * Filter, which Switches to fetch.
     */
    where?: SwitchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Switches to fetch.
     */
    orderBy?: SwitchOrderByWithRelationInput | SwitchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Switches.
     */
    cursor?: SwitchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Switches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Switches.
     */
    skip?: number
    distinct?: SwitchScalarFieldEnum | SwitchScalarFieldEnum[]
  }

  /**
   * Switch create
   */
  export type SwitchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * The data needed to create a Switch.
     */
    data: XOR<SwitchCreateInput, SwitchUncheckedCreateInput>
  }

  /**
   * Switch createMany
   */
  export type SwitchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Switches.
     */
    data: SwitchCreateManyInput | SwitchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Switch createManyAndReturn
   */
  export type SwitchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * The data used to create many Switches.
     */
    data: SwitchCreateManyInput | SwitchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Switch update
   */
  export type SwitchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * The data needed to update a Switch.
     */
    data: XOR<SwitchUpdateInput, SwitchUncheckedUpdateInput>
    /**
     * Choose, which Switch to update.
     */
    where: SwitchWhereUniqueInput
  }

  /**
   * Switch updateMany
   */
  export type SwitchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Switches.
     */
    data: XOR<SwitchUpdateManyMutationInput, SwitchUncheckedUpdateManyInput>
    /**
     * Filter which Switches to update
     */
    where?: SwitchWhereInput
    /**
     * Limit how many Switches to update.
     */
    limit?: number
  }

  /**
   * Switch updateManyAndReturn
   */
  export type SwitchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * The data used to update Switches.
     */
    data: XOR<SwitchUpdateManyMutationInput, SwitchUncheckedUpdateManyInput>
    /**
     * Filter which Switches to update
     */
    where?: SwitchWhereInput
    /**
     * Limit how many Switches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Switch upsert
   */
  export type SwitchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * The filter to search for the Switch to update in case it exists.
     */
    where: SwitchWhereUniqueInput
    /**
     * In case the Switch found by the `where` argument doesn't exist, create a new Switch with this data.
     */
    create: XOR<SwitchCreateInput, SwitchUncheckedCreateInput>
    /**
     * In case the Switch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SwitchUpdateInput, SwitchUncheckedUpdateInput>
  }

  /**
   * Switch delete
   */
  export type SwitchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    /**
     * Filter which Switch to delete.
     */
    where: SwitchWhereUniqueInput
  }

  /**
   * Switch deleteMany
   */
  export type SwitchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Switches to delete
     */
    where?: SwitchWhereInput
    /**
     * Limit how many Switches to delete.
     */
    limit?: number
  }

  /**
   * Switch without action
   */
  export type SwitchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
  }


  /**
   * Model SwitchType
   */

  export type AggregateSwitchType = {
    _count: SwitchTypeCountAggregateOutputType | null
    _min: SwitchTypeMinAggregateOutputType | null
    _max: SwitchTypeMaxAggregateOutputType | null
  }

  export type SwitchTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwitchTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwitchTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SwitchTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwitchTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwitchTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SwitchTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SwitchType to aggregate.
     */
    where?: SwitchTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwitchTypes to fetch.
     */
    orderBy?: SwitchTypeOrderByWithRelationInput | SwitchTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SwitchTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwitchTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwitchTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SwitchTypes
    **/
    _count?: true | SwitchTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SwitchTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SwitchTypeMaxAggregateInputType
  }

  export type GetSwitchTypeAggregateType<T extends SwitchTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSwitchType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSwitchType[P]>
      : GetScalarType<T[P], AggregateSwitchType[P]>
  }




  export type SwitchTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwitchTypeWhereInput
    orderBy?: SwitchTypeOrderByWithAggregationInput | SwitchTypeOrderByWithAggregationInput[]
    by: SwitchTypeScalarFieldEnum[] | SwitchTypeScalarFieldEnum
    having?: SwitchTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SwitchTypeCountAggregateInputType | true
    _min?: SwitchTypeMinAggregateInputType
    _max?: SwitchTypeMaxAggregateInputType
  }

  export type SwitchTypeGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: SwitchTypeCountAggregateOutputType | null
    _min: SwitchTypeMinAggregateOutputType | null
    _max: SwitchTypeMaxAggregateOutputType | null
  }

  type GetSwitchTypeGroupByPayload<T extends SwitchTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SwitchTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SwitchTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SwitchTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SwitchTypeGroupByOutputType[P]>
        }
      >
    >


  export type SwitchTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Switch?: boolean | SwitchType$SwitchArgs<ExtArgs>
    _count?: boolean | SwitchTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["switchType"]>

  export type SwitchTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["switchType"]>

  export type SwitchTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["switchType"]>

  export type SwitchTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SwitchTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["switchType"]>
  export type SwitchTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Switch?: boolean | SwitchType$SwitchArgs<ExtArgs>
    _count?: boolean | SwitchTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SwitchTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SwitchTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SwitchTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SwitchType"
    objects: {
      Switch: Prisma.$SwitchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["switchType"]>
    composites: {}
  }

  type SwitchTypeGetPayload<S extends boolean | null | undefined | SwitchTypeDefaultArgs> = $Result.GetResult<Prisma.$SwitchTypePayload, S>

  type SwitchTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SwitchTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SwitchTypeCountAggregateInputType | true
    }

  export interface SwitchTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SwitchType'], meta: { name: 'SwitchType' } }
    /**
     * Find zero or one SwitchType that matches the filter.
     * @param {SwitchTypeFindUniqueArgs} args - Arguments to find a SwitchType
     * @example
     * // Get one SwitchType
     * const switchType = await prisma.switchType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SwitchTypeFindUniqueArgs>(args: SelectSubset<T, SwitchTypeFindUniqueArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SwitchType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SwitchTypeFindUniqueOrThrowArgs} args - Arguments to find a SwitchType
     * @example
     * // Get one SwitchType
     * const switchType = await prisma.switchType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SwitchTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SwitchTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SwitchType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeFindFirstArgs} args - Arguments to find a SwitchType
     * @example
     * // Get one SwitchType
     * const switchType = await prisma.switchType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SwitchTypeFindFirstArgs>(args?: SelectSubset<T, SwitchTypeFindFirstArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SwitchType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeFindFirstOrThrowArgs} args - Arguments to find a SwitchType
     * @example
     * // Get one SwitchType
     * const switchType = await prisma.switchType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SwitchTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SwitchTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SwitchTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SwitchTypes
     * const switchTypes = await prisma.switchType.findMany()
     * 
     * // Get first 10 SwitchTypes
     * const switchTypes = await prisma.switchType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const switchTypeWithIdOnly = await prisma.switchType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SwitchTypeFindManyArgs>(args?: SelectSubset<T, SwitchTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SwitchType.
     * @param {SwitchTypeCreateArgs} args - Arguments to create a SwitchType.
     * @example
     * // Create one SwitchType
     * const SwitchType = await prisma.switchType.create({
     *   data: {
     *     // ... data to create a SwitchType
     *   }
     * })
     * 
     */
    create<T extends SwitchTypeCreateArgs>(args: SelectSubset<T, SwitchTypeCreateArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SwitchTypes.
     * @param {SwitchTypeCreateManyArgs} args - Arguments to create many SwitchTypes.
     * @example
     * // Create many SwitchTypes
     * const switchType = await prisma.switchType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SwitchTypeCreateManyArgs>(args?: SelectSubset<T, SwitchTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SwitchTypes and returns the data saved in the database.
     * @param {SwitchTypeCreateManyAndReturnArgs} args - Arguments to create many SwitchTypes.
     * @example
     * // Create many SwitchTypes
     * const switchType = await prisma.switchType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SwitchTypes and only return the `id`
     * const switchTypeWithIdOnly = await prisma.switchType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SwitchTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SwitchTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SwitchType.
     * @param {SwitchTypeDeleteArgs} args - Arguments to delete one SwitchType.
     * @example
     * // Delete one SwitchType
     * const SwitchType = await prisma.switchType.delete({
     *   where: {
     *     // ... filter to delete one SwitchType
     *   }
     * })
     * 
     */
    delete<T extends SwitchTypeDeleteArgs>(args: SelectSubset<T, SwitchTypeDeleteArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SwitchType.
     * @param {SwitchTypeUpdateArgs} args - Arguments to update one SwitchType.
     * @example
     * // Update one SwitchType
     * const switchType = await prisma.switchType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SwitchTypeUpdateArgs>(args: SelectSubset<T, SwitchTypeUpdateArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SwitchTypes.
     * @param {SwitchTypeDeleteManyArgs} args - Arguments to filter SwitchTypes to delete.
     * @example
     * // Delete a few SwitchTypes
     * const { count } = await prisma.switchType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SwitchTypeDeleteManyArgs>(args?: SelectSubset<T, SwitchTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SwitchTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SwitchTypes
     * const switchType = await prisma.switchType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SwitchTypeUpdateManyArgs>(args: SelectSubset<T, SwitchTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SwitchTypes and returns the data updated in the database.
     * @param {SwitchTypeUpdateManyAndReturnArgs} args - Arguments to update many SwitchTypes.
     * @example
     * // Update many SwitchTypes
     * const switchType = await prisma.switchType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SwitchTypes and only return the `id`
     * const switchTypeWithIdOnly = await prisma.switchType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SwitchTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SwitchTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SwitchType.
     * @param {SwitchTypeUpsertArgs} args - Arguments to update or create a SwitchType.
     * @example
     * // Update or create a SwitchType
     * const switchType = await prisma.switchType.upsert({
     *   create: {
     *     // ... data to create a SwitchType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SwitchType we want to update
     *   }
     * })
     */
    upsert<T extends SwitchTypeUpsertArgs>(args: SelectSubset<T, SwitchTypeUpsertArgs<ExtArgs>>): Prisma__SwitchTypeClient<$Result.GetResult<Prisma.$SwitchTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SwitchTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeCountArgs} args - Arguments to filter SwitchTypes to count.
     * @example
     * // Count the number of SwitchTypes
     * const count = await prisma.switchType.count({
     *   where: {
     *     // ... the filter for the SwitchTypes we want to count
     *   }
     * })
    **/
    count<T extends SwitchTypeCountArgs>(
      args?: Subset<T, SwitchTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SwitchTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SwitchType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SwitchTypeAggregateArgs>(args: Subset<T, SwitchTypeAggregateArgs>): Prisma.PrismaPromise<GetSwitchTypeAggregateType<T>>

    /**
     * Group by SwitchType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SwitchTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SwitchTypeGroupByArgs['orderBy'] }
        : { orderBy?: SwitchTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SwitchTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSwitchTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SwitchType model
   */
  readonly fields: SwitchTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SwitchType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SwitchTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Switch<T extends SwitchType$SwitchArgs<ExtArgs> = {}>(args?: Subset<T, SwitchType$SwitchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwitchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SwitchType model
   */
  interface SwitchTypeFieldRefs {
    readonly id: FieldRef<"SwitchType", 'String'>
    readonly name: FieldRef<"SwitchType", 'String'>
    readonly createdAt: FieldRef<"SwitchType", 'DateTime'>
    readonly updatedAt: FieldRef<"SwitchType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SwitchType findUnique
   */
  export type SwitchTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * Filter, which SwitchType to fetch.
     */
    where: SwitchTypeWhereUniqueInput
  }

  /**
   * SwitchType findUniqueOrThrow
   */
  export type SwitchTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * Filter, which SwitchType to fetch.
     */
    where: SwitchTypeWhereUniqueInput
  }

  /**
   * SwitchType findFirst
   */
  export type SwitchTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * Filter, which SwitchType to fetch.
     */
    where?: SwitchTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwitchTypes to fetch.
     */
    orderBy?: SwitchTypeOrderByWithRelationInput | SwitchTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SwitchTypes.
     */
    cursor?: SwitchTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwitchTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwitchTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SwitchTypes.
     */
    distinct?: SwitchTypeScalarFieldEnum | SwitchTypeScalarFieldEnum[]
  }

  /**
   * SwitchType findFirstOrThrow
   */
  export type SwitchTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * Filter, which SwitchType to fetch.
     */
    where?: SwitchTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwitchTypes to fetch.
     */
    orderBy?: SwitchTypeOrderByWithRelationInput | SwitchTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SwitchTypes.
     */
    cursor?: SwitchTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwitchTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwitchTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SwitchTypes.
     */
    distinct?: SwitchTypeScalarFieldEnum | SwitchTypeScalarFieldEnum[]
  }

  /**
   * SwitchType findMany
   */
  export type SwitchTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * Filter, which SwitchTypes to fetch.
     */
    where?: SwitchTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SwitchTypes to fetch.
     */
    orderBy?: SwitchTypeOrderByWithRelationInput | SwitchTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SwitchTypes.
     */
    cursor?: SwitchTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SwitchTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SwitchTypes.
     */
    skip?: number
    distinct?: SwitchTypeScalarFieldEnum | SwitchTypeScalarFieldEnum[]
  }

  /**
   * SwitchType create
   */
  export type SwitchTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SwitchType.
     */
    data: XOR<SwitchTypeCreateInput, SwitchTypeUncheckedCreateInput>
  }

  /**
   * SwitchType createMany
   */
  export type SwitchTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SwitchTypes.
     */
    data: SwitchTypeCreateManyInput | SwitchTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SwitchType createManyAndReturn
   */
  export type SwitchTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SwitchTypes.
     */
    data: SwitchTypeCreateManyInput | SwitchTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SwitchType update
   */
  export type SwitchTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SwitchType.
     */
    data: XOR<SwitchTypeUpdateInput, SwitchTypeUncheckedUpdateInput>
    /**
     * Choose, which SwitchType to update.
     */
    where: SwitchTypeWhereUniqueInput
  }

  /**
   * SwitchType updateMany
   */
  export type SwitchTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SwitchTypes.
     */
    data: XOR<SwitchTypeUpdateManyMutationInput, SwitchTypeUncheckedUpdateManyInput>
    /**
     * Filter which SwitchTypes to update
     */
    where?: SwitchTypeWhereInput
    /**
     * Limit how many SwitchTypes to update.
     */
    limit?: number
  }

  /**
   * SwitchType updateManyAndReturn
   */
  export type SwitchTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * The data used to update SwitchTypes.
     */
    data: XOR<SwitchTypeUpdateManyMutationInput, SwitchTypeUncheckedUpdateManyInput>
    /**
     * Filter which SwitchTypes to update
     */
    where?: SwitchTypeWhereInput
    /**
     * Limit how many SwitchTypes to update.
     */
    limit?: number
  }

  /**
   * SwitchType upsert
   */
  export type SwitchTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SwitchType to update in case it exists.
     */
    where: SwitchTypeWhereUniqueInput
    /**
     * In case the SwitchType found by the `where` argument doesn't exist, create a new SwitchType with this data.
     */
    create: XOR<SwitchTypeCreateInput, SwitchTypeUncheckedCreateInput>
    /**
     * In case the SwitchType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SwitchTypeUpdateInput, SwitchTypeUncheckedUpdateInput>
  }

  /**
   * SwitchType delete
   */
  export type SwitchTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
    /**
     * Filter which SwitchType to delete.
     */
    where: SwitchTypeWhereUniqueInput
  }

  /**
   * SwitchType deleteMany
   */
  export type SwitchTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SwitchTypes to delete
     */
    where?: SwitchTypeWhereInput
    /**
     * Limit how many SwitchTypes to delete.
     */
    limit?: number
  }

  /**
   * SwitchType.Switch
   */
  export type SwitchType$SwitchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Switch
     */
    select?: SwitchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Switch
     */
    omit?: SwitchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchInclude<ExtArgs> | null
    where?: SwitchWhereInput
    orderBy?: SwitchOrderByWithRelationInput | SwitchOrderByWithRelationInput[]
    cursor?: SwitchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SwitchScalarFieldEnum | SwitchScalarFieldEnum[]
  }

  /**
   * SwitchType without action
   */
  export type SwitchTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwitchType
     */
    select?: SwitchTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SwitchType
     */
    omit?: SwitchTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwitchTypeInclude<ExtArgs> | null
  }


  /**
   * Model Keycap
   */

  export type AggregateKeycap = {
    _count: KeycapCountAggregateOutputType | null
    _min: KeycapMinAggregateOutputType | null
    _max: KeycapMaxAggregateOutputType | null
  }

  export type KeycapMinAggregateOutputType = {
    id: string | null
    productId: string | null
    profileId: string | null
    materialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeycapMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    profileId: string | null
    materialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeycapCountAggregateOutputType = {
    id: number
    productId: number
    profileId: number
    materialId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeycapMinAggregateInputType = {
    id?: true
    productId?: true
    profileId?: true
    materialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeycapMaxAggregateInputType = {
    id?: true
    productId?: true
    profileId?: true
    materialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeycapCountAggregateInputType = {
    id?: true
    productId?: true
    profileId?: true
    materialId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeycapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keycap to aggregate.
     */
    where?: KeycapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keycaps to fetch.
     */
    orderBy?: KeycapOrderByWithRelationInput | KeycapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeycapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keycaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keycaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Keycaps
    **/
    _count?: true | KeycapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeycapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeycapMaxAggregateInputType
  }

  export type GetKeycapAggregateType<T extends KeycapAggregateArgs> = {
        [P in keyof T & keyof AggregateKeycap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeycap[P]>
      : GetScalarType<T[P], AggregateKeycap[P]>
  }




  export type KeycapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeycapWhereInput
    orderBy?: KeycapOrderByWithAggregationInput | KeycapOrderByWithAggregationInput[]
    by: KeycapScalarFieldEnum[] | KeycapScalarFieldEnum
    having?: KeycapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeycapCountAggregateInputType | true
    _min?: KeycapMinAggregateInputType
    _max?: KeycapMaxAggregateInputType
  }

  export type KeycapGroupByOutputType = {
    id: string
    productId: string
    profileId: string
    materialId: string
    createdAt: Date
    updatedAt: Date
    _count: KeycapCountAggregateOutputType | null
    _min: KeycapMinAggregateOutputType | null
    _max: KeycapMaxAggregateOutputType | null
  }

  type GetKeycapGroupByPayload<T extends KeycapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeycapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeycapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeycapGroupByOutputType[P]>
            : GetScalarType<T[P], KeycapGroupByOutputType[P]>
        }
      >
    >


  export type KeycapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    profileId?: boolean
    materialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    profile?: boolean | KeycapProfileDefaultArgs<ExtArgs>
    material?: boolean | KeycapMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keycap"]>

  export type KeycapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    profileId?: boolean
    materialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    profile?: boolean | KeycapProfileDefaultArgs<ExtArgs>
    material?: boolean | KeycapMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keycap"]>

  export type KeycapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    profileId?: boolean
    materialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    profile?: boolean | KeycapProfileDefaultArgs<ExtArgs>
    material?: boolean | KeycapMaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keycap"]>

  export type KeycapSelectScalar = {
    id?: boolean
    productId?: boolean
    profileId?: boolean
    materialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeycapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "profileId" | "materialId" | "createdAt" | "updatedAt", ExtArgs["result"]["keycap"]>
  export type KeycapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    profile?: boolean | KeycapProfileDefaultArgs<ExtArgs>
    material?: boolean | KeycapMaterialDefaultArgs<ExtArgs>
  }
  export type KeycapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    profile?: boolean | KeycapProfileDefaultArgs<ExtArgs>
    material?: boolean | KeycapMaterialDefaultArgs<ExtArgs>
  }
  export type KeycapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    profile?: boolean | KeycapProfileDefaultArgs<ExtArgs>
    material?: boolean | KeycapMaterialDefaultArgs<ExtArgs>
  }

  export type $KeycapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keycap"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      profile: Prisma.$KeycapProfilePayload<ExtArgs>
      material: Prisma.$KeycapMaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      profileId: string
      materialId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keycap"]>
    composites: {}
  }

  type KeycapGetPayload<S extends boolean | null | undefined | KeycapDefaultArgs> = $Result.GetResult<Prisma.$KeycapPayload, S>

  type KeycapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeycapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeycapCountAggregateInputType | true
    }

  export interface KeycapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keycap'], meta: { name: 'Keycap' } }
    /**
     * Find zero or one Keycap that matches the filter.
     * @param {KeycapFindUniqueArgs} args - Arguments to find a Keycap
     * @example
     * // Get one Keycap
     * const keycap = await prisma.keycap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeycapFindUniqueArgs>(args: SelectSubset<T, KeycapFindUniqueArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Keycap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeycapFindUniqueOrThrowArgs} args - Arguments to find a Keycap
     * @example
     * // Get one Keycap
     * const keycap = await prisma.keycap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeycapFindUniqueOrThrowArgs>(args: SelectSubset<T, KeycapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keycap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapFindFirstArgs} args - Arguments to find a Keycap
     * @example
     * // Get one Keycap
     * const keycap = await prisma.keycap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeycapFindFirstArgs>(args?: SelectSubset<T, KeycapFindFirstArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keycap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapFindFirstOrThrowArgs} args - Arguments to find a Keycap
     * @example
     * // Get one Keycap
     * const keycap = await prisma.keycap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeycapFindFirstOrThrowArgs>(args?: SelectSubset<T, KeycapFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keycaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keycaps
     * const keycaps = await prisma.keycap.findMany()
     * 
     * // Get first 10 Keycaps
     * const keycaps = await prisma.keycap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keycapWithIdOnly = await prisma.keycap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeycapFindManyArgs>(args?: SelectSubset<T, KeycapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Keycap.
     * @param {KeycapCreateArgs} args - Arguments to create a Keycap.
     * @example
     * // Create one Keycap
     * const Keycap = await prisma.keycap.create({
     *   data: {
     *     // ... data to create a Keycap
     *   }
     * })
     * 
     */
    create<T extends KeycapCreateArgs>(args: SelectSubset<T, KeycapCreateArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Keycaps.
     * @param {KeycapCreateManyArgs} args - Arguments to create many Keycaps.
     * @example
     * // Create many Keycaps
     * const keycap = await prisma.keycap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeycapCreateManyArgs>(args?: SelectSubset<T, KeycapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keycaps and returns the data saved in the database.
     * @param {KeycapCreateManyAndReturnArgs} args - Arguments to create many Keycaps.
     * @example
     * // Create many Keycaps
     * const keycap = await prisma.keycap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keycaps and only return the `id`
     * const keycapWithIdOnly = await prisma.keycap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeycapCreateManyAndReturnArgs>(args?: SelectSubset<T, KeycapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Keycap.
     * @param {KeycapDeleteArgs} args - Arguments to delete one Keycap.
     * @example
     * // Delete one Keycap
     * const Keycap = await prisma.keycap.delete({
     *   where: {
     *     // ... filter to delete one Keycap
     *   }
     * })
     * 
     */
    delete<T extends KeycapDeleteArgs>(args: SelectSubset<T, KeycapDeleteArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Keycap.
     * @param {KeycapUpdateArgs} args - Arguments to update one Keycap.
     * @example
     * // Update one Keycap
     * const keycap = await prisma.keycap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeycapUpdateArgs>(args: SelectSubset<T, KeycapUpdateArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Keycaps.
     * @param {KeycapDeleteManyArgs} args - Arguments to filter Keycaps to delete.
     * @example
     * // Delete a few Keycaps
     * const { count } = await prisma.keycap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeycapDeleteManyArgs>(args?: SelectSubset<T, KeycapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keycaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keycaps
     * const keycap = await prisma.keycap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeycapUpdateManyArgs>(args: SelectSubset<T, KeycapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keycaps and returns the data updated in the database.
     * @param {KeycapUpdateManyAndReturnArgs} args - Arguments to update many Keycaps.
     * @example
     * // Update many Keycaps
     * const keycap = await prisma.keycap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Keycaps and only return the `id`
     * const keycapWithIdOnly = await prisma.keycap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeycapUpdateManyAndReturnArgs>(args: SelectSubset<T, KeycapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Keycap.
     * @param {KeycapUpsertArgs} args - Arguments to update or create a Keycap.
     * @example
     * // Update or create a Keycap
     * const keycap = await prisma.keycap.upsert({
     *   create: {
     *     // ... data to create a Keycap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keycap we want to update
     *   }
     * })
     */
    upsert<T extends KeycapUpsertArgs>(args: SelectSubset<T, KeycapUpsertArgs<ExtArgs>>): Prisma__KeycapClient<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Keycaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapCountArgs} args - Arguments to filter Keycaps to count.
     * @example
     * // Count the number of Keycaps
     * const count = await prisma.keycap.count({
     *   where: {
     *     // ... the filter for the Keycaps we want to count
     *   }
     * })
    **/
    count<T extends KeycapCountArgs>(
      args?: Subset<T, KeycapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeycapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keycap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeycapAggregateArgs>(args: Subset<T, KeycapAggregateArgs>): Prisma.PrismaPromise<GetKeycapAggregateType<T>>

    /**
     * Group by Keycap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeycapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeycapGroupByArgs['orderBy'] }
        : { orderBy?: KeycapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeycapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeycapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keycap model
   */
  readonly fields: KeycapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keycap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeycapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends KeycapProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KeycapProfileDefaultArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends KeycapMaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KeycapMaterialDefaultArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keycap model
   */
  interface KeycapFieldRefs {
    readonly id: FieldRef<"Keycap", 'String'>
    readonly productId: FieldRef<"Keycap", 'String'>
    readonly profileId: FieldRef<"Keycap", 'String'>
    readonly materialId: FieldRef<"Keycap", 'String'>
    readonly createdAt: FieldRef<"Keycap", 'DateTime'>
    readonly updatedAt: FieldRef<"Keycap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Keycap findUnique
   */
  export type KeycapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * Filter, which Keycap to fetch.
     */
    where: KeycapWhereUniqueInput
  }

  /**
   * Keycap findUniqueOrThrow
   */
  export type KeycapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * Filter, which Keycap to fetch.
     */
    where: KeycapWhereUniqueInput
  }

  /**
   * Keycap findFirst
   */
  export type KeycapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * Filter, which Keycap to fetch.
     */
    where?: KeycapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keycaps to fetch.
     */
    orderBy?: KeycapOrderByWithRelationInput | KeycapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keycaps.
     */
    cursor?: KeycapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keycaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keycaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keycaps.
     */
    distinct?: KeycapScalarFieldEnum | KeycapScalarFieldEnum[]
  }

  /**
   * Keycap findFirstOrThrow
   */
  export type KeycapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * Filter, which Keycap to fetch.
     */
    where?: KeycapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keycaps to fetch.
     */
    orderBy?: KeycapOrderByWithRelationInput | KeycapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keycaps.
     */
    cursor?: KeycapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keycaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keycaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keycaps.
     */
    distinct?: KeycapScalarFieldEnum | KeycapScalarFieldEnum[]
  }

  /**
   * Keycap findMany
   */
  export type KeycapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * Filter, which Keycaps to fetch.
     */
    where?: KeycapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keycaps to fetch.
     */
    orderBy?: KeycapOrderByWithRelationInput | KeycapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Keycaps.
     */
    cursor?: KeycapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keycaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keycaps.
     */
    skip?: number
    distinct?: KeycapScalarFieldEnum | KeycapScalarFieldEnum[]
  }

  /**
   * Keycap create
   */
  export type KeycapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * The data needed to create a Keycap.
     */
    data: XOR<KeycapCreateInput, KeycapUncheckedCreateInput>
  }

  /**
   * Keycap createMany
   */
  export type KeycapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Keycaps.
     */
    data: KeycapCreateManyInput | KeycapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keycap createManyAndReturn
   */
  export type KeycapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * The data used to create many Keycaps.
     */
    data: KeycapCreateManyInput | KeycapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keycap update
   */
  export type KeycapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * The data needed to update a Keycap.
     */
    data: XOR<KeycapUpdateInput, KeycapUncheckedUpdateInput>
    /**
     * Choose, which Keycap to update.
     */
    where: KeycapWhereUniqueInput
  }

  /**
   * Keycap updateMany
   */
  export type KeycapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Keycaps.
     */
    data: XOR<KeycapUpdateManyMutationInput, KeycapUncheckedUpdateManyInput>
    /**
     * Filter which Keycaps to update
     */
    where?: KeycapWhereInput
    /**
     * Limit how many Keycaps to update.
     */
    limit?: number
  }

  /**
   * Keycap updateManyAndReturn
   */
  export type KeycapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * The data used to update Keycaps.
     */
    data: XOR<KeycapUpdateManyMutationInput, KeycapUncheckedUpdateManyInput>
    /**
     * Filter which Keycaps to update
     */
    where?: KeycapWhereInput
    /**
     * Limit how many Keycaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keycap upsert
   */
  export type KeycapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * The filter to search for the Keycap to update in case it exists.
     */
    where: KeycapWhereUniqueInput
    /**
     * In case the Keycap found by the `where` argument doesn't exist, create a new Keycap with this data.
     */
    create: XOR<KeycapCreateInput, KeycapUncheckedCreateInput>
    /**
     * In case the Keycap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeycapUpdateInput, KeycapUncheckedUpdateInput>
  }

  /**
   * Keycap delete
   */
  export type KeycapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    /**
     * Filter which Keycap to delete.
     */
    where: KeycapWhereUniqueInput
  }

  /**
   * Keycap deleteMany
   */
  export type KeycapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keycaps to delete
     */
    where?: KeycapWhereInput
    /**
     * Limit how many Keycaps to delete.
     */
    limit?: number
  }

  /**
   * Keycap without action
   */
  export type KeycapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
  }


  /**
   * Model KeycapProfile
   */

  export type AggregateKeycapProfile = {
    _count: KeycapProfileCountAggregateOutputType | null
    _min: KeycapProfileMinAggregateOutputType | null
    _max: KeycapProfileMaxAggregateOutputType | null
  }

  export type KeycapProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeycapProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeycapProfileCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeycapProfileMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeycapProfileMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeycapProfileCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeycapProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeycapProfile to aggregate.
     */
    where?: KeycapProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapProfiles to fetch.
     */
    orderBy?: KeycapProfileOrderByWithRelationInput | KeycapProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeycapProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeycapProfiles
    **/
    _count?: true | KeycapProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeycapProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeycapProfileMaxAggregateInputType
  }

  export type GetKeycapProfileAggregateType<T extends KeycapProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateKeycapProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeycapProfile[P]>
      : GetScalarType<T[P], AggregateKeycapProfile[P]>
  }




  export type KeycapProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeycapProfileWhereInput
    orderBy?: KeycapProfileOrderByWithAggregationInput | KeycapProfileOrderByWithAggregationInput[]
    by: KeycapProfileScalarFieldEnum[] | KeycapProfileScalarFieldEnum
    having?: KeycapProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeycapProfileCountAggregateInputType | true
    _min?: KeycapProfileMinAggregateInputType
    _max?: KeycapProfileMaxAggregateInputType
  }

  export type KeycapProfileGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: KeycapProfileCountAggregateOutputType | null
    _min: KeycapProfileMinAggregateOutputType | null
    _max: KeycapProfileMaxAggregateOutputType | null
  }

  type GetKeycapProfileGroupByPayload<T extends KeycapProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeycapProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeycapProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeycapProfileGroupByOutputType[P]>
            : GetScalarType<T[P], KeycapProfileGroupByOutputType[P]>
        }
      >
    >


  export type KeycapProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Keycap?: boolean | KeycapProfile$KeycapArgs<ExtArgs>
    _count?: boolean | KeycapProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keycapProfile"]>

  export type KeycapProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["keycapProfile"]>

  export type KeycapProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["keycapProfile"]>

  export type KeycapProfileSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeycapProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["keycapProfile"]>
  export type KeycapProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keycap?: boolean | KeycapProfile$KeycapArgs<ExtArgs>
    _count?: boolean | KeycapProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeycapProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KeycapProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KeycapProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeycapProfile"
    objects: {
      Keycap: Prisma.$KeycapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keycapProfile"]>
    composites: {}
  }

  type KeycapProfileGetPayload<S extends boolean | null | undefined | KeycapProfileDefaultArgs> = $Result.GetResult<Prisma.$KeycapProfilePayload, S>

  type KeycapProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeycapProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeycapProfileCountAggregateInputType | true
    }

  export interface KeycapProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeycapProfile'], meta: { name: 'KeycapProfile' } }
    /**
     * Find zero or one KeycapProfile that matches the filter.
     * @param {KeycapProfileFindUniqueArgs} args - Arguments to find a KeycapProfile
     * @example
     * // Get one KeycapProfile
     * const keycapProfile = await prisma.keycapProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeycapProfileFindUniqueArgs>(args: SelectSubset<T, KeycapProfileFindUniqueArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeycapProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeycapProfileFindUniqueOrThrowArgs} args - Arguments to find a KeycapProfile
     * @example
     * // Get one KeycapProfile
     * const keycapProfile = await prisma.keycapProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeycapProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, KeycapProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeycapProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileFindFirstArgs} args - Arguments to find a KeycapProfile
     * @example
     * // Get one KeycapProfile
     * const keycapProfile = await prisma.keycapProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeycapProfileFindFirstArgs>(args?: SelectSubset<T, KeycapProfileFindFirstArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeycapProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileFindFirstOrThrowArgs} args - Arguments to find a KeycapProfile
     * @example
     * // Get one KeycapProfile
     * const keycapProfile = await prisma.keycapProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeycapProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, KeycapProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeycapProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeycapProfiles
     * const keycapProfiles = await prisma.keycapProfile.findMany()
     * 
     * // Get first 10 KeycapProfiles
     * const keycapProfiles = await prisma.keycapProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keycapProfileWithIdOnly = await prisma.keycapProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeycapProfileFindManyArgs>(args?: SelectSubset<T, KeycapProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeycapProfile.
     * @param {KeycapProfileCreateArgs} args - Arguments to create a KeycapProfile.
     * @example
     * // Create one KeycapProfile
     * const KeycapProfile = await prisma.keycapProfile.create({
     *   data: {
     *     // ... data to create a KeycapProfile
     *   }
     * })
     * 
     */
    create<T extends KeycapProfileCreateArgs>(args: SelectSubset<T, KeycapProfileCreateArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeycapProfiles.
     * @param {KeycapProfileCreateManyArgs} args - Arguments to create many KeycapProfiles.
     * @example
     * // Create many KeycapProfiles
     * const keycapProfile = await prisma.keycapProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeycapProfileCreateManyArgs>(args?: SelectSubset<T, KeycapProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeycapProfiles and returns the data saved in the database.
     * @param {KeycapProfileCreateManyAndReturnArgs} args - Arguments to create many KeycapProfiles.
     * @example
     * // Create many KeycapProfiles
     * const keycapProfile = await prisma.keycapProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeycapProfiles and only return the `id`
     * const keycapProfileWithIdOnly = await prisma.keycapProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeycapProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, KeycapProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeycapProfile.
     * @param {KeycapProfileDeleteArgs} args - Arguments to delete one KeycapProfile.
     * @example
     * // Delete one KeycapProfile
     * const KeycapProfile = await prisma.keycapProfile.delete({
     *   where: {
     *     // ... filter to delete one KeycapProfile
     *   }
     * })
     * 
     */
    delete<T extends KeycapProfileDeleteArgs>(args: SelectSubset<T, KeycapProfileDeleteArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeycapProfile.
     * @param {KeycapProfileUpdateArgs} args - Arguments to update one KeycapProfile.
     * @example
     * // Update one KeycapProfile
     * const keycapProfile = await prisma.keycapProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeycapProfileUpdateArgs>(args: SelectSubset<T, KeycapProfileUpdateArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeycapProfiles.
     * @param {KeycapProfileDeleteManyArgs} args - Arguments to filter KeycapProfiles to delete.
     * @example
     * // Delete a few KeycapProfiles
     * const { count } = await prisma.keycapProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeycapProfileDeleteManyArgs>(args?: SelectSubset<T, KeycapProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeycapProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeycapProfiles
     * const keycapProfile = await prisma.keycapProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeycapProfileUpdateManyArgs>(args: SelectSubset<T, KeycapProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeycapProfiles and returns the data updated in the database.
     * @param {KeycapProfileUpdateManyAndReturnArgs} args - Arguments to update many KeycapProfiles.
     * @example
     * // Update many KeycapProfiles
     * const keycapProfile = await prisma.keycapProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KeycapProfiles and only return the `id`
     * const keycapProfileWithIdOnly = await prisma.keycapProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeycapProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, KeycapProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KeycapProfile.
     * @param {KeycapProfileUpsertArgs} args - Arguments to update or create a KeycapProfile.
     * @example
     * // Update or create a KeycapProfile
     * const keycapProfile = await prisma.keycapProfile.upsert({
     *   create: {
     *     // ... data to create a KeycapProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeycapProfile we want to update
     *   }
     * })
     */
    upsert<T extends KeycapProfileUpsertArgs>(args: SelectSubset<T, KeycapProfileUpsertArgs<ExtArgs>>): Prisma__KeycapProfileClient<$Result.GetResult<Prisma.$KeycapProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeycapProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileCountArgs} args - Arguments to filter KeycapProfiles to count.
     * @example
     * // Count the number of KeycapProfiles
     * const count = await prisma.keycapProfile.count({
     *   where: {
     *     // ... the filter for the KeycapProfiles we want to count
     *   }
     * })
    **/
    count<T extends KeycapProfileCountArgs>(
      args?: Subset<T, KeycapProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeycapProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeycapProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeycapProfileAggregateArgs>(args: Subset<T, KeycapProfileAggregateArgs>): Prisma.PrismaPromise<GetKeycapProfileAggregateType<T>>

    /**
     * Group by KeycapProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeycapProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeycapProfileGroupByArgs['orderBy'] }
        : { orderBy?: KeycapProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeycapProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeycapProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeycapProfile model
   */
  readonly fields: KeycapProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeycapProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeycapProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Keycap<T extends KeycapProfile$KeycapArgs<ExtArgs> = {}>(args?: Subset<T, KeycapProfile$KeycapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeycapProfile model
   */
  interface KeycapProfileFieldRefs {
    readonly id: FieldRef<"KeycapProfile", 'String'>
    readonly name: FieldRef<"KeycapProfile", 'String'>
    readonly createdAt: FieldRef<"KeycapProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"KeycapProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeycapProfile findUnique
   */
  export type KeycapProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * Filter, which KeycapProfile to fetch.
     */
    where: KeycapProfileWhereUniqueInput
  }

  /**
   * KeycapProfile findUniqueOrThrow
   */
  export type KeycapProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * Filter, which KeycapProfile to fetch.
     */
    where: KeycapProfileWhereUniqueInput
  }

  /**
   * KeycapProfile findFirst
   */
  export type KeycapProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * Filter, which KeycapProfile to fetch.
     */
    where?: KeycapProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapProfiles to fetch.
     */
    orderBy?: KeycapProfileOrderByWithRelationInput | KeycapProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeycapProfiles.
     */
    cursor?: KeycapProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeycapProfiles.
     */
    distinct?: KeycapProfileScalarFieldEnum | KeycapProfileScalarFieldEnum[]
  }

  /**
   * KeycapProfile findFirstOrThrow
   */
  export type KeycapProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * Filter, which KeycapProfile to fetch.
     */
    where?: KeycapProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapProfiles to fetch.
     */
    orderBy?: KeycapProfileOrderByWithRelationInput | KeycapProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeycapProfiles.
     */
    cursor?: KeycapProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeycapProfiles.
     */
    distinct?: KeycapProfileScalarFieldEnum | KeycapProfileScalarFieldEnum[]
  }

  /**
   * KeycapProfile findMany
   */
  export type KeycapProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * Filter, which KeycapProfiles to fetch.
     */
    where?: KeycapProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapProfiles to fetch.
     */
    orderBy?: KeycapProfileOrderByWithRelationInput | KeycapProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeycapProfiles.
     */
    cursor?: KeycapProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapProfiles.
     */
    skip?: number
    distinct?: KeycapProfileScalarFieldEnum | KeycapProfileScalarFieldEnum[]
  }

  /**
   * KeycapProfile create
   */
  export type KeycapProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a KeycapProfile.
     */
    data: XOR<KeycapProfileCreateInput, KeycapProfileUncheckedCreateInput>
  }

  /**
   * KeycapProfile createMany
   */
  export type KeycapProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeycapProfiles.
     */
    data: KeycapProfileCreateManyInput | KeycapProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeycapProfile createManyAndReturn
   */
  export type KeycapProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * The data used to create many KeycapProfiles.
     */
    data: KeycapProfileCreateManyInput | KeycapProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeycapProfile update
   */
  export type KeycapProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a KeycapProfile.
     */
    data: XOR<KeycapProfileUpdateInput, KeycapProfileUncheckedUpdateInput>
    /**
     * Choose, which KeycapProfile to update.
     */
    where: KeycapProfileWhereUniqueInput
  }

  /**
   * KeycapProfile updateMany
   */
  export type KeycapProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeycapProfiles.
     */
    data: XOR<KeycapProfileUpdateManyMutationInput, KeycapProfileUncheckedUpdateManyInput>
    /**
     * Filter which KeycapProfiles to update
     */
    where?: KeycapProfileWhereInput
    /**
     * Limit how many KeycapProfiles to update.
     */
    limit?: number
  }

  /**
   * KeycapProfile updateManyAndReturn
   */
  export type KeycapProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * The data used to update KeycapProfiles.
     */
    data: XOR<KeycapProfileUpdateManyMutationInput, KeycapProfileUncheckedUpdateManyInput>
    /**
     * Filter which KeycapProfiles to update
     */
    where?: KeycapProfileWhereInput
    /**
     * Limit how many KeycapProfiles to update.
     */
    limit?: number
  }

  /**
   * KeycapProfile upsert
   */
  export type KeycapProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the KeycapProfile to update in case it exists.
     */
    where: KeycapProfileWhereUniqueInput
    /**
     * In case the KeycapProfile found by the `where` argument doesn't exist, create a new KeycapProfile with this data.
     */
    create: XOR<KeycapProfileCreateInput, KeycapProfileUncheckedCreateInput>
    /**
     * In case the KeycapProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeycapProfileUpdateInput, KeycapProfileUncheckedUpdateInput>
  }

  /**
   * KeycapProfile delete
   */
  export type KeycapProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
    /**
     * Filter which KeycapProfile to delete.
     */
    where: KeycapProfileWhereUniqueInput
  }

  /**
   * KeycapProfile deleteMany
   */
  export type KeycapProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeycapProfiles to delete
     */
    where?: KeycapProfileWhereInput
    /**
     * Limit how many KeycapProfiles to delete.
     */
    limit?: number
  }

  /**
   * KeycapProfile.Keycap
   */
  export type KeycapProfile$KeycapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    where?: KeycapWhereInput
    orderBy?: KeycapOrderByWithRelationInput | KeycapOrderByWithRelationInput[]
    cursor?: KeycapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeycapScalarFieldEnum | KeycapScalarFieldEnum[]
  }

  /**
   * KeycapProfile without action
   */
  export type KeycapProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapProfile
     */
    select?: KeycapProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapProfile
     */
    omit?: KeycapProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapProfileInclude<ExtArgs> | null
  }


  /**
   * Model KeycapMaterial
   */

  export type AggregateKeycapMaterial = {
    _count: KeycapMaterialCountAggregateOutputType | null
    _min: KeycapMaterialMinAggregateOutputType | null
    _max: KeycapMaterialMaxAggregateOutputType | null
  }

  export type KeycapMaterialMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeycapMaterialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeycapMaterialCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeycapMaterialMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeycapMaterialMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeycapMaterialCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeycapMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeycapMaterial to aggregate.
     */
    where?: KeycapMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapMaterials to fetch.
     */
    orderBy?: KeycapMaterialOrderByWithRelationInput | KeycapMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeycapMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeycapMaterials
    **/
    _count?: true | KeycapMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeycapMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeycapMaterialMaxAggregateInputType
  }

  export type GetKeycapMaterialAggregateType<T extends KeycapMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateKeycapMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeycapMaterial[P]>
      : GetScalarType<T[P], AggregateKeycapMaterial[P]>
  }




  export type KeycapMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeycapMaterialWhereInput
    orderBy?: KeycapMaterialOrderByWithAggregationInput | KeycapMaterialOrderByWithAggregationInput[]
    by: KeycapMaterialScalarFieldEnum[] | KeycapMaterialScalarFieldEnum
    having?: KeycapMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeycapMaterialCountAggregateInputType | true
    _min?: KeycapMaterialMinAggregateInputType
    _max?: KeycapMaterialMaxAggregateInputType
  }

  export type KeycapMaterialGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: KeycapMaterialCountAggregateOutputType | null
    _min: KeycapMaterialMinAggregateOutputType | null
    _max: KeycapMaterialMaxAggregateOutputType | null
  }

  type GetKeycapMaterialGroupByPayload<T extends KeycapMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeycapMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeycapMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeycapMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], KeycapMaterialGroupByOutputType[P]>
        }
      >
    >


  export type KeycapMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Keycap?: boolean | KeycapMaterial$KeycapArgs<ExtArgs>
    _count?: boolean | KeycapMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keycapMaterial"]>

  export type KeycapMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["keycapMaterial"]>

  export type KeycapMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["keycapMaterial"]>

  export type KeycapMaterialSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeycapMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["keycapMaterial"]>
  export type KeycapMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Keycap?: boolean | KeycapMaterial$KeycapArgs<ExtArgs>
    _count?: boolean | KeycapMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeycapMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KeycapMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KeycapMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeycapMaterial"
    objects: {
      Keycap: Prisma.$KeycapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keycapMaterial"]>
    composites: {}
  }

  type KeycapMaterialGetPayload<S extends boolean | null | undefined | KeycapMaterialDefaultArgs> = $Result.GetResult<Prisma.$KeycapMaterialPayload, S>

  type KeycapMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeycapMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeycapMaterialCountAggregateInputType | true
    }

  export interface KeycapMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeycapMaterial'], meta: { name: 'KeycapMaterial' } }
    /**
     * Find zero or one KeycapMaterial that matches the filter.
     * @param {KeycapMaterialFindUniqueArgs} args - Arguments to find a KeycapMaterial
     * @example
     * // Get one KeycapMaterial
     * const keycapMaterial = await prisma.keycapMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeycapMaterialFindUniqueArgs>(args: SelectSubset<T, KeycapMaterialFindUniqueArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeycapMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeycapMaterialFindUniqueOrThrowArgs} args - Arguments to find a KeycapMaterial
     * @example
     * // Get one KeycapMaterial
     * const keycapMaterial = await prisma.keycapMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeycapMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, KeycapMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeycapMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialFindFirstArgs} args - Arguments to find a KeycapMaterial
     * @example
     * // Get one KeycapMaterial
     * const keycapMaterial = await prisma.keycapMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeycapMaterialFindFirstArgs>(args?: SelectSubset<T, KeycapMaterialFindFirstArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeycapMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialFindFirstOrThrowArgs} args - Arguments to find a KeycapMaterial
     * @example
     * // Get one KeycapMaterial
     * const keycapMaterial = await prisma.keycapMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeycapMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, KeycapMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeycapMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeycapMaterials
     * const keycapMaterials = await prisma.keycapMaterial.findMany()
     * 
     * // Get first 10 KeycapMaterials
     * const keycapMaterials = await prisma.keycapMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keycapMaterialWithIdOnly = await prisma.keycapMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeycapMaterialFindManyArgs>(args?: SelectSubset<T, KeycapMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeycapMaterial.
     * @param {KeycapMaterialCreateArgs} args - Arguments to create a KeycapMaterial.
     * @example
     * // Create one KeycapMaterial
     * const KeycapMaterial = await prisma.keycapMaterial.create({
     *   data: {
     *     // ... data to create a KeycapMaterial
     *   }
     * })
     * 
     */
    create<T extends KeycapMaterialCreateArgs>(args: SelectSubset<T, KeycapMaterialCreateArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeycapMaterials.
     * @param {KeycapMaterialCreateManyArgs} args - Arguments to create many KeycapMaterials.
     * @example
     * // Create many KeycapMaterials
     * const keycapMaterial = await prisma.keycapMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeycapMaterialCreateManyArgs>(args?: SelectSubset<T, KeycapMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KeycapMaterials and returns the data saved in the database.
     * @param {KeycapMaterialCreateManyAndReturnArgs} args - Arguments to create many KeycapMaterials.
     * @example
     * // Create many KeycapMaterials
     * const keycapMaterial = await prisma.keycapMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KeycapMaterials and only return the `id`
     * const keycapMaterialWithIdOnly = await prisma.keycapMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeycapMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, KeycapMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KeycapMaterial.
     * @param {KeycapMaterialDeleteArgs} args - Arguments to delete one KeycapMaterial.
     * @example
     * // Delete one KeycapMaterial
     * const KeycapMaterial = await prisma.keycapMaterial.delete({
     *   where: {
     *     // ... filter to delete one KeycapMaterial
     *   }
     * })
     * 
     */
    delete<T extends KeycapMaterialDeleteArgs>(args: SelectSubset<T, KeycapMaterialDeleteArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeycapMaterial.
     * @param {KeycapMaterialUpdateArgs} args - Arguments to update one KeycapMaterial.
     * @example
     * // Update one KeycapMaterial
     * const keycapMaterial = await prisma.keycapMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeycapMaterialUpdateArgs>(args: SelectSubset<T, KeycapMaterialUpdateArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeycapMaterials.
     * @param {KeycapMaterialDeleteManyArgs} args - Arguments to filter KeycapMaterials to delete.
     * @example
     * // Delete a few KeycapMaterials
     * const { count } = await prisma.keycapMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeycapMaterialDeleteManyArgs>(args?: SelectSubset<T, KeycapMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeycapMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeycapMaterials
     * const keycapMaterial = await prisma.keycapMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeycapMaterialUpdateManyArgs>(args: SelectSubset<T, KeycapMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeycapMaterials and returns the data updated in the database.
     * @param {KeycapMaterialUpdateManyAndReturnArgs} args - Arguments to update many KeycapMaterials.
     * @example
     * // Update many KeycapMaterials
     * const keycapMaterial = await prisma.keycapMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KeycapMaterials and only return the `id`
     * const keycapMaterialWithIdOnly = await prisma.keycapMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeycapMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, KeycapMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KeycapMaterial.
     * @param {KeycapMaterialUpsertArgs} args - Arguments to update or create a KeycapMaterial.
     * @example
     * // Update or create a KeycapMaterial
     * const keycapMaterial = await prisma.keycapMaterial.upsert({
     *   create: {
     *     // ... data to create a KeycapMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeycapMaterial we want to update
     *   }
     * })
     */
    upsert<T extends KeycapMaterialUpsertArgs>(args: SelectSubset<T, KeycapMaterialUpsertArgs<ExtArgs>>): Prisma__KeycapMaterialClient<$Result.GetResult<Prisma.$KeycapMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KeycapMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialCountArgs} args - Arguments to filter KeycapMaterials to count.
     * @example
     * // Count the number of KeycapMaterials
     * const count = await prisma.keycapMaterial.count({
     *   where: {
     *     // ... the filter for the KeycapMaterials we want to count
     *   }
     * })
    **/
    count<T extends KeycapMaterialCountArgs>(
      args?: Subset<T, KeycapMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeycapMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeycapMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeycapMaterialAggregateArgs>(args: Subset<T, KeycapMaterialAggregateArgs>): Prisma.PrismaPromise<GetKeycapMaterialAggregateType<T>>

    /**
     * Group by KeycapMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeycapMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeycapMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeycapMaterialGroupByArgs['orderBy'] }
        : { orderBy?: KeycapMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeycapMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeycapMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeycapMaterial model
   */
  readonly fields: KeycapMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeycapMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeycapMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Keycap<T extends KeycapMaterial$KeycapArgs<ExtArgs> = {}>(args?: Subset<T, KeycapMaterial$KeycapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeycapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeycapMaterial model
   */
  interface KeycapMaterialFieldRefs {
    readonly id: FieldRef<"KeycapMaterial", 'String'>
    readonly name: FieldRef<"KeycapMaterial", 'String'>
    readonly createdAt: FieldRef<"KeycapMaterial", 'DateTime'>
    readonly updatedAt: FieldRef<"KeycapMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeycapMaterial findUnique
   */
  export type KeycapMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * Filter, which KeycapMaterial to fetch.
     */
    where: KeycapMaterialWhereUniqueInput
  }

  /**
   * KeycapMaterial findUniqueOrThrow
   */
  export type KeycapMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * Filter, which KeycapMaterial to fetch.
     */
    where: KeycapMaterialWhereUniqueInput
  }

  /**
   * KeycapMaterial findFirst
   */
  export type KeycapMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * Filter, which KeycapMaterial to fetch.
     */
    where?: KeycapMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapMaterials to fetch.
     */
    orderBy?: KeycapMaterialOrderByWithRelationInput | KeycapMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeycapMaterials.
     */
    cursor?: KeycapMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeycapMaterials.
     */
    distinct?: KeycapMaterialScalarFieldEnum | KeycapMaterialScalarFieldEnum[]
  }

  /**
   * KeycapMaterial findFirstOrThrow
   */
  export type KeycapMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * Filter, which KeycapMaterial to fetch.
     */
    where?: KeycapMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapMaterials to fetch.
     */
    orderBy?: KeycapMaterialOrderByWithRelationInput | KeycapMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeycapMaterials.
     */
    cursor?: KeycapMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeycapMaterials.
     */
    distinct?: KeycapMaterialScalarFieldEnum | KeycapMaterialScalarFieldEnum[]
  }

  /**
   * KeycapMaterial findMany
   */
  export type KeycapMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * Filter, which KeycapMaterials to fetch.
     */
    where?: KeycapMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeycapMaterials to fetch.
     */
    orderBy?: KeycapMaterialOrderByWithRelationInput | KeycapMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeycapMaterials.
     */
    cursor?: KeycapMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeycapMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeycapMaterials.
     */
    skip?: number
    distinct?: KeycapMaterialScalarFieldEnum | KeycapMaterialScalarFieldEnum[]
  }

  /**
   * KeycapMaterial create
   */
  export type KeycapMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a KeycapMaterial.
     */
    data: XOR<KeycapMaterialCreateInput, KeycapMaterialUncheckedCreateInput>
  }

  /**
   * KeycapMaterial createMany
   */
  export type KeycapMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeycapMaterials.
     */
    data: KeycapMaterialCreateManyInput | KeycapMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeycapMaterial createManyAndReturn
   */
  export type KeycapMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many KeycapMaterials.
     */
    data: KeycapMaterialCreateManyInput | KeycapMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeycapMaterial update
   */
  export type KeycapMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a KeycapMaterial.
     */
    data: XOR<KeycapMaterialUpdateInput, KeycapMaterialUncheckedUpdateInput>
    /**
     * Choose, which KeycapMaterial to update.
     */
    where: KeycapMaterialWhereUniqueInput
  }

  /**
   * KeycapMaterial updateMany
   */
  export type KeycapMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeycapMaterials.
     */
    data: XOR<KeycapMaterialUpdateManyMutationInput, KeycapMaterialUncheckedUpdateManyInput>
    /**
     * Filter which KeycapMaterials to update
     */
    where?: KeycapMaterialWhereInput
    /**
     * Limit how many KeycapMaterials to update.
     */
    limit?: number
  }

  /**
   * KeycapMaterial updateManyAndReturn
   */
  export type KeycapMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * The data used to update KeycapMaterials.
     */
    data: XOR<KeycapMaterialUpdateManyMutationInput, KeycapMaterialUncheckedUpdateManyInput>
    /**
     * Filter which KeycapMaterials to update
     */
    where?: KeycapMaterialWhereInput
    /**
     * Limit how many KeycapMaterials to update.
     */
    limit?: number
  }

  /**
   * KeycapMaterial upsert
   */
  export type KeycapMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the KeycapMaterial to update in case it exists.
     */
    where: KeycapMaterialWhereUniqueInput
    /**
     * In case the KeycapMaterial found by the `where` argument doesn't exist, create a new KeycapMaterial with this data.
     */
    create: XOR<KeycapMaterialCreateInput, KeycapMaterialUncheckedCreateInput>
    /**
     * In case the KeycapMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeycapMaterialUpdateInput, KeycapMaterialUncheckedUpdateInput>
  }

  /**
   * KeycapMaterial delete
   */
  export type KeycapMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
    /**
     * Filter which KeycapMaterial to delete.
     */
    where: KeycapMaterialWhereUniqueInput
  }

  /**
   * KeycapMaterial deleteMany
   */
  export type KeycapMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeycapMaterials to delete
     */
    where?: KeycapMaterialWhereInput
    /**
     * Limit how many KeycapMaterials to delete.
     */
    limit?: number
  }

  /**
   * KeycapMaterial.Keycap
   */
  export type KeycapMaterial$KeycapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keycap
     */
    select?: KeycapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keycap
     */
    omit?: KeycapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapInclude<ExtArgs> | null
    where?: KeycapWhereInput
    orderBy?: KeycapOrderByWithRelationInput | KeycapOrderByWithRelationInput[]
    cursor?: KeycapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeycapScalarFieldEnum | KeycapScalarFieldEnum[]
  }

  /**
   * KeycapMaterial without action
   */
  export type KeycapMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeycapMaterial
     */
    select?: KeycapMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeycapMaterial
     */
    omit?: KeycapMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeycapMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Accessory
   */

  export type AggregateAccessory = {
    _count: AccessoryCountAggregateOutputType | null
    _min: AccessoryMinAggregateOutputType | null
    _max: AccessoryMaxAggregateOutputType | null
  }

  export type AccessoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    typeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    typeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessoryCountAggregateOutputType = {
    id: number
    productId: number
    typeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccessoryMinAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessoryMaxAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessoryCountAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccessoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accessory to aggregate.
     */
    where?: AccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoryOrderByWithRelationInput | AccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accessories
    **/
    _count?: true | AccessoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessoryMaxAggregateInputType
  }

  export type GetAccessoryAggregateType<T extends AccessoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessory[P]>
      : GetScalarType<T[P], AggregateAccessory[P]>
  }




  export type AccessoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryWhereInput
    orderBy?: AccessoryOrderByWithAggregationInput | AccessoryOrderByWithAggregationInput[]
    by: AccessoryScalarFieldEnum[] | AccessoryScalarFieldEnum
    having?: AccessoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessoryCountAggregateInputType | true
    _min?: AccessoryMinAggregateInputType
    _max?: AccessoryMaxAggregateInputType
  }

  export type AccessoryGroupByOutputType = {
    id: string
    productId: string
    typeId: string
    createdAt: Date
    updatedAt: Date
    _count: AccessoryCountAggregateOutputType | null
    _min: AccessoryMinAggregateOutputType | null
    _max: AccessoryMaxAggregateOutputType | null
  }

  type GetAccessoryGroupByPayload<T extends AccessoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessoryGroupByOutputType[P]>
            : GetScalarType<T[P], AccessoryGroupByOutputType[P]>
        }
      >
    >


  export type AccessorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    type?: boolean | AccessoryTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessory"]>

  export type AccessorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    type?: boolean | AccessoryTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessory"]>

  export type AccessorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    type?: boolean | AccessoryTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessory"]>

  export type AccessorySelectScalar = {
    id?: boolean
    productId?: boolean
    typeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccessoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "typeId" | "createdAt" | "updatedAt", ExtArgs["result"]["accessory"]>
  export type AccessoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    type?: boolean | AccessoryTypeDefaultArgs<ExtArgs>
  }
  export type AccessoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    type?: boolean | AccessoryTypeDefaultArgs<ExtArgs>
  }
  export type AccessoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    type?: boolean | AccessoryTypeDefaultArgs<ExtArgs>
  }

  export type $AccessoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Accessory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      type: Prisma.$AccessoryTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      typeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accessory"]>
    composites: {}
  }

  type AccessoryGetPayload<S extends boolean | null | undefined | AccessoryDefaultArgs> = $Result.GetResult<Prisma.$AccessoryPayload, S>

  type AccessoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessoryCountAggregateInputType | true
    }

  export interface AccessoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accessory'], meta: { name: 'Accessory' } }
    /**
     * Find zero or one Accessory that matches the filter.
     * @param {AccessoryFindUniqueArgs} args - Arguments to find a Accessory
     * @example
     * // Get one Accessory
     * const accessory = await prisma.accessory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessoryFindUniqueArgs>(args: SelectSubset<T, AccessoryFindUniqueArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accessory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessoryFindUniqueOrThrowArgs} args - Arguments to find a Accessory
     * @example
     * // Get one Accessory
     * const accessory = await prisma.accessory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accessory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFindFirstArgs} args - Arguments to find a Accessory
     * @example
     * // Get one Accessory
     * const accessory = await prisma.accessory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessoryFindFirstArgs>(args?: SelectSubset<T, AccessoryFindFirstArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accessory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFindFirstOrThrowArgs} args - Arguments to find a Accessory
     * @example
     * // Get one Accessory
     * const accessory = await prisma.accessory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accessories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accessories
     * const accessories = await prisma.accessory.findMany()
     * 
     * // Get first 10 Accessories
     * const accessories = await prisma.accessory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessoryWithIdOnly = await prisma.accessory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessoryFindManyArgs>(args?: SelectSubset<T, AccessoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accessory.
     * @param {AccessoryCreateArgs} args - Arguments to create a Accessory.
     * @example
     * // Create one Accessory
     * const Accessory = await prisma.accessory.create({
     *   data: {
     *     // ... data to create a Accessory
     *   }
     * })
     * 
     */
    create<T extends AccessoryCreateArgs>(args: SelectSubset<T, AccessoryCreateArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accessories.
     * @param {AccessoryCreateManyArgs} args - Arguments to create many Accessories.
     * @example
     * // Create many Accessories
     * const accessory = await prisma.accessory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessoryCreateManyArgs>(args?: SelectSubset<T, AccessoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accessories and returns the data saved in the database.
     * @param {AccessoryCreateManyAndReturnArgs} args - Arguments to create many Accessories.
     * @example
     * // Create many Accessories
     * const accessory = await prisma.accessory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accessories and only return the `id`
     * const accessoryWithIdOnly = await prisma.accessory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Accessory.
     * @param {AccessoryDeleteArgs} args - Arguments to delete one Accessory.
     * @example
     * // Delete one Accessory
     * const Accessory = await prisma.accessory.delete({
     *   where: {
     *     // ... filter to delete one Accessory
     *   }
     * })
     * 
     */
    delete<T extends AccessoryDeleteArgs>(args: SelectSubset<T, AccessoryDeleteArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accessory.
     * @param {AccessoryUpdateArgs} args - Arguments to update one Accessory.
     * @example
     * // Update one Accessory
     * const accessory = await prisma.accessory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessoryUpdateArgs>(args: SelectSubset<T, AccessoryUpdateArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accessories.
     * @param {AccessoryDeleteManyArgs} args - Arguments to filter Accessories to delete.
     * @example
     * // Delete a few Accessories
     * const { count } = await prisma.accessory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessoryDeleteManyArgs>(args?: SelectSubset<T, AccessoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accessories
     * const accessory = await prisma.accessory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessoryUpdateManyArgs>(args: SelectSubset<T, AccessoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accessories and returns the data updated in the database.
     * @param {AccessoryUpdateManyAndReturnArgs} args - Arguments to update many Accessories.
     * @example
     * // Update many Accessories
     * const accessory = await prisma.accessory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accessories and only return the `id`
     * const accessoryWithIdOnly = await prisma.accessory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Accessory.
     * @param {AccessoryUpsertArgs} args - Arguments to update or create a Accessory.
     * @example
     * // Update or create a Accessory
     * const accessory = await prisma.accessory.upsert({
     *   create: {
     *     // ... data to create a Accessory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accessory we want to update
     *   }
     * })
     */
    upsert<T extends AccessoryUpsertArgs>(args: SelectSubset<T, AccessoryUpsertArgs<ExtArgs>>): Prisma__AccessoryClient<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryCountArgs} args - Arguments to filter Accessories to count.
     * @example
     * // Count the number of Accessories
     * const count = await prisma.accessory.count({
     *   where: {
     *     // ... the filter for the Accessories we want to count
     *   }
     * })
    **/
    count<T extends AccessoryCountArgs>(
      args?: Subset<T, AccessoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accessory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessoryAggregateArgs>(args: Subset<T, AccessoryAggregateArgs>): Prisma.PrismaPromise<GetAccessoryAggregateType<T>>

    /**
     * Group by Accessory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessoryGroupByArgs['orderBy'] }
        : { orderBy?: AccessoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accessory model
   */
  readonly fields: AccessoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accessory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    type<T extends AccessoryTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccessoryTypeDefaultArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Accessory model
   */
  interface AccessoryFieldRefs {
    readonly id: FieldRef<"Accessory", 'String'>
    readonly productId: FieldRef<"Accessory", 'String'>
    readonly typeId: FieldRef<"Accessory", 'String'>
    readonly createdAt: FieldRef<"Accessory", 'DateTime'>
    readonly updatedAt: FieldRef<"Accessory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Accessory findUnique
   */
  export type AccessoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * Filter, which Accessory to fetch.
     */
    where: AccessoryWhereUniqueInput
  }

  /**
   * Accessory findUniqueOrThrow
   */
  export type AccessoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * Filter, which Accessory to fetch.
     */
    where: AccessoryWhereUniqueInput
  }

  /**
   * Accessory findFirst
   */
  export type AccessoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * Filter, which Accessory to fetch.
     */
    where?: AccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoryOrderByWithRelationInput | AccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accessories.
     */
    cursor?: AccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accessories.
     */
    distinct?: AccessoryScalarFieldEnum | AccessoryScalarFieldEnum[]
  }

  /**
   * Accessory findFirstOrThrow
   */
  export type AccessoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * Filter, which Accessory to fetch.
     */
    where?: AccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoryOrderByWithRelationInput | AccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accessories.
     */
    cursor?: AccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accessories.
     */
    distinct?: AccessoryScalarFieldEnum | AccessoryScalarFieldEnum[]
  }

  /**
   * Accessory findMany
   */
  export type AccessoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * Filter, which Accessories to fetch.
     */
    where?: AccessoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoryOrderByWithRelationInput | AccessoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accessories.
     */
    cursor?: AccessoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    distinct?: AccessoryScalarFieldEnum | AccessoryScalarFieldEnum[]
  }

  /**
   * Accessory create
   */
  export type AccessoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Accessory.
     */
    data: XOR<AccessoryCreateInput, AccessoryUncheckedCreateInput>
  }

  /**
   * Accessory createMany
   */
  export type AccessoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accessories.
     */
    data: AccessoryCreateManyInput | AccessoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Accessory createManyAndReturn
   */
  export type AccessoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * The data used to create many Accessories.
     */
    data: AccessoryCreateManyInput | AccessoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Accessory update
   */
  export type AccessoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Accessory.
     */
    data: XOR<AccessoryUpdateInput, AccessoryUncheckedUpdateInput>
    /**
     * Choose, which Accessory to update.
     */
    where: AccessoryWhereUniqueInput
  }

  /**
   * Accessory updateMany
   */
  export type AccessoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accessories.
     */
    data: XOR<AccessoryUpdateManyMutationInput, AccessoryUncheckedUpdateManyInput>
    /**
     * Filter which Accessories to update
     */
    where?: AccessoryWhereInput
    /**
     * Limit how many Accessories to update.
     */
    limit?: number
  }

  /**
   * Accessory updateManyAndReturn
   */
  export type AccessoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * The data used to update Accessories.
     */
    data: XOR<AccessoryUpdateManyMutationInput, AccessoryUncheckedUpdateManyInput>
    /**
     * Filter which Accessories to update
     */
    where?: AccessoryWhereInput
    /**
     * Limit how many Accessories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Accessory upsert
   */
  export type AccessoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Accessory to update in case it exists.
     */
    where: AccessoryWhereUniqueInput
    /**
     * In case the Accessory found by the `where` argument doesn't exist, create a new Accessory with this data.
     */
    create: XOR<AccessoryCreateInput, AccessoryUncheckedCreateInput>
    /**
     * In case the Accessory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessoryUpdateInput, AccessoryUncheckedUpdateInput>
  }

  /**
   * Accessory delete
   */
  export type AccessoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    /**
     * Filter which Accessory to delete.
     */
    where: AccessoryWhereUniqueInput
  }

  /**
   * Accessory deleteMany
   */
  export type AccessoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accessories to delete
     */
    where?: AccessoryWhereInput
    /**
     * Limit how many Accessories to delete.
     */
    limit?: number
  }

  /**
   * Accessory without action
   */
  export type AccessoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
  }


  /**
   * Model AccessoryType
   */

  export type AggregateAccessoryType = {
    _count: AccessoryTypeCountAggregateOutputType | null
    _min: AccessoryTypeMinAggregateOutputType | null
    _max: AccessoryTypeMaxAggregateOutputType | null
  }

  export type AccessoryTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessoryTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessoryTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccessoryTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessoryTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessoryTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccessoryTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessoryType to aggregate.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessoryTypes
    **/
    _count?: true | AccessoryTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessoryTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessoryTypeMaxAggregateInputType
  }

  export type GetAccessoryTypeAggregateType<T extends AccessoryTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessoryType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessoryType[P]>
      : GetScalarType<T[P], AggregateAccessoryType[P]>
  }




  export type AccessoryTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessoryTypeWhereInput
    orderBy?: AccessoryTypeOrderByWithAggregationInput | AccessoryTypeOrderByWithAggregationInput[]
    by: AccessoryTypeScalarFieldEnum[] | AccessoryTypeScalarFieldEnum
    having?: AccessoryTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessoryTypeCountAggregateInputType | true
    _min?: AccessoryTypeMinAggregateInputType
    _max?: AccessoryTypeMaxAggregateInputType
  }

  export type AccessoryTypeGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: AccessoryTypeCountAggregateOutputType | null
    _min: AccessoryTypeMinAggregateOutputType | null
    _max: AccessoryTypeMaxAggregateOutputType | null
  }

  type GetAccessoryTypeGroupByPayload<T extends AccessoryTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessoryTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessoryTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessoryTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AccessoryTypeGroupByOutputType[P]>
        }
      >
    >


  export type AccessoryTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Accessory?: boolean | AccessoryType$AccessoryArgs<ExtArgs>
    _count?: boolean | AccessoryTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessoryType"]>

  export type AccessoryTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accessoryType"]>

  export type AccessoryTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accessoryType"]>

  export type AccessoryTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccessoryTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["accessoryType"]>
  export type AccessoryTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Accessory?: boolean | AccessoryType$AccessoryArgs<ExtArgs>
    _count?: boolean | AccessoryTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccessoryTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccessoryTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccessoryTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessoryType"
    objects: {
      Accessory: Prisma.$AccessoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accessoryType"]>
    composites: {}
  }

  type AccessoryTypeGetPayload<S extends boolean | null | undefined | AccessoryTypeDefaultArgs> = $Result.GetResult<Prisma.$AccessoryTypePayload, S>

  type AccessoryTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessoryTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessoryTypeCountAggregateInputType | true
    }

  export interface AccessoryTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessoryType'], meta: { name: 'AccessoryType' } }
    /**
     * Find zero or one AccessoryType that matches the filter.
     * @param {AccessoryTypeFindUniqueArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessoryTypeFindUniqueArgs>(args: SelectSubset<T, AccessoryTypeFindUniqueArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessoryType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessoryTypeFindUniqueOrThrowArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessoryTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessoryTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessoryType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeFindFirstArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessoryTypeFindFirstArgs>(args?: SelectSubset<T, AccessoryTypeFindFirstArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessoryType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeFindFirstOrThrowArgs} args - Arguments to find a AccessoryType
     * @example
     * // Get one AccessoryType
     * const accessoryType = await prisma.accessoryType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessoryTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessoryTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessoryTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessoryTypes
     * const accessoryTypes = await prisma.accessoryType.findMany()
     * 
     * // Get first 10 AccessoryTypes
     * const accessoryTypes = await prisma.accessoryType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessoryTypeWithIdOnly = await prisma.accessoryType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessoryTypeFindManyArgs>(args?: SelectSubset<T, AccessoryTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessoryType.
     * @param {AccessoryTypeCreateArgs} args - Arguments to create a AccessoryType.
     * @example
     * // Create one AccessoryType
     * const AccessoryType = await prisma.accessoryType.create({
     *   data: {
     *     // ... data to create a AccessoryType
     *   }
     * })
     * 
     */
    create<T extends AccessoryTypeCreateArgs>(args: SelectSubset<T, AccessoryTypeCreateArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessoryTypes.
     * @param {AccessoryTypeCreateManyArgs} args - Arguments to create many AccessoryTypes.
     * @example
     * // Create many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessoryTypeCreateManyArgs>(args?: SelectSubset<T, AccessoryTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessoryTypes and returns the data saved in the database.
     * @param {AccessoryTypeCreateManyAndReturnArgs} args - Arguments to create many AccessoryTypes.
     * @example
     * // Create many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessoryTypes and only return the `id`
     * const accessoryTypeWithIdOnly = await prisma.accessoryType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessoryTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessoryTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessoryType.
     * @param {AccessoryTypeDeleteArgs} args - Arguments to delete one AccessoryType.
     * @example
     * // Delete one AccessoryType
     * const AccessoryType = await prisma.accessoryType.delete({
     *   where: {
     *     // ... filter to delete one AccessoryType
     *   }
     * })
     * 
     */
    delete<T extends AccessoryTypeDeleteArgs>(args: SelectSubset<T, AccessoryTypeDeleteArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessoryType.
     * @param {AccessoryTypeUpdateArgs} args - Arguments to update one AccessoryType.
     * @example
     * // Update one AccessoryType
     * const accessoryType = await prisma.accessoryType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessoryTypeUpdateArgs>(args: SelectSubset<T, AccessoryTypeUpdateArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessoryTypes.
     * @param {AccessoryTypeDeleteManyArgs} args - Arguments to filter AccessoryTypes to delete.
     * @example
     * // Delete a few AccessoryTypes
     * const { count } = await prisma.accessoryType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessoryTypeDeleteManyArgs>(args?: SelectSubset<T, AccessoryTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessoryTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessoryTypeUpdateManyArgs>(args: SelectSubset<T, AccessoryTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessoryTypes and returns the data updated in the database.
     * @param {AccessoryTypeUpdateManyAndReturnArgs} args - Arguments to update many AccessoryTypes.
     * @example
     * // Update many AccessoryTypes
     * const accessoryType = await prisma.accessoryType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessoryTypes and only return the `id`
     * const accessoryTypeWithIdOnly = await prisma.accessoryType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessoryTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessoryTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessoryType.
     * @param {AccessoryTypeUpsertArgs} args - Arguments to update or create a AccessoryType.
     * @example
     * // Update or create a AccessoryType
     * const accessoryType = await prisma.accessoryType.upsert({
     *   create: {
     *     // ... data to create a AccessoryType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessoryType we want to update
     *   }
     * })
     */
    upsert<T extends AccessoryTypeUpsertArgs>(args: SelectSubset<T, AccessoryTypeUpsertArgs<ExtArgs>>): Prisma__AccessoryTypeClient<$Result.GetResult<Prisma.$AccessoryTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessoryTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeCountArgs} args - Arguments to filter AccessoryTypes to count.
     * @example
     * // Count the number of AccessoryTypes
     * const count = await prisma.accessoryType.count({
     *   where: {
     *     // ... the filter for the AccessoryTypes we want to count
     *   }
     * })
    **/
    count<T extends AccessoryTypeCountArgs>(
      args?: Subset<T, AccessoryTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessoryTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessoryType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessoryTypeAggregateArgs>(args: Subset<T, AccessoryTypeAggregateArgs>): Prisma.PrismaPromise<GetAccessoryTypeAggregateType<T>>

    /**
     * Group by AccessoryType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoryTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessoryTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessoryTypeGroupByArgs['orderBy'] }
        : { orderBy?: AccessoryTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessoryTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessoryTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessoryType model
   */
  readonly fields: AccessoryTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessoryType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessoryTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Accessory<T extends AccessoryType$AccessoryArgs<ExtArgs> = {}>(args?: Subset<T, AccessoryType$AccessoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessoryType model
   */
  interface AccessoryTypeFieldRefs {
    readonly id: FieldRef<"AccessoryType", 'String'>
    readonly name: FieldRef<"AccessoryType", 'String'>
    readonly createdAt: FieldRef<"AccessoryType", 'DateTime'>
    readonly updatedAt: FieldRef<"AccessoryType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessoryType findUnique
   */
  export type AccessoryTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType findUniqueOrThrow
   */
  export type AccessoryTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType findFirst
   */
  export type AccessoryTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessoryTypes.
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessoryTypes.
     */
    distinct?: AccessoryTypeScalarFieldEnum | AccessoryTypeScalarFieldEnum[]
  }

  /**
   * AccessoryType findFirstOrThrow
   */
  export type AccessoryTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryType to fetch.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessoryTypes.
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessoryTypes.
     */
    distinct?: AccessoryTypeScalarFieldEnum | AccessoryTypeScalarFieldEnum[]
  }

  /**
   * AccessoryType findMany
   */
  export type AccessoryTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter, which AccessoryTypes to fetch.
     */
    where?: AccessoryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessoryTypes to fetch.
     */
    orderBy?: AccessoryTypeOrderByWithRelationInput | AccessoryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessoryTypes.
     */
    cursor?: AccessoryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessoryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessoryTypes.
     */
    skip?: number
    distinct?: AccessoryTypeScalarFieldEnum | AccessoryTypeScalarFieldEnum[]
  }

  /**
   * AccessoryType create
   */
  export type AccessoryTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessoryType.
     */
    data: XOR<AccessoryTypeCreateInput, AccessoryTypeUncheckedCreateInput>
  }

  /**
   * AccessoryType createMany
   */
  export type AccessoryTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessoryTypes.
     */
    data: AccessoryTypeCreateManyInput | AccessoryTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessoryType createManyAndReturn
   */
  export type AccessoryTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * The data used to create many AccessoryTypes.
     */
    data: AccessoryTypeCreateManyInput | AccessoryTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessoryType update
   */
  export type AccessoryTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessoryType.
     */
    data: XOR<AccessoryTypeUpdateInput, AccessoryTypeUncheckedUpdateInput>
    /**
     * Choose, which AccessoryType to update.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType updateMany
   */
  export type AccessoryTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessoryTypes.
     */
    data: XOR<AccessoryTypeUpdateManyMutationInput, AccessoryTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccessoryTypes to update
     */
    where?: AccessoryTypeWhereInput
    /**
     * Limit how many AccessoryTypes to update.
     */
    limit?: number
  }

  /**
   * AccessoryType updateManyAndReturn
   */
  export type AccessoryTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * The data used to update AccessoryTypes.
     */
    data: XOR<AccessoryTypeUpdateManyMutationInput, AccessoryTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccessoryTypes to update
     */
    where?: AccessoryTypeWhereInput
    /**
     * Limit how many AccessoryTypes to update.
     */
    limit?: number
  }

  /**
   * AccessoryType upsert
   */
  export type AccessoryTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessoryType to update in case it exists.
     */
    where: AccessoryTypeWhereUniqueInput
    /**
     * In case the AccessoryType found by the `where` argument doesn't exist, create a new AccessoryType with this data.
     */
    create: XOR<AccessoryTypeCreateInput, AccessoryTypeUncheckedCreateInput>
    /**
     * In case the AccessoryType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessoryTypeUpdateInput, AccessoryTypeUncheckedUpdateInput>
  }

  /**
   * AccessoryType delete
   */
  export type AccessoryTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
    /**
     * Filter which AccessoryType to delete.
     */
    where: AccessoryTypeWhereUniqueInput
  }

  /**
   * AccessoryType deleteMany
   */
  export type AccessoryTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessoryTypes to delete
     */
    where?: AccessoryTypeWhereInput
    /**
     * Limit how many AccessoryTypes to delete.
     */
    limit?: number
  }

  /**
   * AccessoryType.Accessory
   */
  export type AccessoryType$AccessoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessory
     */
    select?: AccessorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accessory
     */
    omit?: AccessoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryInclude<ExtArgs> | null
    where?: AccessoryWhereInput
    orderBy?: AccessoryOrderByWithRelationInput | AccessoryOrderByWithRelationInput[]
    cursor?: AccessoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessoryScalarFieldEnum | AccessoryScalarFieldEnum[]
  }

  /**
   * AccessoryType without action
   */
  export type AccessoryTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessoryType
     */
    select?: AccessoryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessoryType
     */
    omit?: AccessoryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessoryTypeInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ProductCategory?: boolean | Category$ProductCategoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | Category$ProductCategoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductCategory<T extends Category$ProductCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$ProductCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.ProductCategory
   */
  export type Category$ProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    productId: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    productId: string
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly productId: FieldRef<"ProductCategory", 'String'>
    readonly categoryId: FieldRef<"ProductCategory", 'String'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    roleId: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    address: number
    phoneNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    roleId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    address?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    roleId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    address?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    roleId?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    address?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    Cart?: boolean | User$CartArgs<ExtArgs>
    Wishlist?: boolean | User$WishlistArgs<ExtArgs>
    Bill?: boolean | User$BillArgs<ExtArgs>
    UserCoupon?: boolean | User$UserCouponArgs<ExtArgs>
    UserBuild?: boolean | User$UserBuildArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    roleId?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "email" | "passwordHash" | "firstName" | "lastName" | "address" | "phoneNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    Cart?: boolean | User$CartArgs<ExtArgs>
    Wishlist?: boolean | User$WishlistArgs<ExtArgs>
    Bill?: boolean | User$BillArgs<ExtArgs>
    UserCoupon?: boolean | User$UserCouponArgs<ExtArgs>
    UserBuild?: boolean | User$UserBuildArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      Cart: Prisma.$CartPayload<ExtArgs>[]
      Wishlist: Prisma.$WishlistPayload<ExtArgs>[]
      Bill: Prisma.$BillPayload<ExtArgs>[]
      UserCoupon: Prisma.$UserCouponPayload<ExtArgs>[]
      UserBuild: Prisma.$UserBuildPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      address: string
      phoneNumber: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Cart<T extends User$CartArgs<ExtArgs> = {}>(args?: Subset<T, User$CartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Wishlist<T extends User$WishlistArgs<ExtArgs> = {}>(args?: Subset<T, User$WishlistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bill<T extends User$BillArgs<ExtArgs> = {}>(args?: Subset<T, User$BillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserCoupon<T extends User$UserCouponArgs<ExtArgs> = {}>(args?: Subset<T, User$UserCouponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserBuild<T extends User$UserBuildArgs<ExtArgs> = {}>(args?: Subset<T, User$UserBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Cart
   */
  export type User$CartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.Wishlist
   */
  export type User$WishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * User.Bill
   */
  export type User$BillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * User.UserCoupon
   */
  export type User$UserCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    where?: UserCouponWhereInput
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    cursor?: UserCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * User.UserBuild
   */
  export type User$UserBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    where?: UserBuildWhereInput
    orderBy?: UserBuildOrderByWithRelationInput | UserBuildOrderByWithRelationInput[]
    cursor?: UserBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBuildScalarFieldEnum | UserBuildScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    CartItem?: boolean | Cart$CartItemArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    CartItem?: boolean | Cart$CartItemArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CartItem<T extends Cart$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, Cart$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.CartItem
   */
  export type Cart$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model Wishlist
   */

  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WishlistMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WishlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithAggregationInput | WishlistOrderByWithAggregationInput[]
    by: WishlistScalarFieldEnum[] | WishlistScalarFieldEnum
    having?: WishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }

  export type WishlistGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: WishlistCountAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type WishlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    WishlistItem?: boolean | Wishlist$WishlistItemArgs<ExtArgs>
    _count?: boolean | WishlistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WishlistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["wishlist"]>
  export type WishlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    WishlistItem?: boolean | Wishlist$WishlistItemArgs<ExtArgs>
    _count?: boolean | WishlistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WishlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WishlistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WishlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wishlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      WishlistItem: Prisma.$WishlistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wishlist"]>
    composites: {}
  }

  type WishlistGetPayload<S extends boolean | null | undefined | WishlistDefaultArgs> = $Result.GetResult<Prisma.$WishlistPayload, S>

  type WishlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistCountAggregateInputType | true
    }

  export interface WishlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wishlist'], meta: { name: 'Wishlist' } }
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistFindUniqueArgs>(args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wishlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistFindFirstArgs>(args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistFindManyArgs>(args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
     */
    create<T extends WishlistCreateArgs>(args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wishlists.
     * @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistCreateManyArgs>(args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wishlists and returns the data saved in the database.
     * @param {WishlistCreateManyAndReturnArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wishlists and only return the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
     */
    delete<T extends WishlistDeleteArgs>(args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistUpdateArgs>(args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistDeleteManyArgs>(args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistUpdateManyArgs>(args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists and returns the data updated in the database.
     * @param {WishlistUpdateManyAndReturnArgs} args - Arguments to update many Wishlists.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wishlists and only return the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WishlistUpdateManyAndReturnArgs>(args: SelectSubset<T, WishlistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
     */
    upsert<T extends WishlistUpsertArgs>(args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): Prisma.PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wishlist model
   */
  readonly fields: WishlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    WishlistItem<T extends Wishlist$WishlistItemArgs<ExtArgs> = {}>(args?: Subset<T, Wishlist$WishlistItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wishlist model
   */
  interface WishlistFieldRefs {
    readonly id: FieldRef<"Wishlist", 'String'>
    readonly userId: FieldRef<"Wishlist", 'String'>
    readonly createdAt: FieldRef<"Wishlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Wishlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wishlist findUnique
   */
  export type WishlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findFirst
   */
  export type WishlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
  }

  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wishlist createManyAndReturn
   */
  export type WishlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput
    /**
     * Limit how many Wishlists to update.
     */
    limit?: number
  }

  /**
   * Wishlist updateManyAndReturn
   */
  export type WishlistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput
    /**
     * Limit how many Wishlists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
  }

  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput
    /**
     * Limit how many Wishlists to delete.
     */
    limit?: number
  }

  /**
   * Wishlist.WishlistItem
   */
  export type Wishlist$WishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * Wishlist without action
   */
  export type WishlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
  }


  /**
   * Model WishlistItem
   */

  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null
    _avg: WishlistItemAvgAggregateOutputType | null
    _sum: WishlistItemSumAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  export type WishlistItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type WishlistItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type WishlistItemMinAggregateOutputType = {
    id: string | null
    wishlistId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistItemMaxAggregateOutputType = {
    id: string | null
    wishlistId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistItemCountAggregateOutputType = {
    id: number
    wishlistId: number
    productId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WishlistItemAvgAggregateInputType = {
    quantity?: true
  }

  export type WishlistItemSumAggregateInputType = {
    quantity?: true
  }

  export type WishlistItemMinAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistItemMaxAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistItemCountAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistItems
    **/
    _count?: true | WishlistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistItemMaxAggregateInputType
  }

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>
  }




  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithAggregationInput | WishlistItemOrderByWithAggregationInput[]
    by: WishlistItemScalarFieldEnum[] | WishlistItemScalarFieldEnum
    having?: WishlistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistItemCountAggregateInputType | true
    _avg?: WishlistItemAvgAggregateInputType
    _sum?: WishlistItemSumAggregateInputType
    _min?: WishlistItemMinAggregateInputType
    _max?: WishlistItemMaxAggregateInputType
  }

  export type WishlistItemGroupByOutputType = {
    id: string
    wishlistId: string
    productId: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: WishlistItemCountAggregateOutputType | null
    _avg: WishlistItemAvgAggregateOutputType | null
    _sum: WishlistItemSumAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
        }
      >
    >


  export type WishlistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectScalar = {
    id?: boolean
    wishlistId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WishlistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wishlistId" | "productId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["wishlistItem"]>
  export type WishlistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlist?: boolean | WishlistDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $WishlistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistItem"
    objects: {
      wishlist: Prisma.$WishlistPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wishlistId: string
      productId: string
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wishlistItem"]>
    composites: {}
  }

  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemDefaultArgs> = $Result.GetResult<Prisma.$WishlistItemPayload, S>

  type WishlistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistItemCountAggregateInputType | true
    }

  export interface WishlistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistItem'], meta: { name: 'WishlistItem' } }
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistItemFindUniqueArgs>(args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WishlistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistItemFindFirstArgs>(args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     * 
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistItemFindManyArgs>(args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     * 
     */
    create<T extends WishlistItemCreateArgs>(args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WishlistItems.
     * @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistItemCreateManyArgs>(args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishlistItems and returns the data saved in the database.
     * @param {WishlistItemCreateManyAndReturnArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     * 
     */
    delete<T extends WishlistItemDeleteArgs>(args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistItemUpdateArgs>(args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistItemDeleteManyArgs>(args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistItemUpdateManyArgs>(args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems and returns the data updated in the database.
     * @param {WishlistItemUpdateManyAndReturnArgs} args - Arguments to update many WishlistItems.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WishlistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, WishlistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
     */
    upsert<T extends WishlistItemUpsertArgs>(args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
    **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistItemAggregateArgs>(args: Subset<T, WishlistItemAggregateArgs>): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs['orderBy'] }
        : { orderBy?: WishlistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishlistItem model
   */
  readonly fields: WishlistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wishlist<T extends WishlistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WishlistDefaultArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishlistItem model
   */
  interface WishlistItemFieldRefs {
    readonly id: FieldRef<"WishlistItem", 'String'>
    readonly wishlistId: FieldRef<"WishlistItem", 'String'>
    readonly productId: FieldRef<"WishlistItem", 'String'>
    readonly quantity: FieldRef<"WishlistItem", 'Int'>
    readonly createdAt: FieldRef<"WishlistItem", 'DateTime'>
    readonly updatedAt: FieldRef<"WishlistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WishlistItem findUnique
   */
  export type WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findFirst
   */
  export type WishlistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
  }

  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishlistItem createManyAndReturn
   */
  export type WishlistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
  }

  /**
   * WishlistItem updateManyAndReturn
   */
  export type WishlistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
  }

  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to delete.
     */
    limit?: number
  }

  /**
   * WishlistItem without action
   */
  export type WishlistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type BillSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalAmount: Decimal | null
    status: $Enums.BillStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalAmount: Decimal | null
    status: $Enums.BillStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    userId: number
    totalAmount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    totalAmount?: true
  }

  export type BillSumAggregateInputType = {
    totalAmount?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: string
    userId: string
    totalAmount: Decimal
    status: $Enums.BillStatus
    createdAt: Date
    updatedAt: Date
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    BillItem?: boolean | Bill$BillItemArgs<ExtArgs>
    Transaction?: boolean | Bill$TransactionArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectScalar = {
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalAmount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["bill"]>
  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    BillItem?: boolean | Bill$BillItemArgs<ExtArgs>
    Transaction?: boolean | Bill$TransactionArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      BillItem: Prisma.$BillItemPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalAmount: Prisma.Decimal
      status: $Enums.BillStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillCreateManyAndReturnArgs>(args?: SelectSubset<T, BillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills and returns the data updated in the database.
     * @param {BillUpdateManyAndReturnArgs} args - Arguments to update many Bills.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillUpdateManyAndReturnArgs>(args: SelectSubset<T, BillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    BillItem<T extends Bill$BillItemArgs<ExtArgs> = {}>(args?: Subset<T, Bill$BillItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Bill$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Bill$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'String'>
    readonly userId: FieldRef<"Bill", 'String'>
    readonly totalAmount: FieldRef<"Bill", 'Decimal'>
    readonly status: FieldRef<"Bill", 'BillStatus'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
    readonly updatedAt: FieldRef<"Bill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill createManyAndReturn
   */
  export type BillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
  }

  /**
   * Bill updateManyAndReturn
   */
  export type BillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to delete.
     */
    limit?: number
  }

  /**
   * Bill.BillItem
   */
  export type Bill$BillItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    where?: BillItemWhereInput
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    cursor?: BillItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * Bill.Transaction
   */
  export type Bill$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model BillItem
   */

  export type AggregateBillItem = {
    _count: BillItemCountAggregateOutputType | null
    _avg: BillItemAvgAggregateOutputType | null
    _sum: BillItemSumAggregateOutputType | null
    _min: BillItemMinAggregateOutputType | null
    _max: BillItemMaxAggregateOutputType | null
  }

  export type BillItemAvgAggregateOutputType = {
    quantity: number | null
    priceAtPurchase: Decimal | null
  }

  export type BillItemSumAggregateOutputType = {
    quantity: number | null
    priceAtPurchase: Decimal | null
  }

  export type BillItemMinAggregateOutputType = {
    id: string | null
    billId: string | null
    productId: string | null
    quantity: number | null
    priceAtPurchase: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillItemMaxAggregateOutputType = {
    id: string | null
    billId: string | null
    productId: string | null
    quantity: number | null
    priceAtPurchase: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillItemCountAggregateOutputType = {
    id: number
    billId: number
    productId: number
    quantity: number
    priceAtPurchase: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillItemAvgAggregateInputType = {
    quantity?: true
    priceAtPurchase?: true
  }

  export type BillItemSumAggregateInputType = {
    quantity?: true
    priceAtPurchase?: true
  }

  export type BillItemMinAggregateInputType = {
    id?: true
    billId?: true
    productId?: true
    quantity?: true
    priceAtPurchase?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillItemMaxAggregateInputType = {
    id?: true
    billId?: true
    productId?: true
    quantity?: true
    priceAtPurchase?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillItemCountAggregateInputType = {
    id?: true
    billId?: true
    productId?: true
    quantity?: true
    priceAtPurchase?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillItem to aggregate.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillItems
    **/
    _count?: true | BillItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillItemMaxAggregateInputType
  }

  export type GetBillItemAggregateType<T extends BillItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBillItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillItem[P]>
      : GetScalarType<T[P], AggregateBillItem[P]>
  }




  export type BillItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillItemWhereInput
    orderBy?: BillItemOrderByWithAggregationInput | BillItemOrderByWithAggregationInput[]
    by: BillItemScalarFieldEnum[] | BillItemScalarFieldEnum
    having?: BillItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillItemCountAggregateInputType | true
    _avg?: BillItemAvgAggregateInputType
    _sum?: BillItemSumAggregateInputType
    _min?: BillItemMinAggregateInputType
    _max?: BillItemMaxAggregateInputType
  }

  export type BillItemGroupByOutputType = {
    id: string
    billId: string
    productId: string
    quantity: number
    priceAtPurchase: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BillItemCountAggregateOutputType | null
    _avg: BillItemAvgAggregateOutputType | null
    _sum: BillItemSumAggregateOutputType | null
    _min: BillItemMinAggregateOutputType | null
    _max: BillItemMaxAggregateOutputType | null
  }

  type GetBillItemGroupByPayload<T extends BillItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillItemGroupByOutputType[P]>
            : GetScalarType<T[P], BillItemGroupByOutputType[P]>
        }
      >
    >


  export type BillItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    productId?: boolean
    quantity?: boolean
    priceAtPurchase?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billItem"]>

  export type BillItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    productId?: boolean
    quantity?: boolean
    priceAtPurchase?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billItem"]>

  export type BillItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    productId?: boolean
    quantity?: boolean
    priceAtPurchase?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billItem"]>

  export type BillItemSelectScalar = {
    id?: boolean
    billId?: boolean
    productId?: boolean
    quantity?: boolean
    priceAtPurchase?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "productId" | "quantity" | "priceAtPurchase" | "createdAt" | "updatedAt", ExtArgs["result"]["billItem"]>
  export type BillItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type BillItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type BillItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $BillItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillItem"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billId: string
      productId: string
      quantity: number
      priceAtPurchase: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billItem"]>
    composites: {}
  }

  type BillItemGetPayload<S extends boolean | null | undefined | BillItemDefaultArgs> = $Result.GetResult<Prisma.$BillItemPayload, S>

  type BillItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillItemCountAggregateInputType | true
    }

  export interface BillItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillItem'], meta: { name: 'BillItem' } }
    /**
     * Find zero or one BillItem that matches the filter.
     * @param {BillItemFindUniqueArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillItemFindUniqueArgs>(args: SelectSubset<T, BillItemFindUniqueArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillItemFindUniqueOrThrowArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BillItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemFindFirstArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillItemFindFirstArgs>(args?: SelectSubset<T, BillItemFindFirstArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemFindFirstOrThrowArgs} args - Arguments to find a BillItem
     * @example
     * // Get one BillItem
     * const billItem = await prisma.billItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BillItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillItems
     * const billItems = await prisma.billItem.findMany()
     * 
     * // Get first 10 BillItems
     * const billItems = await prisma.billItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billItemWithIdOnly = await prisma.billItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillItemFindManyArgs>(args?: SelectSubset<T, BillItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillItem.
     * @param {BillItemCreateArgs} args - Arguments to create a BillItem.
     * @example
     * // Create one BillItem
     * const BillItem = await prisma.billItem.create({
     *   data: {
     *     // ... data to create a BillItem
     *   }
     * })
     * 
     */
    create<T extends BillItemCreateArgs>(args: SelectSubset<T, BillItemCreateArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillItems.
     * @param {BillItemCreateManyArgs} args - Arguments to create many BillItems.
     * @example
     * // Create many BillItems
     * const billItem = await prisma.billItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillItemCreateManyArgs>(args?: SelectSubset<T, BillItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillItems and returns the data saved in the database.
     * @param {BillItemCreateManyAndReturnArgs} args - Arguments to create many BillItems.
     * @example
     * // Create many BillItems
     * const billItem = await prisma.billItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillItems and only return the `id`
     * const billItemWithIdOnly = await prisma.billItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillItemCreateManyAndReturnArgs>(args?: SelectSubset<T, BillItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillItem.
     * @param {BillItemDeleteArgs} args - Arguments to delete one BillItem.
     * @example
     * // Delete one BillItem
     * const BillItem = await prisma.billItem.delete({
     *   where: {
     *     // ... filter to delete one BillItem
     *   }
     * })
     * 
     */
    delete<T extends BillItemDeleteArgs>(args: SelectSubset<T, BillItemDeleteArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillItem.
     * @param {BillItemUpdateArgs} args - Arguments to update one BillItem.
     * @example
     * // Update one BillItem
     * const billItem = await prisma.billItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillItemUpdateArgs>(args: SelectSubset<T, BillItemUpdateArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillItems.
     * @param {BillItemDeleteManyArgs} args - Arguments to filter BillItems to delete.
     * @example
     * // Delete a few BillItems
     * const { count } = await prisma.billItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillItemDeleteManyArgs>(args?: SelectSubset<T, BillItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillItems
     * const billItem = await prisma.billItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillItemUpdateManyArgs>(args: SelectSubset<T, BillItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillItems and returns the data updated in the database.
     * @param {BillItemUpdateManyAndReturnArgs} args - Arguments to update many BillItems.
     * @example
     * // Update many BillItems
     * const billItem = await prisma.billItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillItems and only return the `id`
     * const billItemWithIdOnly = await prisma.billItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillItemUpdateManyAndReturnArgs>(args: SelectSubset<T, BillItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillItem.
     * @param {BillItemUpsertArgs} args - Arguments to update or create a BillItem.
     * @example
     * // Update or create a BillItem
     * const billItem = await prisma.billItem.upsert({
     *   create: {
     *     // ... data to create a BillItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillItem we want to update
     *   }
     * })
     */
    upsert<T extends BillItemUpsertArgs>(args: SelectSubset<T, BillItemUpsertArgs<ExtArgs>>): Prisma__BillItemClient<$Result.GetResult<Prisma.$BillItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemCountArgs} args - Arguments to filter BillItems to count.
     * @example
     * // Count the number of BillItems
     * const count = await prisma.billItem.count({
     *   where: {
     *     // ... the filter for the BillItems we want to count
     *   }
     * })
    **/
    count<T extends BillItemCountArgs>(
      args?: Subset<T, BillItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillItemAggregateArgs>(args: Subset<T, BillItemAggregateArgs>): Prisma.PrismaPromise<GetBillItemAggregateType<T>>

    /**
     * Group by BillItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillItemGroupByArgs['orderBy'] }
        : { orderBy?: BillItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillItem model
   */
  readonly fields: BillItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillItem model
   */
  interface BillItemFieldRefs {
    readonly id: FieldRef<"BillItem", 'String'>
    readonly billId: FieldRef<"BillItem", 'String'>
    readonly productId: FieldRef<"BillItem", 'String'>
    readonly quantity: FieldRef<"BillItem", 'Int'>
    readonly priceAtPurchase: FieldRef<"BillItem", 'Decimal'>
    readonly createdAt: FieldRef<"BillItem", 'DateTime'>
    readonly updatedAt: FieldRef<"BillItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillItem findUnique
   */
  export type BillItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem findUniqueOrThrow
   */
  export type BillItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem findFirst
   */
  export type BillItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillItems.
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillItems.
     */
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * BillItem findFirstOrThrow
   */
  export type BillItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItem to fetch.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillItems.
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillItems.
     */
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * BillItem findMany
   */
  export type BillItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter, which BillItems to fetch.
     */
    where?: BillItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillItems to fetch.
     */
    orderBy?: BillItemOrderByWithRelationInput | BillItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillItems.
     */
    cursor?: BillItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillItems.
     */
    skip?: number
    distinct?: BillItemScalarFieldEnum | BillItemScalarFieldEnum[]
  }

  /**
   * BillItem create
   */
  export type BillItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BillItem.
     */
    data: XOR<BillItemCreateInput, BillItemUncheckedCreateInput>
  }

  /**
   * BillItem createMany
   */
  export type BillItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillItems.
     */
    data: BillItemCreateManyInput | BillItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillItem createManyAndReturn
   */
  export type BillItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * The data used to create many BillItems.
     */
    data: BillItemCreateManyInput | BillItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillItem update
   */
  export type BillItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BillItem.
     */
    data: XOR<BillItemUpdateInput, BillItemUncheckedUpdateInput>
    /**
     * Choose, which BillItem to update.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem updateMany
   */
  export type BillItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillItems.
     */
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyInput>
    /**
     * Filter which BillItems to update
     */
    where?: BillItemWhereInput
    /**
     * Limit how many BillItems to update.
     */
    limit?: number
  }

  /**
   * BillItem updateManyAndReturn
   */
  export type BillItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * The data used to update BillItems.
     */
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyInput>
    /**
     * Filter which BillItems to update
     */
    where?: BillItemWhereInput
    /**
     * Limit how many BillItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillItem upsert
   */
  export type BillItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BillItem to update in case it exists.
     */
    where: BillItemWhereUniqueInput
    /**
     * In case the BillItem found by the `where` argument doesn't exist, create a new BillItem with this data.
     */
    create: XOR<BillItemCreateInput, BillItemUncheckedCreateInput>
    /**
     * In case the BillItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillItemUpdateInput, BillItemUncheckedUpdateInput>
  }

  /**
   * BillItem delete
   */
  export type BillItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
    /**
     * Filter which BillItem to delete.
     */
    where: BillItemWhereUniqueInput
  }

  /**
   * BillItem deleteMany
   */
  export type BillItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillItems to delete
     */
    where?: BillItemWhereInput
    /**
     * Limit how many BillItems to delete.
     */
    limit?: number
  }

  /**
   * BillItem without action
   */
  export type BillItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillItem
     */
    select?: BillItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillItem
     */
    omit?: BillItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillItemInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    billId: string | null
    paymentMethod: $Enums.TransactionMethod | null
    amount: Decimal | null
    status: $Enums.TransactionStatus | null
    transactionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    billId: string | null
    paymentMethod: $Enums.TransactionMethod | null
    amount: Decimal | null
    status: $Enums.TransactionStatus | null
    transactionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    billId: number
    paymentMethod: number
    amount: number
    status: number
    transactionDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    billId?: true
    paymentMethod?: true
    amount?: true
    status?: true
    transactionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    billId?: true
    paymentMethod?: true
    amount?: true
    status?: true
    transactionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    billId?: true
    paymentMethod?: true
    amount?: true
    status?: true
    transactionDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    billId: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal
    status: $Enums.TransactionStatus
    transactionDate: Date
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    billId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "paymentMethod" | "amount" | "status" | "transactionDate" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billId: string
      paymentMethod: $Enums.TransactionMethod
      amount: Prisma.Decimal
      status: $Enums.TransactionStatus
      transactionDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly billId: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'TransactionMethod'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly transactionDate: FieldRef<"Transaction", 'DateTime'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    minimumOrderAmount: Decimal | null
    usageLimit: number | null
  }

  export type CouponSumAggregateOutputType = {
    minimumOrderAmount: Decimal | null
    usageLimit: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    discountType: string | null
    discountValue: string | null
    validFrom: Date | null
    validUntil: Date | null
    minimumOrderAmount: Decimal | null
    usageLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    discountType: string | null
    discountValue: string | null
    validFrom: Date | null
    validUntil: Date | null
    minimumOrderAmount: Decimal | null
    usageLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    discountType: number
    discountValue: number
    validFrom: number
    validUntil: number
    minimumOrderAmount: number
    usageLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    minimumOrderAmount?: true
    usageLimit?: true
  }

  export type CouponSumAggregateInputType = {
    minimumOrderAmount?: true
    usageLimit?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    discountType?: true
    discountValue?: true
    validFrom?: true
    validUntil?: true
    minimumOrderAmount?: true
    usageLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    discountType?: true
    discountValue?: true
    validFrom?: true
    validUntil?: true
    minimumOrderAmount?: true
    usageLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    discountType?: true
    discountValue?: true
    validFrom?: true
    validUntil?: true
    minimumOrderAmount?: true
    usageLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    discountType: string
    discountValue: string
    validFrom: Date
    validUntil: Date
    minimumOrderAmount: Decimal
    usageLimit: number
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    minimumOrderAmount?: boolean
    usageLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UserCoupon?: boolean | Coupon$UserCouponArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    minimumOrderAmount?: boolean
    usageLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    minimumOrderAmount?: boolean
    usageLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    minimumOrderAmount?: boolean
    usageLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "discountType" | "discountValue" | "validFrom" | "validUntil" | "minimumOrderAmount" | "usageLimit" | "createdAt" | "updatedAt", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserCoupon?: boolean | Coupon$UserCouponArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      UserCoupon: Prisma.$UserCouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      discountType: string
      discountValue: string
      validFrom: Date
      validUntil: Date
      minimumOrderAmount: Prisma.Decimal
      usageLimit: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserCoupon<T extends Coupon$UserCouponArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$UserCouponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly discountType: FieldRef<"Coupon", 'String'>
    readonly discountValue: FieldRef<"Coupon", 'String'>
    readonly validFrom: FieldRef<"Coupon", 'DateTime'>
    readonly validUntil: FieldRef<"Coupon", 'DateTime'>
    readonly minimumOrderAmount: FieldRef<"Coupon", 'Decimal'>
    readonly usageLimit: FieldRef<"Coupon", 'Int'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon.UserCoupon
   */
  export type Coupon$UserCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    where?: UserCouponWhereInput
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    cursor?: UserCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model UserCoupon
   */

  export type AggregateUserCoupon = {
    _count: UserCouponCountAggregateOutputType | null
    _avg: UserCouponAvgAggregateOutputType | null
    _sum: UserCouponSumAggregateOutputType | null
    _min: UserCouponMinAggregateOutputType | null
    _max: UserCouponMaxAggregateOutputType | null
  }

  export type UserCouponAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type UserCouponSumAggregateOutputType = {
    usageCount: number | null
  }

  export type UserCouponMinAggregateOutputType = {
    id: string | null
    couponId: string | null
    userId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCouponMaxAggregateOutputType = {
    id: string | null
    couponId: string | null
    userId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCouponCountAggregateOutputType = {
    id: number
    couponId: number
    userId: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserCouponAvgAggregateInputType = {
    usageCount?: true
  }

  export type UserCouponSumAggregateInputType = {
    usageCount?: true
  }

  export type UserCouponMinAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCouponMaxAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCouponCountAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserCouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCoupon to aggregate.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCoupons
    **/
    _count?: true | UserCouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCouponMaxAggregateInputType
  }

  export type GetUserCouponAggregateType<T extends UserCouponAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCoupon[P]>
      : GetScalarType<T[P], AggregateUserCoupon[P]>
  }




  export type UserCouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCouponWhereInput
    orderBy?: UserCouponOrderByWithAggregationInput | UserCouponOrderByWithAggregationInput[]
    by: UserCouponScalarFieldEnum[] | UserCouponScalarFieldEnum
    having?: UserCouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCouponCountAggregateInputType | true
    _avg?: UserCouponAvgAggregateInputType
    _sum?: UserCouponSumAggregateInputType
    _min?: UserCouponMinAggregateInputType
    _max?: UserCouponMaxAggregateInputType
  }

  export type UserCouponGroupByOutputType = {
    id: string
    couponId: string
    userId: string
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: UserCouponCountAggregateOutputType | null
    _avg: UserCouponAvgAggregateOutputType | null
    _sum: UserCouponSumAggregateOutputType | null
    _min: UserCouponMinAggregateOutputType | null
    _max: UserCouponMaxAggregateOutputType | null
  }

  type GetUserCouponGroupByPayload<T extends UserCouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCouponGroupByOutputType[P]>
            : GetScalarType<T[P], UserCouponGroupByOutputType[P]>
        }
      >
    >


  export type UserCouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCoupon"]>

  export type UserCouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCoupon"]>

  export type UserCouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCoupon"]>

  export type UserCouponSelectScalar = {
    id?: boolean
    couponId?: boolean
    userId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserCouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "couponId" | "userId" | "usageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["userCoupon"]>
  export type UserCouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserCouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCoupon"
    objects: {
      coupon: Prisma.$CouponPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      couponId: string
      userId: string
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userCoupon"]>
    composites: {}
  }

  type UserCouponGetPayload<S extends boolean | null | undefined | UserCouponDefaultArgs> = $Result.GetResult<Prisma.$UserCouponPayload, S>

  type UserCouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCouponCountAggregateInputType | true
    }

  export interface UserCouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCoupon'], meta: { name: 'UserCoupon' } }
    /**
     * Find zero or one UserCoupon that matches the filter.
     * @param {UserCouponFindUniqueArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCouponFindUniqueArgs>(args: SelectSubset<T, UserCouponFindUniqueArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCoupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCouponFindUniqueOrThrowArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCouponFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindFirstArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCouponFindFirstArgs>(args?: SelectSubset<T, UserCouponFindFirstArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCoupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindFirstOrThrowArgs} args - Arguments to find a UserCoupon
     * @example
     * // Get one UserCoupon
     * const userCoupon = await prisma.userCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCouponFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCoupons
     * const userCoupons = await prisma.userCoupon.findMany()
     * 
     * // Get first 10 UserCoupons
     * const userCoupons = await prisma.userCoupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCouponWithIdOnly = await prisma.userCoupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCouponFindManyArgs>(args?: SelectSubset<T, UserCouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCoupon.
     * @param {UserCouponCreateArgs} args - Arguments to create a UserCoupon.
     * @example
     * // Create one UserCoupon
     * const UserCoupon = await prisma.userCoupon.create({
     *   data: {
     *     // ... data to create a UserCoupon
     *   }
     * })
     * 
     */
    create<T extends UserCouponCreateArgs>(args: SelectSubset<T, UserCouponCreateArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCoupons.
     * @param {UserCouponCreateManyArgs} args - Arguments to create many UserCoupons.
     * @example
     * // Create many UserCoupons
     * const userCoupon = await prisma.userCoupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCouponCreateManyArgs>(args?: SelectSubset<T, UserCouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCoupons and returns the data saved in the database.
     * @param {UserCouponCreateManyAndReturnArgs} args - Arguments to create many UserCoupons.
     * @example
     * // Create many UserCoupons
     * const userCoupon = await prisma.userCoupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCoupons and only return the `id`
     * const userCouponWithIdOnly = await prisma.userCoupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCouponCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCoupon.
     * @param {UserCouponDeleteArgs} args - Arguments to delete one UserCoupon.
     * @example
     * // Delete one UserCoupon
     * const UserCoupon = await prisma.userCoupon.delete({
     *   where: {
     *     // ... filter to delete one UserCoupon
     *   }
     * })
     * 
     */
    delete<T extends UserCouponDeleteArgs>(args: SelectSubset<T, UserCouponDeleteArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCoupon.
     * @param {UserCouponUpdateArgs} args - Arguments to update one UserCoupon.
     * @example
     * // Update one UserCoupon
     * const userCoupon = await prisma.userCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCouponUpdateArgs>(args: SelectSubset<T, UserCouponUpdateArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCoupons.
     * @param {UserCouponDeleteManyArgs} args - Arguments to filter UserCoupons to delete.
     * @example
     * // Delete a few UserCoupons
     * const { count } = await prisma.userCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCouponDeleteManyArgs>(args?: SelectSubset<T, UserCouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCoupons
     * const userCoupon = await prisma.userCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCouponUpdateManyArgs>(args: SelectSubset<T, UserCouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCoupons and returns the data updated in the database.
     * @param {UserCouponUpdateManyAndReturnArgs} args - Arguments to update many UserCoupons.
     * @example
     * // Update many UserCoupons
     * const userCoupon = await prisma.userCoupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCoupons and only return the `id`
     * const userCouponWithIdOnly = await prisma.userCoupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCouponUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCoupon.
     * @param {UserCouponUpsertArgs} args - Arguments to update or create a UserCoupon.
     * @example
     * // Update or create a UserCoupon
     * const userCoupon = await prisma.userCoupon.upsert({
     *   create: {
     *     // ... data to create a UserCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCoupon we want to update
     *   }
     * })
     */
    upsert<T extends UserCouponUpsertArgs>(args: SelectSubset<T, UserCouponUpsertArgs<ExtArgs>>): Prisma__UserCouponClient<$Result.GetResult<Prisma.$UserCouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponCountArgs} args - Arguments to filter UserCoupons to count.
     * @example
     * // Count the number of UserCoupons
     * const count = await prisma.userCoupon.count({
     *   where: {
     *     // ... the filter for the UserCoupons we want to count
     *   }
     * })
    **/
    count<T extends UserCouponCountArgs>(
      args?: Subset<T, UserCouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCouponAggregateArgs>(args: Subset<T, UserCouponAggregateArgs>): Prisma.PrismaPromise<GetUserCouponAggregateType<T>>

    /**
     * Group by UserCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCouponGroupByArgs['orderBy'] }
        : { orderBy?: UserCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCoupon model
   */
  readonly fields: UserCouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CouponDefaultArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCoupon model
   */
  interface UserCouponFieldRefs {
    readonly id: FieldRef<"UserCoupon", 'String'>
    readonly couponId: FieldRef<"UserCoupon", 'String'>
    readonly userId: FieldRef<"UserCoupon", 'String'>
    readonly usageCount: FieldRef<"UserCoupon", 'Int'>
    readonly createdAt: FieldRef<"UserCoupon", 'DateTime'>
    readonly updatedAt: FieldRef<"UserCoupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCoupon findUnique
   */
  export type UserCouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon findUniqueOrThrow
   */
  export type UserCouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon findFirst
   */
  export type UserCouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCoupons.
     */
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * UserCoupon findFirstOrThrow
   */
  export type UserCouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupon to fetch.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCoupons.
     */
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * UserCoupon findMany
   */
  export type UserCouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter, which UserCoupons to fetch.
     */
    where?: UserCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCoupons to fetch.
     */
    orderBy?: UserCouponOrderByWithRelationInput | UserCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCoupons.
     */
    cursor?: UserCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCoupons.
     */
    skip?: number
    distinct?: UserCouponScalarFieldEnum | UserCouponScalarFieldEnum[]
  }

  /**
   * UserCoupon create
   */
  export type UserCouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCoupon.
     */
    data: XOR<UserCouponCreateInput, UserCouponUncheckedCreateInput>
  }

  /**
   * UserCoupon createMany
   */
  export type UserCouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCoupons.
     */
    data: UserCouponCreateManyInput | UserCouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCoupon createManyAndReturn
   */
  export type UserCouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * The data used to create many UserCoupons.
     */
    data: UserCouponCreateManyInput | UserCouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCoupon update
   */
  export type UserCouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCoupon.
     */
    data: XOR<UserCouponUpdateInput, UserCouponUncheckedUpdateInput>
    /**
     * Choose, which UserCoupon to update.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon updateMany
   */
  export type UserCouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCoupons.
     */
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyInput>
    /**
     * Filter which UserCoupons to update
     */
    where?: UserCouponWhereInput
    /**
     * Limit how many UserCoupons to update.
     */
    limit?: number
  }

  /**
   * UserCoupon updateManyAndReturn
   */
  export type UserCouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * The data used to update UserCoupons.
     */
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyInput>
    /**
     * Filter which UserCoupons to update
     */
    where?: UserCouponWhereInput
    /**
     * Limit how many UserCoupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCoupon upsert
   */
  export type UserCouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCoupon to update in case it exists.
     */
    where: UserCouponWhereUniqueInput
    /**
     * In case the UserCoupon found by the `where` argument doesn't exist, create a new UserCoupon with this data.
     */
    create: XOR<UserCouponCreateInput, UserCouponUncheckedCreateInput>
    /**
     * In case the UserCoupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCouponUpdateInput, UserCouponUncheckedUpdateInput>
  }

  /**
   * UserCoupon delete
   */
  export type UserCouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
    /**
     * Filter which UserCoupon to delete.
     */
    where: UserCouponWhereUniqueInput
  }

  /**
   * UserCoupon deleteMany
   */
  export type UserCouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCoupons to delete
     */
    where?: UserCouponWhereInput
    /**
     * Limit how many UserCoupons to delete.
     */
    limit?: number
  }

  /**
   * UserCoupon without action
   */
  export type UserCouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCoupon
     */
    select?: UserCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCoupon
     */
    omit?: UserCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCouponInclude<ExtArgs> | null
  }


  /**
   * Model UserBuild
   */

  export type AggregateUserBuild = {
    _count: UserBuildCountAggregateOutputType | null
    _min: UserBuildMinAggregateOutputType | null
    _max: UserBuildMaxAggregateOutputType | null
  }

  export type UserBuildMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBuildMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBuildCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBuildMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBuildMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBuildCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBuild to aggregate.
     */
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     */
    orderBy?: UserBuildOrderByWithRelationInput | UserBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBuilds
    **/
    _count?: true | UserBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBuildMaxAggregateInputType
  }

  export type GetUserBuildAggregateType<T extends UserBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBuild[P]>
      : GetScalarType<T[P], AggregateUserBuild[P]>
  }




  export type UserBuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBuildWhereInput
    orderBy?: UserBuildOrderByWithAggregationInput | UserBuildOrderByWithAggregationInput[]
    by: UserBuildScalarFieldEnum[] | UserBuildScalarFieldEnum
    having?: UserBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBuildCountAggregateInputType | true
    _min?: UserBuildMinAggregateInputType
    _max?: UserBuildMaxAggregateInputType
  }

  export type UserBuildGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: UserBuildCountAggregateOutputType | null
    _min: UserBuildMinAggregateOutputType | null
    _max: UserBuildMaxAggregateOutputType | null
  }

  type GetUserBuildGroupByPayload<T extends UserBuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBuildGroupByOutputType[P]>
            : GetScalarType<T[P], UserBuildGroupByOutputType[P]>
        }
      >
    >


  export type UserBuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    UserBuildComponent?: boolean | UserBuild$UserBuildComponentArgs<ExtArgs>
    _count?: boolean | UserBuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBuild"]>

  export type UserBuildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBuild"]>

  export type UserBuildSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBuild"]>

  export type UserBuildSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserBuildOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["userBuild"]>
  export type UserBuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    UserBuildComponent?: boolean | UserBuild$UserBuildComponentArgs<ExtArgs>
    _count?: boolean | UserBuildCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserBuildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBuildIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBuild"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      UserBuildComponent: Prisma.$UserBuildComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userBuild"]>
    composites: {}
  }

  type UserBuildGetPayload<S extends boolean | null | undefined | UserBuildDefaultArgs> = $Result.GetResult<Prisma.$UserBuildPayload, S>

  type UserBuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBuildFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBuildCountAggregateInputType | true
    }

  export interface UserBuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBuild'], meta: { name: 'UserBuild' } }
    /**
     * Find zero or one UserBuild that matches the filter.
     * @param {UserBuildFindUniqueArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBuildFindUniqueArgs>(args: SelectSubset<T, UserBuildFindUniqueArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBuild that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBuildFindUniqueOrThrowArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBuildFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBuildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildFindFirstArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBuildFindFirstArgs>(args?: SelectSubset<T, UserBuildFindFirstArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBuild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildFindFirstOrThrowArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBuildFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBuildFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBuilds
     * const userBuilds = await prisma.userBuild.findMany()
     * 
     * // Get first 10 UserBuilds
     * const userBuilds = await prisma.userBuild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBuildWithIdOnly = await prisma.userBuild.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBuildFindManyArgs>(args?: SelectSubset<T, UserBuildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBuild.
     * @param {UserBuildCreateArgs} args - Arguments to create a UserBuild.
     * @example
     * // Create one UserBuild
     * const UserBuild = await prisma.userBuild.create({
     *   data: {
     *     // ... data to create a UserBuild
     *   }
     * })
     * 
     */
    create<T extends UserBuildCreateArgs>(args: SelectSubset<T, UserBuildCreateArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBuilds.
     * @param {UserBuildCreateManyArgs} args - Arguments to create many UserBuilds.
     * @example
     * // Create many UserBuilds
     * const userBuild = await prisma.userBuild.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBuildCreateManyArgs>(args?: SelectSubset<T, UserBuildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBuilds and returns the data saved in the database.
     * @param {UserBuildCreateManyAndReturnArgs} args - Arguments to create many UserBuilds.
     * @example
     * // Create many UserBuilds
     * const userBuild = await prisma.userBuild.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBuilds and only return the `id`
     * const userBuildWithIdOnly = await prisma.userBuild.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBuildCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBuildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBuild.
     * @param {UserBuildDeleteArgs} args - Arguments to delete one UserBuild.
     * @example
     * // Delete one UserBuild
     * const UserBuild = await prisma.userBuild.delete({
     *   where: {
     *     // ... filter to delete one UserBuild
     *   }
     * })
     * 
     */
    delete<T extends UserBuildDeleteArgs>(args: SelectSubset<T, UserBuildDeleteArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBuild.
     * @param {UserBuildUpdateArgs} args - Arguments to update one UserBuild.
     * @example
     * // Update one UserBuild
     * const userBuild = await prisma.userBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBuildUpdateArgs>(args: SelectSubset<T, UserBuildUpdateArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBuilds.
     * @param {UserBuildDeleteManyArgs} args - Arguments to filter UserBuilds to delete.
     * @example
     * // Delete a few UserBuilds
     * const { count } = await prisma.userBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBuildDeleteManyArgs>(args?: SelectSubset<T, UserBuildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBuilds
     * const userBuild = await prisma.userBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBuildUpdateManyArgs>(args: SelectSubset<T, UserBuildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBuilds and returns the data updated in the database.
     * @param {UserBuildUpdateManyAndReturnArgs} args - Arguments to update many UserBuilds.
     * @example
     * // Update many UserBuilds
     * const userBuild = await prisma.userBuild.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBuilds and only return the `id`
     * const userBuildWithIdOnly = await prisma.userBuild.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBuildUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBuildUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBuild.
     * @param {UserBuildUpsertArgs} args - Arguments to update or create a UserBuild.
     * @example
     * // Update or create a UserBuild
     * const userBuild = await prisma.userBuild.upsert({
     *   create: {
     *     // ... data to create a UserBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBuild we want to update
     *   }
     * })
     */
    upsert<T extends UserBuildUpsertArgs>(args: SelectSubset<T, UserBuildUpsertArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildCountArgs} args - Arguments to filter UserBuilds to count.
     * @example
     * // Count the number of UserBuilds
     * const count = await prisma.userBuild.count({
     *   where: {
     *     // ... the filter for the UserBuilds we want to count
     *   }
     * })
    **/
    count<T extends UserBuildCountArgs>(
      args?: Subset<T, UserBuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBuildAggregateArgs>(args: Subset<T, UserBuildAggregateArgs>): Prisma.PrismaPromise<GetUserBuildAggregateType<T>>

    /**
     * Group by UserBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBuildGroupByArgs['orderBy'] }
        : { orderBy?: UserBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBuild model
   */
  readonly fields: UserBuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    UserBuildComponent<T extends UserBuild$UserBuildComponentArgs<ExtArgs> = {}>(args?: Subset<T, UserBuild$UserBuildComponentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBuild model
   */
  interface UserBuildFieldRefs {
    readonly id: FieldRef<"UserBuild", 'String'>
    readonly userId: FieldRef<"UserBuild", 'String'>
    readonly name: FieldRef<"UserBuild", 'String'>
    readonly description: FieldRef<"UserBuild", 'String'>
    readonly createdAt: FieldRef<"UserBuild", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBuild", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBuild findUnique
   */
  export type UserBuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * Filter, which UserBuild to fetch.
     */
    where: UserBuildWhereUniqueInput
  }

  /**
   * UserBuild findUniqueOrThrow
   */
  export type UserBuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * Filter, which UserBuild to fetch.
     */
    where: UserBuildWhereUniqueInput
  }

  /**
   * UserBuild findFirst
   */
  export type UserBuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * Filter, which UserBuild to fetch.
     */
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     */
    orderBy?: UserBuildOrderByWithRelationInput | UserBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBuilds.
     */
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBuilds.
     */
    distinct?: UserBuildScalarFieldEnum | UserBuildScalarFieldEnum[]
  }

  /**
   * UserBuild findFirstOrThrow
   */
  export type UserBuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * Filter, which UserBuild to fetch.
     */
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     */
    orderBy?: UserBuildOrderByWithRelationInput | UserBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBuilds.
     */
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBuilds.
     */
    distinct?: UserBuildScalarFieldEnum | UserBuildScalarFieldEnum[]
  }

  /**
   * UserBuild findMany
   */
  export type UserBuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * Filter, which UserBuilds to fetch.
     */
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     */
    orderBy?: UserBuildOrderByWithRelationInput | UserBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBuilds.
     */
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     */
    skip?: number
    distinct?: UserBuildScalarFieldEnum | UserBuildScalarFieldEnum[]
  }

  /**
   * UserBuild create
   */
  export type UserBuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBuild.
     */
    data: XOR<UserBuildCreateInput, UserBuildUncheckedCreateInput>
  }

  /**
   * UserBuild createMany
   */
  export type UserBuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBuilds.
     */
    data: UserBuildCreateManyInput | UserBuildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBuild createManyAndReturn
   */
  export type UserBuildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * The data used to create many UserBuilds.
     */
    data: UserBuildCreateManyInput | UserBuildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBuild update
   */
  export type UserBuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBuild.
     */
    data: XOR<UserBuildUpdateInput, UserBuildUncheckedUpdateInput>
    /**
     * Choose, which UserBuild to update.
     */
    where: UserBuildWhereUniqueInput
  }

  /**
   * UserBuild updateMany
   */
  export type UserBuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBuilds.
     */
    data: XOR<UserBuildUpdateManyMutationInput, UserBuildUncheckedUpdateManyInput>
    /**
     * Filter which UserBuilds to update
     */
    where?: UserBuildWhereInput
    /**
     * Limit how many UserBuilds to update.
     */
    limit?: number
  }

  /**
   * UserBuild updateManyAndReturn
   */
  export type UserBuildUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * The data used to update UserBuilds.
     */
    data: XOR<UserBuildUpdateManyMutationInput, UserBuildUncheckedUpdateManyInput>
    /**
     * Filter which UserBuilds to update
     */
    where?: UserBuildWhereInput
    /**
     * Limit how many UserBuilds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBuild upsert
   */
  export type UserBuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBuild to update in case it exists.
     */
    where: UserBuildWhereUniqueInput
    /**
     * In case the UserBuild found by the `where` argument doesn't exist, create a new UserBuild with this data.
     */
    create: XOR<UserBuildCreateInput, UserBuildUncheckedCreateInput>
    /**
     * In case the UserBuild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBuildUpdateInput, UserBuildUncheckedUpdateInput>
  }

  /**
   * UserBuild delete
   */
  export type UserBuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
    /**
     * Filter which UserBuild to delete.
     */
    where: UserBuildWhereUniqueInput
  }

  /**
   * UserBuild deleteMany
   */
  export type UserBuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBuilds to delete
     */
    where?: UserBuildWhereInput
    /**
     * Limit how many UserBuilds to delete.
     */
    limit?: number
  }

  /**
   * UserBuild.UserBuildComponent
   */
  export type UserBuild$UserBuildComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    where?: UserBuildComponentWhereInput
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    cursor?: UserBuildComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBuildComponentScalarFieldEnum | UserBuildComponentScalarFieldEnum[]
  }

  /**
   * UserBuild without action
   */
  export type UserBuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuild
     */
    select?: UserBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuild
     */
    omit?: UserBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildInclude<ExtArgs> | null
  }


  /**
   * Model UserBuildComponent
   */

  export type AggregateUserBuildComponent = {
    _count: UserBuildComponentCountAggregateOutputType | null
    _min: UserBuildComponentMinAggregateOutputType | null
    _max: UserBuildComponentMaxAggregateOutputType | null
  }

  export type UserBuildComponentMinAggregateOutputType = {
    id: string | null
    userBuildId: string | null
    productId: string | null
    componentTypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBuildComponentMaxAggregateOutputType = {
    id: string | null
    userBuildId: string | null
    productId: string | null
    componentTypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBuildComponentCountAggregateOutputType = {
    id: number
    userBuildId: number
    productId: number
    componentTypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBuildComponentMinAggregateInputType = {
    id?: true
    userBuildId?: true
    productId?: true
    componentTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBuildComponentMaxAggregateInputType = {
    id?: true
    userBuildId?: true
    productId?: true
    componentTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBuildComponentCountAggregateInputType = {
    id?: true
    userBuildId?: true
    productId?: true
    componentTypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBuildComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBuildComponent to aggregate.
     */
    where?: UserBuildComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuildComponents to fetch.
     */
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBuildComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuildComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuildComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBuildComponents
    **/
    _count?: true | UserBuildComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBuildComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBuildComponentMaxAggregateInputType
  }

  export type GetUserBuildComponentAggregateType<T extends UserBuildComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBuildComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBuildComponent[P]>
      : GetScalarType<T[P], AggregateUserBuildComponent[P]>
  }




  export type UserBuildComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBuildComponentWhereInput
    orderBy?: UserBuildComponentOrderByWithAggregationInput | UserBuildComponentOrderByWithAggregationInput[]
    by: UserBuildComponentScalarFieldEnum[] | UserBuildComponentScalarFieldEnum
    having?: UserBuildComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBuildComponentCountAggregateInputType | true
    _min?: UserBuildComponentMinAggregateInputType
    _max?: UserBuildComponentMaxAggregateInputType
  }

  export type UserBuildComponentGroupByOutputType = {
    id: string
    userBuildId: string
    productId: string
    componentTypeId: string
    createdAt: Date
    updatedAt: Date
    _count: UserBuildComponentCountAggregateOutputType | null
    _min: UserBuildComponentMinAggregateOutputType | null
    _max: UserBuildComponentMaxAggregateOutputType | null
  }

  type GetUserBuildComponentGroupByPayload<T extends UserBuildComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBuildComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBuildComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBuildComponentGroupByOutputType[P]>
            : GetScalarType<T[P], UserBuildComponentGroupByOutputType[P]>
        }
      >
    >


  export type UserBuildComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userBuildId?: boolean
    productId?: boolean
    componentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userBuild?: boolean | UserBuildDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    componentType?: boolean | ComponentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBuildComponent"]>

  export type UserBuildComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userBuildId?: boolean
    productId?: boolean
    componentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userBuild?: boolean | UserBuildDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    componentType?: boolean | ComponentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBuildComponent"]>

  export type UserBuildComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userBuildId?: boolean
    productId?: boolean
    componentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userBuild?: boolean | UserBuildDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    componentType?: boolean | ComponentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBuildComponent"]>

  export type UserBuildComponentSelectScalar = {
    id?: boolean
    userBuildId?: boolean
    productId?: boolean
    componentTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserBuildComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userBuildId" | "productId" | "componentTypeId" | "createdAt" | "updatedAt", ExtArgs["result"]["userBuildComponent"]>
  export type UserBuildComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBuild?: boolean | UserBuildDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    componentType?: boolean | ComponentTypeDefaultArgs<ExtArgs>
  }
  export type UserBuildComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBuild?: boolean | UserBuildDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    componentType?: boolean | ComponentTypeDefaultArgs<ExtArgs>
  }
  export type UserBuildComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBuild?: boolean | UserBuildDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    componentType?: boolean | ComponentTypeDefaultArgs<ExtArgs>
  }

  export type $UserBuildComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBuildComponent"
    objects: {
      userBuild: Prisma.$UserBuildPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      componentType: Prisma.$ComponentTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userBuildId: string
      productId: string
      componentTypeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userBuildComponent"]>
    composites: {}
  }

  type UserBuildComponentGetPayload<S extends boolean | null | undefined | UserBuildComponentDefaultArgs> = $Result.GetResult<Prisma.$UserBuildComponentPayload, S>

  type UserBuildComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBuildComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBuildComponentCountAggregateInputType | true
    }

  export interface UserBuildComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBuildComponent'], meta: { name: 'UserBuildComponent' } }
    /**
     * Find zero or one UserBuildComponent that matches the filter.
     * @param {UserBuildComponentFindUniqueArgs} args - Arguments to find a UserBuildComponent
     * @example
     * // Get one UserBuildComponent
     * const userBuildComponent = await prisma.userBuildComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBuildComponentFindUniqueArgs>(args: SelectSubset<T, UserBuildComponentFindUniqueArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBuildComponent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBuildComponentFindUniqueOrThrowArgs} args - Arguments to find a UserBuildComponent
     * @example
     * // Get one UserBuildComponent
     * const userBuildComponent = await prisma.userBuildComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBuildComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBuildComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBuildComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentFindFirstArgs} args - Arguments to find a UserBuildComponent
     * @example
     * // Get one UserBuildComponent
     * const userBuildComponent = await prisma.userBuildComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBuildComponentFindFirstArgs>(args?: SelectSubset<T, UserBuildComponentFindFirstArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBuildComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentFindFirstOrThrowArgs} args - Arguments to find a UserBuildComponent
     * @example
     * // Get one UserBuildComponent
     * const userBuildComponent = await prisma.userBuildComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBuildComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBuildComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBuildComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBuildComponents
     * const userBuildComponents = await prisma.userBuildComponent.findMany()
     * 
     * // Get first 10 UserBuildComponents
     * const userBuildComponents = await prisma.userBuildComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBuildComponentWithIdOnly = await prisma.userBuildComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBuildComponentFindManyArgs>(args?: SelectSubset<T, UserBuildComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBuildComponent.
     * @param {UserBuildComponentCreateArgs} args - Arguments to create a UserBuildComponent.
     * @example
     * // Create one UserBuildComponent
     * const UserBuildComponent = await prisma.userBuildComponent.create({
     *   data: {
     *     // ... data to create a UserBuildComponent
     *   }
     * })
     * 
     */
    create<T extends UserBuildComponentCreateArgs>(args: SelectSubset<T, UserBuildComponentCreateArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBuildComponents.
     * @param {UserBuildComponentCreateManyArgs} args - Arguments to create many UserBuildComponents.
     * @example
     * // Create many UserBuildComponents
     * const userBuildComponent = await prisma.userBuildComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBuildComponentCreateManyArgs>(args?: SelectSubset<T, UserBuildComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBuildComponents and returns the data saved in the database.
     * @param {UserBuildComponentCreateManyAndReturnArgs} args - Arguments to create many UserBuildComponents.
     * @example
     * // Create many UserBuildComponents
     * const userBuildComponent = await prisma.userBuildComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBuildComponents and only return the `id`
     * const userBuildComponentWithIdOnly = await prisma.userBuildComponent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBuildComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBuildComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBuildComponent.
     * @param {UserBuildComponentDeleteArgs} args - Arguments to delete one UserBuildComponent.
     * @example
     * // Delete one UserBuildComponent
     * const UserBuildComponent = await prisma.userBuildComponent.delete({
     *   where: {
     *     // ... filter to delete one UserBuildComponent
     *   }
     * })
     * 
     */
    delete<T extends UserBuildComponentDeleteArgs>(args: SelectSubset<T, UserBuildComponentDeleteArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBuildComponent.
     * @param {UserBuildComponentUpdateArgs} args - Arguments to update one UserBuildComponent.
     * @example
     * // Update one UserBuildComponent
     * const userBuildComponent = await prisma.userBuildComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBuildComponentUpdateArgs>(args: SelectSubset<T, UserBuildComponentUpdateArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBuildComponents.
     * @param {UserBuildComponentDeleteManyArgs} args - Arguments to filter UserBuildComponents to delete.
     * @example
     * // Delete a few UserBuildComponents
     * const { count } = await prisma.userBuildComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBuildComponentDeleteManyArgs>(args?: SelectSubset<T, UserBuildComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBuildComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBuildComponents
     * const userBuildComponent = await prisma.userBuildComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBuildComponentUpdateManyArgs>(args: SelectSubset<T, UserBuildComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBuildComponents and returns the data updated in the database.
     * @param {UserBuildComponentUpdateManyAndReturnArgs} args - Arguments to update many UserBuildComponents.
     * @example
     * // Update many UserBuildComponents
     * const userBuildComponent = await prisma.userBuildComponent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBuildComponents and only return the `id`
     * const userBuildComponentWithIdOnly = await prisma.userBuildComponent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBuildComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBuildComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBuildComponent.
     * @param {UserBuildComponentUpsertArgs} args - Arguments to update or create a UserBuildComponent.
     * @example
     * // Update or create a UserBuildComponent
     * const userBuildComponent = await prisma.userBuildComponent.upsert({
     *   create: {
     *     // ... data to create a UserBuildComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBuildComponent we want to update
     *   }
     * })
     */
    upsert<T extends UserBuildComponentUpsertArgs>(args: SelectSubset<T, UserBuildComponentUpsertArgs<ExtArgs>>): Prisma__UserBuildComponentClient<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBuildComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentCountArgs} args - Arguments to filter UserBuildComponents to count.
     * @example
     * // Count the number of UserBuildComponents
     * const count = await prisma.userBuildComponent.count({
     *   where: {
     *     // ... the filter for the UserBuildComponents we want to count
     *   }
     * })
    **/
    count<T extends UserBuildComponentCountArgs>(
      args?: Subset<T, UserBuildComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBuildComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBuildComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBuildComponentAggregateArgs>(args: Subset<T, UserBuildComponentAggregateArgs>): Prisma.PrismaPromise<GetUserBuildComponentAggregateType<T>>

    /**
     * Group by UserBuildComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBuildComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBuildComponentGroupByArgs['orderBy'] }
        : { orderBy?: UserBuildComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBuildComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBuildComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBuildComponent model
   */
  readonly fields: UserBuildComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBuildComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBuildComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBuild<T extends UserBuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserBuildDefaultArgs<ExtArgs>>): Prisma__UserBuildClient<$Result.GetResult<Prisma.$UserBuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    componentType<T extends ComponentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentTypeDefaultArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBuildComponent model
   */
  interface UserBuildComponentFieldRefs {
    readonly id: FieldRef<"UserBuildComponent", 'String'>
    readonly userBuildId: FieldRef<"UserBuildComponent", 'String'>
    readonly productId: FieldRef<"UserBuildComponent", 'String'>
    readonly componentTypeId: FieldRef<"UserBuildComponent", 'String'>
    readonly createdAt: FieldRef<"UserBuildComponent", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBuildComponent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBuildComponent findUnique
   */
  export type UserBuildComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * Filter, which UserBuildComponent to fetch.
     */
    where: UserBuildComponentWhereUniqueInput
  }

  /**
   * UserBuildComponent findUniqueOrThrow
   */
  export type UserBuildComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * Filter, which UserBuildComponent to fetch.
     */
    where: UserBuildComponentWhereUniqueInput
  }

  /**
   * UserBuildComponent findFirst
   */
  export type UserBuildComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * Filter, which UserBuildComponent to fetch.
     */
    where?: UserBuildComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuildComponents to fetch.
     */
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBuildComponents.
     */
    cursor?: UserBuildComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuildComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuildComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBuildComponents.
     */
    distinct?: UserBuildComponentScalarFieldEnum | UserBuildComponentScalarFieldEnum[]
  }

  /**
   * UserBuildComponent findFirstOrThrow
   */
  export type UserBuildComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * Filter, which UserBuildComponent to fetch.
     */
    where?: UserBuildComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuildComponents to fetch.
     */
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBuildComponents.
     */
    cursor?: UserBuildComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuildComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuildComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBuildComponents.
     */
    distinct?: UserBuildComponentScalarFieldEnum | UserBuildComponentScalarFieldEnum[]
  }

  /**
   * UserBuildComponent findMany
   */
  export type UserBuildComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * Filter, which UserBuildComponents to fetch.
     */
    where?: UserBuildComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuildComponents to fetch.
     */
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBuildComponents.
     */
    cursor?: UserBuildComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuildComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuildComponents.
     */
    skip?: number
    distinct?: UserBuildComponentScalarFieldEnum | UserBuildComponentScalarFieldEnum[]
  }

  /**
   * UserBuildComponent create
   */
  export type UserBuildComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBuildComponent.
     */
    data: XOR<UserBuildComponentCreateInput, UserBuildComponentUncheckedCreateInput>
  }

  /**
   * UserBuildComponent createMany
   */
  export type UserBuildComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBuildComponents.
     */
    data: UserBuildComponentCreateManyInput | UserBuildComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBuildComponent createManyAndReturn
   */
  export type UserBuildComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * The data used to create many UserBuildComponents.
     */
    data: UserBuildComponentCreateManyInput | UserBuildComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBuildComponent update
   */
  export type UserBuildComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBuildComponent.
     */
    data: XOR<UserBuildComponentUpdateInput, UserBuildComponentUncheckedUpdateInput>
    /**
     * Choose, which UserBuildComponent to update.
     */
    where: UserBuildComponentWhereUniqueInput
  }

  /**
   * UserBuildComponent updateMany
   */
  export type UserBuildComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBuildComponents.
     */
    data: XOR<UserBuildComponentUpdateManyMutationInput, UserBuildComponentUncheckedUpdateManyInput>
    /**
     * Filter which UserBuildComponents to update
     */
    where?: UserBuildComponentWhereInput
    /**
     * Limit how many UserBuildComponents to update.
     */
    limit?: number
  }

  /**
   * UserBuildComponent updateManyAndReturn
   */
  export type UserBuildComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * The data used to update UserBuildComponents.
     */
    data: XOR<UserBuildComponentUpdateManyMutationInput, UserBuildComponentUncheckedUpdateManyInput>
    /**
     * Filter which UserBuildComponents to update
     */
    where?: UserBuildComponentWhereInput
    /**
     * Limit how many UserBuildComponents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBuildComponent upsert
   */
  export type UserBuildComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBuildComponent to update in case it exists.
     */
    where: UserBuildComponentWhereUniqueInput
    /**
     * In case the UserBuildComponent found by the `where` argument doesn't exist, create a new UserBuildComponent with this data.
     */
    create: XOR<UserBuildComponentCreateInput, UserBuildComponentUncheckedCreateInput>
    /**
     * In case the UserBuildComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBuildComponentUpdateInput, UserBuildComponentUncheckedUpdateInput>
  }

  /**
   * UserBuildComponent delete
   */
  export type UserBuildComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    /**
     * Filter which UserBuildComponent to delete.
     */
    where: UserBuildComponentWhereUniqueInput
  }

  /**
   * UserBuildComponent deleteMany
   */
  export type UserBuildComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBuildComponents to delete
     */
    where?: UserBuildComponentWhereInput
    /**
     * Limit how many UserBuildComponents to delete.
     */
    limit?: number
  }

  /**
   * UserBuildComponent without action
   */
  export type UserBuildComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
  }


  /**
   * Model ComponentType
   */

  export type AggregateComponentType = {
    _count: ComponentTypeCountAggregateOutputType | null
    _min: ComponentTypeMinAggregateOutputType | null
    _max: ComponentTypeMaxAggregateOutputType | null
  }

  export type ComponentTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComponentTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComponentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentType to aggregate.
     */
    where?: ComponentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentTypes to fetch.
     */
    orderBy?: ComponentTypeOrderByWithRelationInput | ComponentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComponentTypes
    **/
    _count?: true | ComponentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentTypeMaxAggregateInputType
  }

  export type GetComponentTypeAggregateType<T extends ComponentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateComponentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponentType[P]>
      : GetScalarType<T[P], AggregateComponentType[P]>
  }




  export type ComponentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentTypeWhereInput
    orderBy?: ComponentTypeOrderByWithAggregationInput | ComponentTypeOrderByWithAggregationInput[]
    by: ComponentTypeScalarFieldEnum[] | ComponentTypeScalarFieldEnum
    having?: ComponentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentTypeCountAggregateInputType | true
    _min?: ComponentTypeMinAggregateInputType
    _max?: ComponentTypeMaxAggregateInputType
  }

  export type ComponentTypeGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ComponentTypeCountAggregateOutputType | null
    _min: ComponentTypeMinAggregateOutputType | null
    _max: ComponentTypeMaxAggregateOutputType | null
  }

  type GetComponentTypeGroupByPayload<T extends ComponentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentTypeGroupByOutputType[P]>
        }
      >
    >


  export type ComponentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UserBuildComponent?: boolean | ComponentType$UserBuildComponentArgs<ExtArgs>
    _count?: boolean | ComponentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentType"]>

  export type ComponentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["componentType"]>

  export type ComponentTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["componentType"]>

  export type ComponentTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComponentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["componentType"]>
  export type ComponentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserBuildComponent?: boolean | ComponentType$UserBuildComponentArgs<ExtArgs>
    _count?: boolean | ComponentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComponentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ComponentTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ComponentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComponentType"
    objects: {
      UserBuildComponent: Prisma.$UserBuildComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["componentType"]>
    composites: {}
  }

  type ComponentTypeGetPayload<S extends boolean | null | undefined | ComponentTypeDefaultArgs> = $Result.GetResult<Prisma.$ComponentTypePayload, S>

  type ComponentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComponentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComponentTypeCountAggregateInputType | true
    }

  export interface ComponentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComponentType'], meta: { name: 'ComponentType' } }
    /**
     * Find zero or one ComponentType that matches the filter.
     * @param {ComponentTypeFindUniqueArgs} args - Arguments to find a ComponentType
     * @example
     * // Get one ComponentType
     * const componentType = await prisma.componentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentTypeFindUniqueArgs>(args: SelectSubset<T, ComponentTypeFindUniqueArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComponentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComponentTypeFindUniqueOrThrowArgs} args - Arguments to find a ComponentType
     * @example
     * // Get one ComponentType
     * const componentType = await prisma.componentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComponentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeFindFirstArgs} args - Arguments to find a ComponentType
     * @example
     * // Get one ComponentType
     * const componentType = await prisma.componentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentTypeFindFirstArgs>(args?: SelectSubset<T, ComponentTypeFindFirstArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComponentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeFindFirstOrThrowArgs} args - Arguments to find a ComponentType
     * @example
     * // Get one ComponentType
     * const componentType = await prisma.componentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComponentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComponentTypes
     * const componentTypes = await prisma.componentType.findMany()
     * 
     * // Get first 10 ComponentTypes
     * const componentTypes = await prisma.componentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentTypeWithIdOnly = await prisma.componentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentTypeFindManyArgs>(args?: SelectSubset<T, ComponentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComponentType.
     * @param {ComponentTypeCreateArgs} args - Arguments to create a ComponentType.
     * @example
     * // Create one ComponentType
     * const ComponentType = await prisma.componentType.create({
     *   data: {
     *     // ... data to create a ComponentType
     *   }
     * })
     * 
     */
    create<T extends ComponentTypeCreateArgs>(args: SelectSubset<T, ComponentTypeCreateArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComponentTypes.
     * @param {ComponentTypeCreateManyArgs} args - Arguments to create many ComponentTypes.
     * @example
     * // Create many ComponentTypes
     * const componentType = await prisma.componentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentTypeCreateManyArgs>(args?: SelectSubset<T, ComponentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComponentTypes and returns the data saved in the database.
     * @param {ComponentTypeCreateManyAndReturnArgs} args - Arguments to create many ComponentTypes.
     * @example
     * // Create many ComponentTypes
     * const componentType = await prisma.componentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComponentTypes and only return the `id`
     * const componentTypeWithIdOnly = await prisma.componentType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComponentType.
     * @param {ComponentTypeDeleteArgs} args - Arguments to delete one ComponentType.
     * @example
     * // Delete one ComponentType
     * const ComponentType = await prisma.componentType.delete({
     *   where: {
     *     // ... filter to delete one ComponentType
     *   }
     * })
     * 
     */
    delete<T extends ComponentTypeDeleteArgs>(args: SelectSubset<T, ComponentTypeDeleteArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComponentType.
     * @param {ComponentTypeUpdateArgs} args - Arguments to update one ComponentType.
     * @example
     * // Update one ComponentType
     * const componentType = await prisma.componentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentTypeUpdateArgs>(args: SelectSubset<T, ComponentTypeUpdateArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComponentTypes.
     * @param {ComponentTypeDeleteManyArgs} args - Arguments to filter ComponentTypes to delete.
     * @example
     * // Delete a few ComponentTypes
     * const { count } = await prisma.componentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentTypeDeleteManyArgs>(args?: SelectSubset<T, ComponentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComponentTypes
     * const componentType = await prisma.componentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentTypeUpdateManyArgs>(args: SelectSubset<T, ComponentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentTypes and returns the data updated in the database.
     * @param {ComponentTypeUpdateManyAndReturnArgs} args - Arguments to update many ComponentTypes.
     * @example
     * // Update many ComponentTypes
     * const componentType = await prisma.componentType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComponentTypes and only return the `id`
     * const componentTypeWithIdOnly = await prisma.componentType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComponentTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ComponentTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComponentType.
     * @param {ComponentTypeUpsertArgs} args - Arguments to update or create a ComponentType.
     * @example
     * // Update or create a ComponentType
     * const componentType = await prisma.componentType.upsert({
     *   create: {
     *     // ... data to create a ComponentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComponentType we want to update
     *   }
     * })
     */
    upsert<T extends ComponentTypeUpsertArgs>(args: SelectSubset<T, ComponentTypeUpsertArgs<ExtArgs>>): Prisma__ComponentTypeClient<$Result.GetResult<Prisma.$ComponentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComponentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeCountArgs} args - Arguments to filter ComponentTypes to count.
     * @example
     * // Count the number of ComponentTypes
     * const count = await prisma.componentType.count({
     *   where: {
     *     // ... the filter for the ComponentTypes we want to count
     *   }
     * })
    **/
    count<T extends ComponentTypeCountArgs>(
      args?: Subset<T, ComponentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComponentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentTypeAggregateArgs>(args: Subset<T, ComponentTypeAggregateArgs>): Prisma.PrismaPromise<GetComponentTypeAggregateType<T>>

    /**
     * Group by ComponentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentTypeGroupByArgs['orderBy'] }
        : { orderBy?: ComponentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComponentType model
   */
  readonly fields: ComponentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComponentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserBuildComponent<T extends ComponentType$UserBuildComponentArgs<ExtArgs> = {}>(args?: Subset<T, ComponentType$UserBuildComponentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBuildComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComponentType model
   */
  interface ComponentTypeFieldRefs {
    readonly id: FieldRef<"ComponentType", 'String'>
    readonly name: FieldRef<"ComponentType", 'String'>
    readonly createdAt: FieldRef<"ComponentType", 'DateTime'>
    readonly updatedAt: FieldRef<"ComponentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComponentType findUnique
   */
  export type ComponentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComponentType to fetch.
     */
    where: ComponentTypeWhereUniqueInput
  }

  /**
   * ComponentType findUniqueOrThrow
   */
  export type ComponentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComponentType to fetch.
     */
    where: ComponentTypeWhereUniqueInput
  }

  /**
   * ComponentType findFirst
   */
  export type ComponentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComponentType to fetch.
     */
    where?: ComponentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentTypes to fetch.
     */
    orderBy?: ComponentTypeOrderByWithRelationInput | ComponentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentTypes.
     */
    cursor?: ComponentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentTypes.
     */
    distinct?: ComponentTypeScalarFieldEnum | ComponentTypeScalarFieldEnum[]
  }

  /**
   * ComponentType findFirstOrThrow
   */
  export type ComponentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComponentType to fetch.
     */
    where?: ComponentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentTypes to fetch.
     */
    orderBy?: ComponentTypeOrderByWithRelationInput | ComponentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentTypes.
     */
    cursor?: ComponentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentTypes.
     */
    distinct?: ComponentTypeScalarFieldEnum | ComponentTypeScalarFieldEnum[]
  }

  /**
   * ComponentType findMany
   */
  export type ComponentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ComponentTypes to fetch.
     */
    where?: ComponentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentTypes to fetch.
     */
    orderBy?: ComponentTypeOrderByWithRelationInput | ComponentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComponentTypes.
     */
    cursor?: ComponentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentTypes.
     */
    skip?: number
    distinct?: ComponentTypeScalarFieldEnum | ComponentTypeScalarFieldEnum[]
  }

  /**
   * ComponentType create
   */
  export type ComponentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ComponentType.
     */
    data: XOR<ComponentTypeCreateInput, ComponentTypeUncheckedCreateInput>
  }

  /**
   * ComponentType createMany
   */
  export type ComponentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComponentTypes.
     */
    data: ComponentTypeCreateManyInput | ComponentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComponentType createManyAndReturn
   */
  export type ComponentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ComponentTypes.
     */
    data: ComponentTypeCreateManyInput | ComponentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComponentType update
   */
  export type ComponentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ComponentType.
     */
    data: XOR<ComponentTypeUpdateInput, ComponentTypeUncheckedUpdateInput>
    /**
     * Choose, which ComponentType to update.
     */
    where: ComponentTypeWhereUniqueInput
  }

  /**
   * ComponentType updateMany
   */
  export type ComponentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComponentTypes.
     */
    data: XOR<ComponentTypeUpdateManyMutationInput, ComponentTypeUncheckedUpdateManyInput>
    /**
     * Filter which ComponentTypes to update
     */
    where?: ComponentTypeWhereInput
    /**
     * Limit how many ComponentTypes to update.
     */
    limit?: number
  }

  /**
   * ComponentType updateManyAndReturn
   */
  export type ComponentTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * The data used to update ComponentTypes.
     */
    data: XOR<ComponentTypeUpdateManyMutationInput, ComponentTypeUncheckedUpdateManyInput>
    /**
     * Filter which ComponentTypes to update
     */
    where?: ComponentTypeWhereInput
    /**
     * Limit how many ComponentTypes to update.
     */
    limit?: number
  }

  /**
   * ComponentType upsert
   */
  export type ComponentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ComponentType to update in case it exists.
     */
    where: ComponentTypeWhereUniqueInput
    /**
     * In case the ComponentType found by the `where` argument doesn't exist, create a new ComponentType with this data.
     */
    create: XOR<ComponentTypeCreateInput, ComponentTypeUncheckedCreateInput>
    /**
     * In case the ComponentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentTypeUpdateInput, ComponentTypeUncheckedUpdateInput>
  }

  /**
   * ComponentType delete
   */
  export type ComponentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
    /**
     * Filter which ComponentType to delete.
     */
    where: ComponentTypeWhereUniqueInput
  }

  /**
   * ComponentType deleteMany
   */
  export type ComponentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentTypes to delete
     */
    where?: ComponentTypeWhereInput
    /**
     * Limit how many ComponentTypes to delete.
     */
    limit?: number
  }

  /**
   * ComponentType.UserBuildComponent
   */
  export type ComponentType$UserBuildComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBuildComponent
     */
    select?: UserBuildComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBuildComponent
     */
    omit?: UserBuildComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBuildComponentInclude<ExtArgs> | null
    where?: UserBuildComponentWhereInput
    orderBy?: UserBuildComponentOrderByWithRelationInput | UserBuildComponentOrderByWithRelationInput[]
    cursor?: UserBuildComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBuildComponentScalarFieldEnum | UserBuildComponentScalarFieldEnum[]
  }

  /**
   * ComponentType without action
   */
  export type ComponentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentType
     */
    select?: ComponentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentType
     */
    omit?: ComponentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentTypeInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: string | null
    productId: string | null
    imageUrl: string | null
    altText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    imageUrl: string | null
    altText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    productId: number
    imageUrl: number
    altText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductImageMinAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    altText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: string
    productId: string
    imageUrl: string
    altText: string
    createdAt: Date
    updatedAt: Date
    _count: ProductImageCountAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectScalar = {
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    altText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "imageUrl" | "altText" | "createdAt" | "updatedAt", ExtArgs["result"]["productImage"]>
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      imageUrl: string
      altText: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductImages and returns the data saved in the database.
     * @param {ProductImageCreateManyAndReturnArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages and returns the data updated in the database.
     * @param {ProductImageUpdateManyAndReturnArgs} args - Arguments to update many ProductImages.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'String'>
    readonly productId: FieldRef<"ProductImage", 'String'>
    readonly imageUrl: FieldRef<"ProductImage", 'String'>
    readonly altText: FieldRef<"ProductImage", 'String'>
    readonly createdAt: FieldRef<"ProductImage", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage createManyAndReturn
   */
  export type ProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImage updateManyAndReturn
   */
  export type ProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    sku: 'sku',
    stock: 'stock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ColorScalarFieldEnum: {
    id: 'id',
    keyboardId: 'keyboardId',
    hex: 'hex',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ColorScalarFieldEnum = (typeof ColorScalarFieldEnum)[keyof typeof ColorScalarFieldEnum]


  export const KeyboardScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    layoutId: 'layoutId',
    connectionTypeId: 'connectionTypeId',
    isHotswapable: 'isHotswapable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeyboardScalarFieldEnum = (typeof KeyboardScalarFieldEnum)[keyof typeof KeyboardScalarFieldEnum]


  export const LayoutScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LayoutScalarFieldEnum = (typeof LayoutScalarFieldEnum)[keyof typeof LayoutScalarFieldEnum]


  export const ConnectionTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConnectionTypeScalarFieldEnum = (typeof ConnectionTypeScalarFieldEnum)[keyof typeof ConnectionTypeScalarFieldEnum]


  export const SwitchScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    typeId: 'typeId',
    actuationForce: 'actuationForce',
    actuationPoint: 'actuationPoint',
    totalTravel: 'totalTravel',
    keystrokeLifespan: 'keystrokeLifespan',
    isFactoryLubed: 'isFactoryLubed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SwitchScalarFieldEnum = (typeof SwitchScalarFieldEnum)[keyof typeof SwitchScalarFieldEnum]


  export const SwitchTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SwitchTypeScalarFieldEnum = (typeof SwitchTypeScalarFieldEnum)[keyof typeof SwitchTypeScalarFieldEnum]


  export const KeycapScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    profileId: 'profileId',
    materialId: 'materialId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeycapScalarFieldEnum = (typeof KeycapScalarFieldEnum)[keyof typeof KeycapScalarFieldEnum]


  export const KeycapProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeycapProfileScalarFieldEnum = (typeof KeycapProfileScalarFieldEnum)[keyof typeof KeycapProfileScalarFieldEnum]


  export const KeycapMaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeycapMaterialScalarFieldEnum = (typeof KeycapMaterialScalarFieldEnum)[keyof typeof KeycapMaterialScalarFieldEnum]


  export const AccessoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    typeId: 'typeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccessoryScalarFieldEnum = (typeof AccessoryScalarFieldEnum)[keyof typeof AccessoryScalarFieldEnum]


  export const AccessoryTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccessoryTypeScalarFieldEnum = (typeof AccessoryTypeScalarFieldEnum)[keyof typeof AccessoryTypeScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    address: 'address',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  export const WishlistItemScalarFieldEnum: {
    id: 'id',
    wishlistId: 'wishlistId',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalAmount: 'totalAmount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const BillItemScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    productId: 'productId',
    quantity: 'quantity',
    priceAtPurchase: 'priceAtPurchase',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillItemScalarFieldEnum = (typeof BillItemScalarFieldEnum)[keyof typeof BillItemScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    paymentMethod: 'paymentMethod',
    amount: 'amount',
    status: 'status',
    transactionDate: 'transactionDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    discountType: 'discountType',
    discountValue: 'discountValue',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    minimumOrderAmount: 'minimumOrderAmount',
    usageLimit: 'usageLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const UserCouponScalarFieldEnum: {
    id: 'id',
    couponId: 'couponId',
    userId: 'userId',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserCouponScalarFieldEnum = (typeof UserCouponScalarFieldEnum)[keyof typeof UserCouponScalarFieldEnum]


  export const UserBuildScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBuildScalarFieldEnum = (typeof UserBuildScalarFieldEnum)[keyof typeof UserBuildScalarFieldEnum]


  export const UserBuildComponentScalarFieldEnum: {
    id: 'id',
    userBuildId: 'userBuildId',
    productId: 'productId',
    componentTypeId: 'componentTypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBuildComponentScalarFieldEnum = (typeof UserBuildComponentScalarFieldEnum)[keyof typeof UserBuildComponentScalarFieldEnum]


  export const ComponentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComponentTypeScalarFieldEnum = (typeof ComponentTypeScalarFieldEnum)[keyof typeof ComponentTypeScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    imageUrl: 'imageUrl',
    altText: 'altText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BillStatus'
   */
  export type EnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus'>
    


  /**
   * Reference to a field of type 'BillStatus[]'
   */
  export type ListEnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionMethod'
   */
  export type EnumTransactionMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionMethod'>
    


  /**
   * Reference to a field of type 'TransactionMethod[]'
   */
  export type ListEnumTransactionMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionMethod[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    sku?: StringFilter<"Product"> | string
    stock?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    Keyboard?: XOR<KeyboardNullableScalarRelationFilter, KeyboardWhereInput> | null
    Switch?: XOR<SwitchNullableScalarRelationFilter, SwitchWhereInput> | null
    Keycap?: XOR<KeycapNullableScalarRelationFilter, KeycapWhereInput> | null
    Accessory?: XOR<AccessoryNullableScalarRelationFilter, AccessoryWhereInput> | null
    ProductCategory?: ProductCategoryListRelationFilter
    WishlistItem?: WishlistItemListRelationFilter
    BillItem?: BillItemListRelationFilter
    UserBuildComponent?: UserBuildComponentListRelationFilter
    ProductImage?: ProductImageListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Keyboard?: KeyboardOrderByWithRelationInput
    Switch?: SwitchOrderByWithRelationInput
    Keycap?: KeycapOrderByWithRelationInput
    Accessory?: AccessoryOrderByWithRelationInput
    ProductCategory?: ProductCategoryOrderByRelationAggregateInput
    WishlistItem?: WishlistItemOrderByRelationAggregateInput
    BillItem?: BillItemOrderByRelationAggregateInput
    UserBuildComponent?: UserBuildComponentOrderByRelationAggregateInput
    ProductImage?: ProductImageOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    sku?: StringFilter<"Product"> | string
    stock?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    Keyboard?: XOR<KeyboardNullableScalarRelationFilter, KeyboardWhereInput> | null
    Switch?: XOR<SwitchNullableScalarRelationFilter, SwitchWhereInput> | null
    Keycap?: XOR<KeycapNullableScalarRelationFilter, KeycapWhereInput> | null
    Accessory?: XOR<AccessoryNullableScalarRelationFilter, AccessoryWhereInput> | null
    ProductCategory?: ProductCategoryListRelationFilter
    WishlistItem?: WishlistItemListRelationFilter
    BillItem?: BillItemListRelationFilter
    UserBuildComponent?: UserBuildComponentListRelationFilter
    ProductImage?: ProductImageListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    stock?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ColorWhereInput = {
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    id?: StringFilter<"Color"> | string
    keyboardId?: StringFilter<"Color"> | string
    hex?: StringFilter<"Color"> | string
    name?: StringFilter<"Color"> | string
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
    keyboard?: XOR<KeyboardScalarRelationFilter, KeyboardWhereInput>
  }

  export type ColorOrderByWithRelationInput = {
    id?: SortOrder
    keyboardId?: SortOrder
    hex?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    keyboard?: KeyboardOrderByWithRelationInput
  }

  export type ColorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    keyboardId?: StringFilter<"Color"> | string
    hex?: StringFilter<"Color"> | string
    name?: StringFilter<"Color"> | string
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
    keyboard?: XOR<KeyboardScalarRelationFilter, KeyboardWhereInput>
  }, "id">

  export type ColorOrderByWithAggregationInput = {
    id?: SortOrder
    keyboardId?: SortOrder
    hex?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ColorCountOrderByAggregateInput
    _max?: ColorMaxOrderByAggregateInput
    _min?: ColorMinOrderByAggregateInput
  }

  export type ColorScalarWhereWithAggregatesInput = {
    AND?: ColorScalarWhereWithAggregatesInput | ColorScalarWhereWithAggregatesInput[]
    OR?: ColorScalarWhereWithAggregatesInput[]
    NOT?: ColorScalarWhereWithAggregatesInput | ColorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Color"> | string
    keyboardId?: StringWithAggregatesFilter<"Color"> | string
    hex?: StringWithAggregatesFilter<"Color"> | string
    name?: StringWithAggregatesFilter<"Color"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Color"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Color"> | Date | string
  }

  export type KeyboardWhereInput = {
    AND?: KeyboardWhereInput | KeyboardWhereInput[]
    OR?: KeyboardWhereInput[]
    NOT?: KeyboardWhereInput | KeyboardWhereInput[]
    id?: StringFilter<"Keyboard"> | string
    productId?: StringFilter<"Keyboard"> | string
    layoutId?: StringFilter<"Keyboard"> | string
    connectionTypeId?: StringFilter<"Keyboard"> | string
    isHotswapable?: BoolFilter<"Keyboard"> | boolean
    createdAt?: DateTimeFilter<"Keyboard"> | Date | string
    updatedAt?: DateTimeFilter<"Keyboard"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    layout?: XOR<LayoutScalarRelationFilter, LayoutWhereInput>
    connectionType?: XOR<ConnectionTypeScalarRelationFilter, ConnectionTypeWhereInput>
    Color?: ColorListRelationFilter
  }

  export type KeyboardOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    layoutId?: SortOrder
    connectionTypeId?: SortOrder
    isHotswapable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    layout?: LayoutOrderByWithRelationInput
    connectionType?: ConnectionTypeOrderByWithRelationInput
    Color?: ColorOrderByRelationAggregateInput
  }

  export type KeyboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: KeyboardWhereInput | KeyboardWhereInput[]
    OR?: KeyboardWhereInput[]
    NOT?: KeyboardWhereInput | KeyboardWhereInput[]
    layoutId?: StringFilter<"Keyboard"> | string
    connectionTypeId?: StringFilter<"Keyboard"> | string
    isHotswapable?: BoolFilter<"Keyboard"> | boolean
    createdAt?: DateTimeFilter<"Keyboard"> | Date | string
    updatedAt?: DateTimeFilter<"Keyboard"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    layout?: XOR<LayoutScalarRelationFilter, LayoutWhereInput>
    connectionType?: XOR<ConnectionTypeScalarRelationFilter, ConnectionTypeWhereInput>
    Color?: ColorListRelationFilter
  }, "id" | "productId">

  export type KeyboardOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    layoutId?: SortOrder
    connectionTypeId?: SortOrder
    isHotswapable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeyboardCountOrderByAggregateInput
    _max?: KeyboardMaxOrderByAggregateInput
    _min?: KeyboardMinOrderByAggregateInput
  }

  export type KeyboardScalarWhereWithAggregatesInput = {
    AND?: KeyboardScalarWhereWithAggregatesInput | KeyboardScalarWhereWithAggregatesInput[]
    OR?: KeyboardScalarWhereWithAggregatesInput[]
    NOT?: KeyboardScalarWhereWithAggregatesInput | KeyboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Keyboard"> | string
    productId?: StringWithAggregatesFilter<"Keyboard"> | string
    layoutId?: StringWithAggregatesFilter<"Keyboard"> | string
    connectionTypeId?: StringWithAggregatesFilter<"Keyboard"> | string
    isHotswapable?: BoolWithAggregatesFilter<"Keyboard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Keyboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Keyboard"> | Date | string
  }

  export type LayoutWhereInput = {
    AND?: LayoutWhereInput | LayoutWhereInput[]
    OR?: LayoutWhereInput[]
    NOT?: LayoutWhereInput | LayoutWhereInput[]
    id?: StringFilter<"Layout"> | string
    name?: StringFilter<"Layout"> | string
    createdAt?: DateTimeFilter<"Layout"> | Date | string
    updatedAt?: DateTimeFilter<"Layout"> | Date | string
    Keyboard?: KeyboardListRelationFilter
  }

  export type LayoutOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Keyboard?: KeyboardOrderByRelationAggregateInput
  }

  export type LayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LayoutWhereInput | LayoutWhereInput[]
    OR?: LayoutWhereInput[]
    NOT?: LayoutWhereInput | LayoutWhereInput[]
    name?: StringFilter<"Layout"> | string
    createdAt?: DateTimeFilter<"Layout"> | Date | string
    updatedAt?: DateTimeFilter<"Layout"> | Date | string
    Keyboard?: KeyboardListRelationFilter
  }, "id">

  export type LayoutOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LayoutCountOrderByAggregateInput
    _max?: LayoutMaxOrderByAggregateInput
    _min?: LayoutMinOrderByAggregateInput
  }

  export type LayoutScalarWhereWithAggregatesInput = {
    AND?: LayoutScalarWhereWithAggregatesInput | LayoutScalarWhereWithAggregatesInput[]
    OR?: LayoutScalarWhereWithAggregatesInput[]
    NOT?: LayoutScalarWhereWithAggregatesInput | LayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Layout"> | string
    name?: StringWithAggregatesFilter<"Layout"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Layout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Layout"> | Date | string
  }

  export type ConnectionTypeWhereInput = {
    AND?: ConnectionTypeWhereInput | ConnectionTypeWhereInput[]
    OR?: ConnectionTypeWhereInput[]
    NOT?: ConnectionTypeWhereInput | ConnectionTypeWhereInput[]
    id?: StringFilter<"ConnectionType"> | string
    name?: StringFilter<"ConnectionType"> | string
    createdAt?: DateTimeFilter<"ConnectionType"> | Date | string
    updatedAt?: DateTimeFilter<"ConnectionType"> | Date | string
    Keyboard?: KeyboardListRelationFilter
  }

  export type ConnectionTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Keyboard?: KeyboardOrderByRelationAggregateInput
  }

  export type ConnectionTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConnectionTypeWhereInput | ConnectionTypeWhereInput[]
    OR?: ConnectionTypeWhereInput[]
    NOT?: ConnectionTypeWhereInput | ConnectionTypeWhereInput[]
    name?: StringFilter<"ConnectionType"> | string
    createdAt?: DateTimeFilter<"ConnectionType"> | Date | string
    updatedAt?: DateTimeFilter<"ConnectionType"> | Date | string
    Keyboard?: KeyboardListRelationFilter
  }, "id">

  export type ConnectionTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConnectionTypeCountOrderByAggregateInput
    _max?: ConnectionTypeMaxOrderByAggregateInput
    _min?: ConnectionTypeMinOrderByAggregateInput
  }

  export type ConnectionTypeScalarWhereWithAggregatesInput = {
    AND?: ConnectionTypeScalarWhereWithAggregatesInput | ConnectionTypeScalarWhereWithAggregatesInput[]
    OR?: ConnectionTypeScalarWhereWithAggregatesInput[]
    NOT?: ConnectionTypeScalarWhereWithAggregatesInput | ConnectionTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectionType"> | string
    name?: StringWithAggregatesFilter<"ConnectionType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConnectionType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConnectionType"> | Date | string
  }

  export type SwitchWhereInput = {
    AND?: SwitchWhereInput | SwitchWhereInput[]
    OR?: SwitchWhereInput[]
    NOT?: SwitchWhereInput | SwitchWhereInput[]
    id?: StringFilter<"Switch"> | string
    productId?: StringFilter<"Switch"> | string
    typeId?: StringFilter<"Switch"> | string
    actuationForce?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFilter<"Switch"> | number
    isFactoryLubed?: BoolFilter<"Switch"> | boolean
    createdAt?: DateTimeFilter<"Switch"> | Date | string
    updatedAt?: DateTimeFilter<"Switch"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    switchType?: XOR<SwitchTypeScalarRelationFilter, SwitchTypeWhereInput>
  }

  export type SwitchOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
    isFactoryLubed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    switchType?: SwitchTypeOrderByWithRelationInput
  }

  export type SwitchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: SwitchWhereInput | SwitchWhereInput[]
    OR?: SwitchWhereInput[]
    NOT?: SwitchWhereInput | SwitchWhereInput[]
    typeId?: StringFilter<"Switch"> | string
    actuationForce?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFilter<"Switch"> | number
    isFactoryLubed?: BoolFilter<"Switch"> | boolean
    createdAt?: DateTimeFilter<"Switch"> | Date | string
    updatedAt?: DateTimeFilter<"Switch"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    switchType?: XOR<SwitchTypeScalarRelationFilter, SwitchTypeWhereInput>
  }, "id" | "productId">

  export type SwitchOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
    isFactoryLubed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SwitchCountOrderByAggregateInput
    _avg?: SwitchAvgOrderByAggregateInput
    _max?: SwitchMaxOrderByAggregateInput
    _min?: SwitchMinOrderByAggregateInput
    _sum?: SwitchSumOrderByAggregateInput
  }

  export type SwitchScalarWhereWithAggregatesInput = {
    AND?: SwitchScalarWhereWithAggregatesInput | SwitchScalarWhereWithAggregatesInput[]
    OR?: SwitchScalarWhereWithAggregatesInput[]
    NOT?: SwitchScalarWhereWithAggregatesInput | SwitchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Switch"> | string
    productId?: StringWithAggregatesFilter<"Switch"> | string
    typeId?: StringWithAggregatesFilter<"Switch"> | string
    actuationForce?: DecimalWithAggregatesFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalWithAggregatesFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalWithAggregatesFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntWithAggregatesFilter<"Switch"> | number
    isFactoryLubed?: BoolWithAggregatesFilter<"Switch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Switch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Switch"> | Date | string
  }

  export type SwitchTypeWhereInput = {
    AND?: SwitchTypeWhereInput | SwitchTypeWhereInput[]
    OR?: SwitchTypeWhereInput[]
    NOT?: SwitchTypeWhereInput | SwitchTypeWhereInput[]
    id?: StringFilter<"SwitchType"> | string
    name?: StringFilter<"SwitchType"> | string
    createdAt?: DateTimeFilter<"SwitchType"> | Date | string
    updatedAt?: DateTimeFilter<"SwitchType"> | Date | string
    Switch?: SwitchListRelationFilter
  }

  export type SwitchTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Switch?: SwitchOrderByRelationAggregateInput
  }

  export type SwitchTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SwitchTypeWhereInput | SwitchTypeWhereInput[]
    OR?: SwitchTypeWhereInput[]
    NOT?: SwitchTypeWhereInput | SwitchTypeWhereInput[]
    name?: StringFilter<"SwitchType"> | string
    createdAt?: DateTimeFilter<"SwitchType"> | Date | string
    updatedAt?: DateTimeFilter<"SwitchType"> | Date | string
    Switch?: SwitchListRelationFilter
  }, "id">

  export type SwitchTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SwitchTypeCountOrderByAggregateInput
    _max?: SwitchTypeMaxOrderByAggregateInput
    _min?: SwitchTypeMinOrderByAggregateInput
  }

  export type SwitchTypeScalarWhereWithAggregatesInput = {
    AND?: SwitchTypeScalarWhereWithAggregatesInput | SwitchTypeScalarWhereWithAggregatesInput[]
    OR?: SwitchTypeScalarWhereWithAggregatesInput[]
    NOT?: SwitchTypeScalarWhereWithAggregatesInput | SwitchTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SwitchType"> | string
    name?: StringWithAggregatesFilter<"SwitchType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SwitchType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SwitchType"> | Date | string
  }

  export type KeycapWhereInput = {
    AND?: KeycapWhereInput | KeycapWhereInput[]
    OR?: KeycapWhereInput[]
    NOT?: KeycapWhereInput | KeycapWhereInput[]
    id?: StringFilter<"Keycap"> | string
    productId?: StringFilter<"Keycap"> | string
    profileId?: StringFilter<"Keycap"> | string
    materialId?: StringFilter<"Keycap"> | string
    createdAt?: DateTimeFilter<"Keycap"> | Date | string
    updatedAt?: DateTimeFilter<"Keycap"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    profile?: XOR<KeycapProfileScalarRelationFilter, KeycapProfileWhereInput>
    material?: XOR<KeycapMaterialScalarRelationFilter, KeycapMaterialWhereInput>
  }

  export type KeycapOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    profileId?: SortOrder
    materialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    profile?: KeycapProfileOrderByWithRelationInput
    material?: KeycapMaterialOrderByWithRelationInput
  }

  export type KeycapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: KeycapWhereInput | KeycapWhereInput[]
    OR?: KeycapWhereInput[]
    NOT?: KeycapWhereInput | KeycapWhereInput[]
    profileId?: StringFilter<"Keycap"> | string
    materialId?: StringFilter<"Keycap"> | string
    createdAt?: DateTimeFilter<"Keycap"> | Date | string
    updatedAt?: DateTimeFilter<"Keycap"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    profile?: XOR<KeycapProfileScalarRelationFilter, KeycapProfileWhereInput>
    material?: XOR<KeycapMaterialScalarRelationFilter, KeycapMaterialWhereInput>
  }, "id" | "productId">

  export type KeycapOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    profileId?: SortOrder
    materialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeycapCountOrderByAggregateInput
    _max?: KeycapMaxOrderByAggregateInput
    _min?: KeycapMinOrderByAggregateInput
  }

  export type KeycapScalarWhereWithAggregatesInput = {
    AND?: KeycapScalarWhereWithAggregatesInput | KeycapScalarWhereWithAggregatesInput[]
    OR?: KeycapScalarWhereWithAggregatesInput[]
    NOT?: KeycapScalarWhereWithAggregatesInput | KeycapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Keycap"> | string
    productId?: StringWithAggregatesFilter<"Keycap"> | string
    profileId?: StringWithAggregatesFilter<"Keycap"> | string
    materialId?: StringWithAggregatesFilter<"Keycap"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Keycap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Keycap"> | Date | string
  }

  export type KeycapProfileWhereInput = {
    AND?: KeycapProfileWhereInput | KeycapProfileWhereInput[]
    OR?: KeycapProfileWhereInput[]
    NOT?: KeycapProfileWhereInput | KeycapProfileWhereInput[]
    id?: StringFilter<"KeycapProfile"> | string
    name?: StringFilter<"KeycapProfile"> | string
    createdAt?: DateTimeFilter<"KeycapProfile"> | Date | string
    updatedAt?: DateTimeFilter<"KeycapProfile"> | Date | string
    Keycap?: KeycapListRelationFilter
  }

  export type KeycapProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Keycap?: KeycapOrderByRelationAggregateInput
  }

  export type KeycapProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeycapProfileWhereInput | KeycapProfileWhereInput[]
    OR?: KeycapProfileWhereInput[]
    NOT?: KeycapProfileWhereInput | KeycapProfileWhereInput[]
    name?: StringFilter<"KeycapProfile"> | string
    createdAt?: DateTimeFilter<"KeycapProfile"> | Date | string
    updatedAt?: DateTimeFilter<"KeycapProfile"> | Date | string
    Keycap?: KeycapListRelationFilter
  }, "id">

  export type KeycapProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeycapProfileCountOrderByAggregateInput
    _max?: KeycapProfileMaxOrderByAggregateInput
    _min?: KeycapProfileMinOrderByAggregateInput
  }

  export type KeycapProfileScalarWhereWithAggregatesInput = {
    AND?: KeycapProfileScalarWhereWithAggregatesInput | KeycapProfileScalarWhereWithAggregatesInput[]
    OR?: KeycapProfileScalarWhereWithAggregatesInput[]
    NOT?: KeycapProfileScalarWhereWithAggregatesInput | KeycapProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeycapProfile"> | string
    name?: StringWithAggregatesFilter<"KeycapProfile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KeycapProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KeycapProfile"> | Date | string
  }

  export type KeycapMaterialWhereInput = {
    AND?: KeycapMaterialWhereInput | KeycapMaterialWhereInput[]
    OR?: KeycapMaterialWhereInput[]
    NOT?: KeycapMaterialWhereInput | KeycapMaterialWhereInput[]
    id?: StringFilter<"KeycapMaterial"> | string
    name?: StringFilter<"KeycapMaterial"> | string
    createdAt?: DateTimeFilter<"KeycapMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"KeycapMaterial"> | Date | string
    Keycap?: KeycapListRelationFilter
  }

  export type KeycapMaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Keycap?: KeycapOrderByRelationAggregateInput
  }

  export type KeycapMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeycapMaterialWhereInput | KeycapMaterialWhereInput[]
    OR?: KeycapMaterialWhereInput[]
    NOT?: KeycapMaterialWhereInput | KeycapMaterialWhereInput[]
    name?: StringFilter<"KeycapMaterial"> | string
    createdAt?: DateTimeFilter<"KeycapMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"KeycapMaterial"> | Date | string
    Keycap?: KeycapListRelationFilter
  }, "id">

  export type KeycapMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeycapMaterialCountOrderByAggregateInput
    _max?: KeycapMaterialMaxOrderByAggregateInput
    _min?: KeycapMaterialMinOrderByAggregateInput
  }

  export type KeycapMaterialScalarWhereWithAggregatesInput = {
    AND?: KeycapMaterialScalarWhereWithAggregatesInput | KeycapMaterialScalarWhereWithAggregatesInput[]
    OR?: KeycapMaterialScalarWhereWithAggregatesInput[]
    NOT?: KeycapMaterialScalarWhereWithAggregatesInput | KeycapMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeycapMaterial"> | string
    name?: StringWithAggregatesFilter<"KeycapMaterial"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KeycapMaterial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KeycapMaterial"> | Date | string
  }

  export type AccessoryWhereInput = {
    AND?: AccessoryWhereInput | AccessoryWhereInput[]
    OR?: AccessoryWhereInput[]
    NOT?: AccessoryWhereInput | AccessoryWhereInput[]
    id?: StringFilter<"Accessory"> | string
    productId?: StringFilter<"Accessory"> | string
    typeId?: StringFilter<"Accessory"> | string
    createdAt?: DateTimeFilter<"Accessory"> | Date | string
    updatedAt?: DateTimeFilter<"Accessory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    type?: XOR<AccessoryTypeScalarRelationFilter, AccessoryTypeWhereInput>
  }

  export type AccessoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    type?: AccessoryTypeOrderByWithRelationInput
  }

  export type AccessoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: AccessoryWhereInput | AccessoryWhereInput[]
    OR?: AccessoryWhereInput[]
    NOT?: AccessoryWhereInput | AccessoryWhereInput[]
    typeId?: StringFilter<"Accessory"> | string
    createdAt?: DateTimeFilter<"Accessory"> | Date | string
    updatedAt?: DateTimeFilter<"Accessory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    type?: XOR<AccessoryTypeScalarRelationFilter, AccessoryTypeWhereInput>
  }, "id" | "productId">

  export type AccessoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccessoryCountOrderByAggregateInput
    _max?: AccessoryMaxOrderByAggregateInput
    _min?: AccessoryMinOrderByAggregateInput
  }

  export type AccessoryScalarWhereWithAggregatesInput = {
    AND?: AccessoryScalarWhereWithAggregatesInput | AccessoryScalarWhereWithAggregatesInput[]
    OR?: AccessoryScalarWhereWithAggregatesInput[]
    NOT?: AccessoryScalarWhereWithAggregatesInput | AccessoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Accessory"> | string
    productId?: StringWithAggregatesFilter<"Accessory"> | string
    typeId?: StringWithAggregatesFilter<"Accessory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Accessory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Accessory"> | Date | string
  }

  export type AccessoryTypeWhereInput = {
    AND?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    OR?: AccessoryTypeWhereInput[]
    NOT?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    id?: StringFilter<"AccessoryType"> | string
    name?: StringFilter<"AccessoryType"> | string
    createdAt?: DateTimeFilter<"AccessoryType"> | Date | string
    updatedAt?: DateTimeFilter<"AccessoryType"> | Date | string
    Accessory?: AccessoryListRelationFilter
  }

  export type AccessoryTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Accessory?: AccessoryOrderByRelationAggregateInput
  }

  export type AccessoryTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    OR?: AccessoryTypeWhereInput[]
    NOT?: AccessoryTypeWhereInput | AccessoryTypeWhereInput[]
    name?: StringFilter<"AccessoryType"> | string
    createdAt?: DateTimeFilter<"AccessoryType"> | Date | string
    updatedAt?: DateTimeFilter<"AccessoryType"> | Date | string
    Accessory?: AccessoryListRelationFilter
  }, "id">

  export type AccessoryTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccessoryTypeCountOrderByAggregateInput
    _max?: AccessoryTypeMaxOrderByAggregateInput
    _min?: AccessoryTypeMinOrderByAggregateInput
  }

  export type AccessoryTypeScalarWhereWithAggregatesInput = {
    AND?: AccessoryTypeScalarWhereWithAggregatesInput | AccessoryTypeScalarWhereWithAggregatesInput[]
    OR?: AccessoryTypeScalarWhereWithAggregatesInput[]
    NOT?: AccessoryTypeScalarWhereWithAggregatesInput | AccessoryTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccessoryType"> | string
    name?: StringWithAggregatesFilter<"AccessoryType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccessoryType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccessoryType"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    ProductCategory?: ProductCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ProductCategory?: ProductCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    ProductCategory?: ProductCategoryListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    productId?: StringWithAggregatesFilter<"ProductCategory"> | string
    categoryId?: StringWithAggregatesFilter<"ProductCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    Cart?: CartListRelationFilter
    Wishlist?: WishlistListRelationFilter
    Bill?: BillListRelationFilter
    UserCoupon?: UserCouponListRelationFilter
    UserBuild?: UserBuildListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    Cart?: CartOrderByRelationAggregateInput
    Wishlist?: WishlistOrderByRelationAggregateInput
    Bill?: BillOrderByRelationAggregateInput
    UserCoupon?: UserCouponOrderByRelationAggregateInput
    UserBuild?: UserBuildOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    roleId?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    Cart?: CartListRelationFilter
    Wishlist?: WishlistListRelationFilter
    Bill?: BillListRelationFilter
    UserCoupon?: UserCouponListRelationFilter
    UserBuild?: UserBuildListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    address?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    CartItem?: CartItemListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    CartItem?: CartItemOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    userId?: StringFilter<"Cart"> | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    CartItem?: CartItemListRelationFilter
  }, "id">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringWithAggregatesFilter<"Cart"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type WishlistWhereInput = {
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    id?: StringFilter<"Wishlist"> | string
    userId?: StringFilter<"Wishlist"> | string
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    WishlistItem?: WishlistItemListRelationFilter
  }

  export type WishlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    WishlistItem?: WishlistItemOrderByRelationAggregateInput
  }

  export type WishlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    WishlistItem?: WishlistItemListRelationFilter
  }, "id" | "userId">

  export type WishlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WishlistCountOrderByAggregateInput
    _max?: WishlistMaxOrderByAggregateInput
    _min?: WishlistMinOrderByAggregateInput
  }

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    OR?: WishlistScalarWhereWithAggregatesInput[]
    NOT?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wishlist"> | string
    userId?: StringWithAggregatesFilter<"Wishlist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
  }

  export type WishlistItemWhereInput = {
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    wishlistId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    quantity?: IntFilter<"WishlistItem"> | number
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeFilter<"WishlistItem"> | Date | string
    wishlist?: XOR<WishlistScalarRelationFilter, WishlistWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wishlist?: WishlistOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type WishlistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    wishlistId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    quantity?: IntFilter<"WishlistItem"> | number
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeFilter<"WishlistItem"> | Date | string
    wishlist?: XOR<WishlistScalarRelationFilter, WishlistWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WishlistItemCountOrderByAggregateInput
    _avg?: WishlistItemAvgOrderByAggregateInput
    _max?: WishlistItemMaxOrderByAggregateInput
    _min?: WishlistItemMinOrderByAggregateInput
    _sum?: WishlistItemSumOrderByAggregateInput
  }

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    OR?: WishlistItemScalarWhereWithAggregatesInput[]
    NOT?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WishlistItem"> | string
    wishlistId?: StringWithAggregatesFilter<"WishlistItem"> | string
    productId?: StringWithAggregatesFilter<"WishlistItem"> | string
    quantity?: IntWithAggregatesFilter<"WishlistItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: StringFilter<"Bill"> | string
    userId?: StringFilter<"Bill"> | string
    totalAmount?: DecimalFilter<"Bill"> | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFilter<"Bill"> | $Enums.BillStatus
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    BillItem?: BillItemListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    BillItem?: BillItemOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    userId?: StringFilter<"Bill"> | string
    totalAmount?: DecimalFilter<"Bill"> | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFilter<"Bill"> | $Enums.BillStatus
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    BillItem?: BillItemListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bill"> | string
    userId?: StringWithAggregatesFilter<"Bill"> | string
    totalAmount?: DecimalWithAggregatesFilter<"Bill"> | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusWithAggregatesFilter<"Bill"> | $Enums.BillStatus
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
  }

  export type BillItemWhereInput = {
    AND?: BillItemWhereInput | BillItemWhereInput[]
    OR?: BillItemWhereInput[]
    NOT?: BillItemWhereInput | BillItemWhereInput[]
    id?: StringFilter<"BillItem"> | string
    billId?: StringFilter<"BillItem"> | string
    productId?: StringFilter<"BillItem"> | string
    quantity?: IntFilter<"BillItem"> | number
    priceAtPurchase?: DecimalFilter<"BillItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeFilter<"BillItem"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type BillItemOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: BillOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type BillItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillItemWhereInput | BillItemWhereInput[]
    OR?: BillItemWhereInput[]
    NOT?: BillItemWhereInput | BillItemWhereInput[]
    billId?: StringFilter<"BillItem"> | string
    productId?: StringFilter<"BillItem"> | string
    quantity?: IntFilter<"BillItem"> | number
    priceAtPurchase?: DecimalFilter<"BillItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeFilter<"BillItem"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type BillItemOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillItemCountOrderByAggregateInput
    _avg?: BillItemAvgOrderByAggregateInput
    _max?: BillItemMaxOrderByAggregateInput
    _min?: BillItemMinOrderByAggregateInput
    _sum?: BillItemSumOrderByAggregateInput
  }

  export type BillItemScalarWhereWithAggregatesInput = {
    AND?: BillItemScalarWhereWithAggregatesInput | BillItemScalarWhereWithAggregatesInput[]
    OR?: BillItemScalarWhereWithAggregatesInput[]
    NOT?: BillItemScalarWhereWithAggregatesInput | BillItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillItem"> | string
    billId?: StringWithAggregatesFilter<"BillItem"> | string
    productId?: StringWithAggregatesFilter<"BillItem"> | string
    quantity?: IntWithAggregatesFilter<"BillItem"> | number
    priceAtPurchase?: DecimalWithAggregatesFilter<"BillItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillItem"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    billId?: StringFilter<"Transaction"> | string
    paymentMethod?: EnumTransactionMethodFilter<"Transaction"> | $Enums.TransactionMethod
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: BillOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    billId?: StringFilter<"Transaction"> | string
    paymentMethod?: EnumTransactionMethodFilter<"Transaction"> | $Enums.TransactionMethod
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    billId?: StringWithAggregatesFilter<"Transaction"> | string
    paymentMethod?: EnumTransactionMethodWithAggregatesFilter<"Transaction"> | $Enums.TransactionMethod
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    transactionDate?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    discountType?: StringFilter<"Coupon"> | string
    discountValue?: StringFilter<"Coupon"> | string
    validFrom?: DateTimeFilter<"Coupon"> | Date | string
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    minimumOrderAmount?: DecimalFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFilter<"Coupon"> | number
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    UserCoupon?: UserCouponListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    UserCoupon?: UserCouponOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    discountType?: StringFilter<"Coupon"> | string
    discountValue?: StringFilter<"Coupon"> | string
    validFrom?: DateTimeFilter<"Coupon"> | Date | string
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    minimumOrderAmount?: DecimalFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFilter<"Coupon"> | number
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    UserCoupon?: UserCouponListRelationFilter
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    discountType?: StringWithAggregatesFilter<"Coupon"> | string
    discountValue?: StringWithAggregatesFilter<"Coupon"> | string
    validFrom?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    validUntil?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    minimumOrderAmount?: DecimalWithAggregatesFilter<"Coupon"> | Decimal | DecimalJsLike | number | string
    usageLimit?: IntWithAggregatesFilter<"Coupon"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type UserCouponWhereInput = {
    AND?: UserCouponWhereInput | UserCouponWhereInput[]
    OR?: UserCouponWhereInput[]
    NOT?: UserCouponWhereInput | UserCouponWhereInput[]
    id?: StringFilter<"UserCoupon"> | string
    couponId?: StringFilter<"UserCoupon"> | string
    userId?: StringFilter<"UserCoupon"> | string
    usageCount?: IntFilter<"UserCoupon"> | number
    createdAt?: DateTimeFilter<"UserCoupon"> | Date | string
    updatedAt?: DateTimeFilter<"UserCoupon"> | Date | string
    coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserCouponOrderByWithRelationInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coupon?: CouponOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserCouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserCouponWhereInput | UserCouponWhereInput[]
    OR?: UserCouponWhereInput[]
    NOT?: UserCouponWhereInput | UserCouponWhereInput[]
    couponId?: StringFilter<"UserCoupon"> | string
    userId?: StringFilter<"UserCoupon"> | string
    usageCount?: IntFilter<"UserCoupon"> | number
    createdAt?: DateTimeFilter<"UserCoupon"> | Date | string
    updatedAt?: DateTimeFilter<"UserCoupon"> | Date | string
    coupon?: XOR<CouponScalarRelationFilter, CouponWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserCouponOrderByWithAggregationInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCouponCountOrderByAggregateInput
    _avg?: UserCouponAvgOrderByAggregateInput
    _max?: UserCouponMaxOrderByAggregateInput
    _min?: UserCouponMinOrderByAggregateInput
    _sum?: UserCouponSumOrderByAggregateInput
  }

  export type UserCouponScalarWhereWithAggregatesInput = {
    AND?: UserCouponScalarWhereWithAggregatesInput | UserCouponScalarWhereWithAggregatesInput[]
    OR?: UserCouponScalarWhereWithAggregatesInput[]
    NOT?: UserCouponScalarWhereWithAggregatesInput | UserCouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCoupon"> | string
    couponId?: StringWithAggregatesFilter<"UserCoupon"> | string
    userId?: StringWithAggregatesFilter<"UserCoupon"> | string
    usageCount?: IntWithAggregatesFilter<"UserCoupon"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserCoupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserCoupon"> | Date | string
  }

  export type UserBuildWhereInput = {
    AND?: UserBuildWhereInput | UserBuildWhereInput[]
    OR?: UserBuildWhereInput[]
    NOT?: UserBuildWhereInput | UserBuildWhereInput[]
    id?: StringFilter<"UserBuild"> | string
    userId?: StringFilter<"UserBuild"> | string
    name?: StringFilter<"UserBuild"> | string
    description?: StringFilter<"UserBuild"> | string
    createdAt?: DateTimeFilter<"UserBuild"> | Date | string
    updatedAt?: DateTimeFilter<"UserBuild"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    UserBuildComponent?: UserBuildComponentListRelationFilter
  }

  export type UserBuildOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    UserBuildComponent?: UserBuildComponentOrderByRelationAggregateInput
  }

  export type UserBuildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBuildWhereInput | UserBuildWhereInput[]
    OR?: UserBuildWhereInput[]
    NOT?: UserBuildWhereInput | UserBuildWhereInput[]
    userId?: StringFilter<"UserBuild"> | string
    name?: StringFilter<"UserBuild"> | string
    description?: StringFilter<"UserBuild"> | string
    createdAt?: DateTimeFilter<"UserBuild"> | Date | string
    updatedAt?: DateTimeFilter<"UserBuild"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    UserBuildComponent?: UserBuildComponentListRelationFilter
  }, "id">

  export type UserBuildOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBuildCountOrderByAggregateInput
    _max?: UserBuildMaxOrderByAggregateInput
    _min?: UserBuildMinOrderByAggregateInput
  }

  export type UserBuildScalarWhereWithAggregatesInput = {
    AND?: UserBuildScalarWhereWithAggregatesInput | UserBuildScalarWhereWithAggregatesInput[]
    OR?: UserBuildScalarWhereWithAggregatesInput[]
    NOT?: UserBuildScalarWhereWithAggregatesInput | UserBuildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBuild"> | string
    userId?: StringWithAggregatesFilter<"UserBuild"> | string
    name?: StringWithAggregatesFilter<"UserBuild"> | string
    description?: StringWithAggregatesFilter<"UserBuild"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBuild"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBuild"> | Date | string
  }

  export type UserBuildComponentWhereInput = {
    AND?: UserBuildComponentWhereInput | UserBuildComponentWhereInput[]
    OR?: UserBuildComponentWhereInput[]
    NOT?: UserBuildComponentWhereInput | UserBuildComponentWhereInput[]
    id?: StringFilter<"UserBuildComponent"> | string
    userBuildId?: StringFilter<"UserBuildComponent"> | string
    productId?: StringFilter<"UserBuildComponent"> | string
    componentTypeId?: StringFilter<"UserBuildComponent"> | string
    createdAt?: DateTimeFilter<"UserBuildComponent"> | Date | string
    updatedAt?: DateTimeFilter<"UserBuildComponent"> | Date | string
    userBuild?: XOR<UserBuildScalarRelationFilter, UserBuildWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    componentType?: XOR<ComponentTypeScalarRelationFilter, ComponentTypeWhereInput>
  }

  export type UserBuildComponentOrderByWithRelationInput = {
    id?: SortOrder
    userBuildId?: SortOrder
    productId?: SortOrder
    componentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userBuild?: UserBuildOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    componentType?: ComponentTypeOrderByWithRelationInput
  }

  export type UserBuildComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBuildComponentWhereInput | UserBuildComponentWhereInput[]
    OR?: UserBuildComponentWhereInput[]
    NOT?: UserBuildComponentWhereInput | UserBuildComponentWhereInput[]
    userBuildId?: StringFilter<"UserBuildComponent"> | string
    productId?: StringFilter<"UserBuildComponent"> | string
    componentTypeId?: StringFilter<"UserBuildComponent"> | string
    createdAt?: DateTimeFilter<"UserBuildComponent"> | Date | string
    updatedAt?: DateTimeFilter<"UserBuildComponent"> | Date | string
    userBuild?: XOR<UserBuildScalarRelationFilter, UserBuildWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    componentType?: XOR<ComponentTypeScalarRelationFilter, ComponentTypeWhereInput>
  }, "id">

  export type UserBuildComponentOrderByWithAggregationInput = {
    id?: SortOrder
    userBuildId?: SortOrder
    productId?: SortOrder
    componentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBuildComponentCountOrderByAggregateInput
    _max?: UserBuildComponentMaxOrderByAggregateInput
    _min?: UserBuildComponentMinOrderByAggregateInput
  }

  export type UserBuildComponentScalarWhereWithAggregatesInput = {
    AND?: UserBuildComponentScalarWhereWithAggregatesInput | UserBuildComponentScalarWhereWithAggregatesInput[]
    OR?: UserBuildComponentScalarWhereWithAggregatesInput[]
    NOT?: UserBuildComponentScalarWhereWithAggregatesInput | UserBuildComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBuildComponent"> | string
    userBuildId?: StringWithAggregatesFilter<"UserBuildComponent"> | string
    productId?: StringWithAggregatesFilter<"UserBuildComponent"> | string
    componentTypeId?: StringWithAggregatesFilter<"UserBuildComponent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBuildComponent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBuildComponent"> | Date | string
  }

  export type ComponentTypeWhereInput = {
    AND?: ComponentTypeWhereInput | ComponentTypeWhereInput[]
    OR?: ComponentTypeWhereInput[]
    NOT?: ComponentTypeWhereInput | ComponentTypeWhereInput[]
    id?: StringFilter<"ComponentType"> | string
    name?: StringFilter<"ComponentType"> | string
    createdAt?: DateTimeFilter<"ComponentType"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentType"> | Date | string
    UserBuildComponent?: UserBuildComponentListRelationFilter
  }

  export type ComponentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    UserBuildComponent?: UserBuildComponentOrderByRelationAggregateInput
  }

  export type ComponentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComponentTypeWhereInput | ComponentTypeWhereInput[]
    OR?: ComponentTypeWhereInput[]
    NOT?: ComponentTypeWhereInput | ComponentTypeWhereInput[]
    name?: StringFilter<"ComponentType"> | string
    createdAt?: DateTimeFilter<"ComponentType"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentType"> | Date | string
    UserBuildComponent?: UserBuildComponentListRelationFilter
  }, "id">

  export type ComponentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComponentTypeCountOrderByAggregateInput
    _max?: ComponentTypeMaxOrderByAggregateInput
    _min?: ComponentTypeMinOrderByAggregateInput
  }

  export type ComponentTypeScalarWhereWithAggregatesInput = {
    AND?: ComponentTypeScalarWhereWithAggregatesInput | ComponentTypeScalarWhereWithAggregatesInput[]
    OR?: ComponentTypeScalarWhereWithAggregatesInput[]
    NOT?: ComponentTypeScalarWhereWithAggregatesInput | ComponentTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComponentType"> | string
    name?: StringWithAggregatesFilter<"ComponentType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComponentType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComponentType"> | Date | string
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    imageUrl?: StringFilter<"ProductImage"> | string
    altText?: StringFilter<"ProductImage"> | string
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    productId?: StringFilter<"ProductImage"> | string
    imageUrl?: StringFilter<"ProductImage"> | string
    altText?: StringFilter<"ProductImage"> | string
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductImage"> | string
    productId?: StringWithAggregatesFilter<"ProductImage"> | string
    imageUrl?: StringWithAggregatesFilter<"ProductImage"> | string
    altText?: StringWithAggregatesFilter<"ProductImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorCreateInput = {
    id?: string
    hex: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    keyboard: KeyboardCreateNestedOneWithoutColorInput
  }

  export type ColorUncheckedCreateInput = {
    id?: string
    keyboardId: string
    hex: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyboard?: KeyboardUpdateOneRequiredWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyboardId?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorCreateManyInput = {
    id?: string
    keyboardId: string
    hex: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyboardId?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyboardCreateInput = {
    id?: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeyboardInput
    layout: LayoutCreateNestedOneWithoutKeyboardInput
    connectionType: ConnectionTypeCreateNestedOneWithoutKeyboardInput
    Color?: ColorCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardUncheckedCreateInput = {
    id?: string
    productId: string
    layoutId: string
    connectionTypeId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Color?: ColorUncheckedCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeyboardNestedInput
    layout?: LayoutUpdateOneRequiredWithoutKeyboardNestedInput
    connectionType?: ConnectionTypeUpdateOneRequiredWithoutKeyboardNestedInput
    Color?: ColorUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    layoutId?: StringFieldUpdateOperationsInput | string
    connectionTypeId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Color?: ColorUncheckedUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardCreateManyInput = {
    id?: string
    productId: string
    layoutId: string
    connectionTypeId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    layoutId?: StringFieldUpdateOperationsInput | string
    connectionTypeId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedManyWithoutLayoutInput
  }

  export type LayoutUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedManyWithoutLayoutInput
  }

  export type LayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateManyWithoutLayoutNestedInput
  }

  export type LayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateManyWithoutLayoutNestedInput
  }

  export type LayoutCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionTypeCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedManyWithoutConnectionTypeInput
  }

  export type ConnectionTypeUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedManyWithoutConnectionTypeInput
  }

  export type ConnectionTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateManyWithoutConnectionTypeNestedInput
  }

  export type ConnectionTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateManyWithoutConnectionTypeNestedInput
  }

  export type ConnectionTypeCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchCreateInput = {
    id?: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSwitchInput
    switchType: SwitchTypeCreateNestedOneWithoutSwitchInput
  }

  export type SwitchUncheckedCreateInput = {
    id?: string
    productId: string
    typeId: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSwitchNestedInput
    switchType?: SwitchTypeUpdateOneRequiredWithoutSwitchNestedInput
  }

  export type SwitchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchCreateManyInput = {
    id?: string
    productId: string
    typeId: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchTypeCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Switch?: SwitchCreateNestedManyWithoutSwitchTypeInput
  }

  export type SwitchTypeUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Switch?: SwitchUncheckedCreateNestedManyWithoutSwitchTypeInput
  }

  export type SwitchTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Switch?: SwitchUpdateManyWithoutSwitchTypeNestedInput
  }

  export type SwitchTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Switch?: SwitchUncheckedUpdateManyWithoutSwitchTypeNestedInput
  }

  export type SwitchTypeCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeycapInput
    profile: KeycapProfileCreateNestedOneWithoutKeycapInput
    material: KeycapMaterialCreateNestedOneWithoutKeycapInput
  }

  export type KeycapUncheckedCreateInput = {
    id?: string
    productId: string
    profileId: string
    materialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeycapNestedInput
    profile?: KeycapProfileUpdateOneRequiredWithoutKeycapNestedInput
    material?: KeycapMaterialUpdateOneRequiredWithoutKeycapNestedInput
  }

  export type KeycapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapCreateManyInput = {
    id?: string
    productId: string
    profileId: string
    materialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapProfileCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keycap?: KeycapCreateNestedManyWithoutProfileInput
  }

  export type KeycapProfileUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keycap?: KeycapUncheckedCreateNestedManyWithoutProfileInput
  }

  export type KeycapProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keycap?: KeycapUpdateManyWithoutProfileNestedInput
  }

  export type KeycapProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keycap?: KeycapUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type KeycapProfileCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapMaterialCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keycap?: KeycapCreateNestedManyWithoutMaterialInput
  }

  export type KeycapMaterialUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Keycap?: KeycapUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type KeycapMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keycap?: KeycapUpdateManyWithoutMaterialNestedInput
  }

  export type KeycapMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keycap?: KeycapUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type KeycapMaterialCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutAccessoryInput
    type: AccessoryTypeCreateNestedOneWithoutAccessoryInput
  }

  export type AccessoryUncheckedCreateInput = {
    id?: string
    productId: string
    typeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutAccessoryNestedInput
    type?: AccessoryTypeUpdateOneRequiredWithoutAccessoryNestedInput
  }

  export type AccessoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryCreateManyInput = {
    id?: string
    productId: string
    typeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryTypeCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Accessory?: AccessoryCreateNestedManyWithoutTypeInput
  }

  export type AccessoryTypeUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Accessory?: AccessoryUncheckedCreateNestedManyWithoutTypeInput
  }

  export type AccessoryTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accessory?: AccessoryUpdateManyWithoutTypeNestedInput
  }

  export type AccessoryTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Accessory?: AccessoryUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type AccessoryTypeCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductCategory?: ProductCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductCategory?: ProductCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductCategoryInput
    category: CategoryCreateNestedOneWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    productId: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductCategoryNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    productId: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Cart?: CartCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    Bill?: BillCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    Bill?: BillUncheckedCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Cart?: CartUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    Bill?: BillUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    Bill?: BillUncheckedUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartInput
    CartItem?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CartItem?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartNestedInput
    CartItem?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CartItem?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutWishlistInput
  }

  export type WishlistUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutWishlistInput
  }

  export type WishlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wishlist: WishlistCreateNestedOneWithoutWishlistItemInput
    product: ProductCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateInput = {
    id?: string
    wishlistId: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wishlist?: WishlistUpdateOneRequiredWithoutWishlistItemNestedInput
    product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wishlistId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateManyInput = {
    id?: string
    wishlistId: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    wishlistId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillInput
    BillItem?: BillItemCreateNestedManyWithoutBillInput
    Transaction?: TransactionCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateInput = {
    id?: string
    userId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    BillItem?: BillItemUncheckedCreateNestedManyWithoutBillInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillNestedInput
    BillItem?: BillItemUpdateManyWithoutBillNestedInput
    Transaction?: TransactionUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BillItem?: BillItemUncheckedUpdateManyWithoutBillNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillCreateManyInput = {
    id?: string
    userId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemCreateInput = {
    id?: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutBillItemInput
    product: ProductCreateNestedOneWithoutBillItemInput
  }

  export type BillItemUncheckedCreateInput = {
    id?: string
    billId: string
    productId: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutBillItemNestedInput
    product?: ProductUpdateOneRequiredWithoutBillItemNestedInput
  }

  export type BillItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemCreateManyInput = {
    id?: string
    billId: string
    productId: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    billId: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    billId: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    discountType: string
    discountValue: string
    validFrom: Date | string
    validUntil: Date | string
    minimumOrderAmount: Decimal | DecimalJsLike | number | string
    usageLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    UserCoupon?: UserCouponCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    discountType: string
    discountValue: string
    validFrom: Date | string
    validUntil: Date | string
    minimumOrderAmount: Decimal | DecimalJsLike | number | string
    usageLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumOrderAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserCoupon?: UserCouponUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumOrderAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    discountType: string
    discountValue: string
    validFrom: Date | string
    validUntil: Date | string
    minimumOrderAmount: Decimal | DecimalJsLike | number | string
    usageLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumOrderAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumOrderAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponCreateInput = {
    id?: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coupon: CouponCreateNestedOneWithoutUserCouponInput
    user: UserCreateNestedOneWithoutUserCouponInput
  }

  export type UserCouponUncheckedCreateInput = {
    id?: string
    couponId: string
    userId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneRequiredWithoutUserCouponNestedInput
    user?: UserUpdateOneRequiredWithoutUserCouponNestedInput
  }

  export type UserCouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponCreateManyInput = {
    id?: string
    couponId: string
    userId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserBuildInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutUserBuildInput
  }

  export type UserBuildUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutUserBuildInput
  }

  export type UserBuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBuildNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutUserBuildNestedInput
  }

  export type UserBuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutUserBuildNestedInput
  }

  export type UserBuildCreateManyInput = {
    id?: string
    userId: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userBuild: UserBuildCreateNestedOneWithoutUserBuildComponentInput
    product: ProductCreateNestedOneWithoutUserBuildComponentInput
    componentType: ComponentTypeCreateNestedOneWithoutUserBuildComponentInput
  }

  export type UserBuildComponentUncheckedCreateInput = {
    id?: string
    userBuildId: string
    productId: string
    componentTypeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBuild?: UserBuildUpdateOneRequiredWithoutUserBuildComponentNestedInput
    product?: ProductUpdateOneRequiredWithoutUserBuildComponentNestedInput
    componentType?: ComponentTypeUpdateOneRequiredWithoutUserBuildComponentNestedInput
  }

  export type UserBuildComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBuildId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    componentTypeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentCreateManyInput = {
    id?: string
    userBuildId: string
    productId: string
    componentTypeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBuildId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    componentTypeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentTypeCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutComponentTypeInput
  }

  export type ComponentTypeUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutComponentTypeInput
  }

  export type ComponentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutComponentTypeNestedInput
  }

  export type ComponentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutComponentTypeNestedInput
  }

  export type ComponentTypeCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateInput = {
    id?: string
    imageUrl: string
    altText: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: string
    productId: string
    imageUrl: string
    altText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateManyInput = {
    id?: string
    productId: string
    imageUrl: string
    altText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type KeyboardNullableScalarRelationFilter = {
    is?: KeyboardWhereInput | null
    isNot?: KeyboardWhereInput | null
  }

  export type SwitchNullableScalarRelationFilter = {
    is?: SwitchWhereInput | null
    isNot?: SwitchWhereInput | null
  }

  export type KeycapNullableScalarRelationFilter = {
    is?: KeycapWhereInput | null
    isNot?: KeycapWhereInput | null
  }

  export type AccessoryNullableScalarRelationFilter = {
    is?: AccessoryWhereInput | null
    isNot?: AccessoryWhereInput | null
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput
    some?: WishlistItemWhereInput
    none?: WishlistItemWhereInput
  }

  export type BillItemListRelationFilter = {
    every?: BillItemWhereInput
    some?: BillItemWhereInput
    none?: BillItemWhereInput
  }

  export type UserBuildComponentListRelationFilter = {
    every?: UserBuildComponentWhereInput
    some?: UserBuildComponentWhereInput
    none?: UserBuildComponentWhereInput
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBuildComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type KeyboardScalarRelationFilter = {
    is?: KeyboardWhereInput
    isNot?: KeyboardWhereInput
  }

  export type ColorCountOrderByAggregateInput = {
    id?: SortOrder
    keyboardId?: SortOrder
    hex?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorMaxOrderByAggregateInput = {
    id?: SortOrder
    keyboardId?: SortOrder
    hex?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorMinOrderByAggregateInput = {
    id?: SortOrder
    keyboardId?: SortOrder
    hex?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type LayoutScalarRelationFilter = {
    is?: LayoutWhereInput
    isNot?: LayoutWhereInput
  }

  export type ConnectionTypeScalarRelationFilter = {
    is?: ConnectionTypeWhereInput
    isNot?: ConnectionTypeWhereInput
  }

  export type ColorListRelationFilter = {
    every?: ColorWhereInput
    some?: ColorWhereInput
    none?: ColorWhereInput
  }

  export type ColorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeyboardCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    layoutId?: SortOrder
    connectionTypeId?: SortOrder
    isHotswapable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyboardMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    layoutId?: SortOrder
    connectionTypeId?: SortOrder
    isHotswapable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyboardMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    layoutId?: SortOrder
    connectionTypeId?: SortOrder
    isHotswapable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type KeyboardListRelationFilter = {
    every?: KeyboardWhereInput
    some?: KeyboardWhereInput
    none?: KeyboardWhereInput
  }

  export type KeyboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LayoutCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectionTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectionTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectionTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwitchTypeScalarRelationFilter = {
    is?: SwitchTypeWhereInput
    isNot?: SwitchTypeWhereInput
  }

  export type SwitchCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
    isFactoryLubed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwitchAvgOrderByAggregateInput = {
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
  }

  export type SwitchMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
    isFactoryLubed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwitchMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
    isFactoryLubed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwitchSumOrderByAggregateInput = {
    actuationForce?: SortOrder
    actuationPoint?: SortOrder
    totalTravel?: SortOrder
    keystrokeLifespan?: SortOrder
  }

  export type SwitchListRelationFilter = {
    every?: SwitchWhereInput
    some?: SwitchWhereInput
    none?: SwitchWhereInput
  }

  export type SwitchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SwitchTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwitchTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwitchTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapProfileScalarRelationFilter = {
    is?: KeycapProfileWhereInput
    isNot?: KeycapProfileWhereInput
  }

  export type KeycapMaterialScalarRelationFilter = {
    is?: KeycapMaterialWhereInput
    isNot?: KeycapMaterialWhereInput
  }

  export type KeycapCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    profileId?: SortOrder
    materialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    profileId?: SortOrder
    materialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    profileId?: SortOrder
    materialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapListRelationFilter = {
    every?: KeycapWhereInput
    some?: KeycapWhereInput
    none?: KeycapWhereInput
  }

  export type KeycapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeycapProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeycapMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessoryTypeScalarRelationFilter = {
    is?: AccessoryTypeWhereInput
    isNot?: AccessoryTypeWhereInput
  }

  export type AccessoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessoryListRelationFilter = {
    every?: AccessoryWhereInput
    some?: AccessoryWhereInput
    none?: AccessoryWhereInput
  }

  export type AccessoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessoryTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessoryTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessoryTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type WishlistListRelationFilter = {
    every?: WishlistWhereInput
    some?: WishlistWhereInput
    none?: WishlistWhereInput
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type UserCouponListRelationFilter = {
    every?: UserCouponWhereInput
    some?: UserCouponWhereInput
    none?: UserCouponWhereInput
  }

  export type UserBuildListRelationFilter = {
    every?: UserBuildWhereInput
    some?: UserBuildWhereInput
    none?: UserBuildWhereInput
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WishlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistScalarRelationFilter = {
    is?: WishlistWhereInput
    isNot?: WishlistWhereInput
  }

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type BillScalarRelationFilter = {
    is?: BillWhereInput
    isNot?: BillWhereInput
  }

  export type BillItemCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
  }

  export type BillItemMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillItemMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    priceAtPurchase?: SortOrder
  }

  export type EnumTransactionMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionMethod | EnumTransactionMethodFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionMethodFilter<$PrismaModel> | $Enums.TransactionMethod
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionMethod | EnumTransactionMethodFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionMethodWithAggregatesFilter<$PrismaModel> | $Enums.TransactionMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionMethodFilter<$PrismaModel>
    _max?: NestedEnumTransactionMethodFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    minimumOrderAmount?: SortOrder
    usageLimit?: SortOrder
  }

  export type CouponScalarRelationFilter = {
    is?: CouponWhereInput
    isNot?: CouponWhereInput
  }

  export type UserCouponCountOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCouponAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type UserCouponMaxOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCouponMinOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCouponSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type UserBuildCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBuildMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBuildMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBuildScalarRelationFilter = {
    is?: UserBuildWhereInput
    isNot?: UserBuildWhereInput
  }

  export type ComponentTypeScalarRelationFilter = {
    is?: ComponentTypeWhereInput
    isNot?: ComponentTypeWhereInput
  }

  export type UserBuildComponentCountOrderByAggregateInput = {
    id?: SortOrder
    userBuildId?: SortOrder
    productId?: SortOrder
    componentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBuildComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    userBuildId?: SortOrder
    productId?: SortOrder
    componentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBuildComponentMinOrderByAggregateInput = {
    id?: SortOrder
    userBuildId?: SortOrder
    productId?: SortOrder
    componentTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyboardCreateNestedOneWithoutProductInput = {
    create?: XOR<KeyboardCreateWithoutProductInput, KeyboardUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeyboardCreateOrConnectWithoutProductInput
    connect?: KeyboardWhereUniqueInput
  }

  export type SwitchCreateNestedOneWithoutProductInput = {
    create?: XOR<SwitchCreateWithoutProductInput, SwitchUncheckedCreateWithoutProductInput>
    connectOrCreate?: SwitchCreateOrConnectWithoutProductInput
    connect?: SwitchWhereUniqueInput
  }

  export type KeycapCreateNestedOneWithoutProductInput = {
    create?: XOR<KeycapCreateWithoutProductInput, KeycapUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeycapCreateOrConnectWithoutProductInput
    connect?: KeycapWhereUniqueInput
  }

  export type AccessoryCreateNestedOneWithoutProductInput = {
    create?: XOR<AccessoryCreateWithoutProductInput, AccessoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: AccessoryCreateOrConnectWithoutProductInput
    connect?: AccessoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type BillItemCreateNestedManyWithoutProductInput = {
    create?: XOR<BillItemCreateWithoutProductInput, BillItemUncheckedCreateWithoutProductInput> | BillItemCreateWithoutProductInput[] | BillItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutProductInput | BillItemCreateOrConnectWithoutProductInput[]
    createMany?: BillItemCreateManyProductInputEnvelope
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
  }

  export type UserBuildComponentCreateNestedManyWithoutProductInput = {
    create?: XOR<UserBuildComponentCreateWithoutProductInput, UserBuildComponentUncheckedCreateWithoutProductInput> | UserBuildComponentCreateWithoutProductInput[] | UserBuildComponentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutProductInput | UserBuildComponentCreateOrConnectWithoutProductInput[]
    createMany?: UserBuildComponentCreateManyProductInputEnvelope
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type KeyboardUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<KeyboardCreateWithoutProductInput, KeyboardUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeyboardCreateOrConnectWithoutProductInput
    connect?: KeyboardWhereUniqueInput
  }

  export type SwitchUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<SwitchCreateWithoutProductInput, SwitchUncheckedCreateWithoutProductInput>
    connectOrCreate?: SwitchCreateOrConnectWithoutProductInput
    connect?: SwitchWhereUniqueInput
  }

  export type KeycapUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<KeycapCreateWithoutProductInput, KeycapUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeycapCreateOrConnectWithoutProductInput
    connect?: KeycapWhereUniqueInput
  }

  export type AccessoryUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<AccessoryCreateWithoutProductInput, AccessoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: AccessoryCreateOrConnectWithoutProductInput
    connect?: AccessoryWhereUniqueInput
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type BillItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<BillItemCreateWithoutProductInput, BillItemUncheckedCreateWithoutProductInput> | BillItemCreateWithoutProductInput[] | BillItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutProductInput | BillItemCreateOrConnectWithoutProductInput[]
    createMany?: BillItemCreateManyProductInputEnvelope
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
  }

  export type UserBuildComponentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<UserBuildComponentCreateWithoutProductInput, UserBuildComponentUncheckedCreateWithoutProductInput> | UserBuildComponentCreateWithoutProductInput[] | UserBuildComponentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutProductInput | UserBuildComponentCreateOrConnectWithoutProductInput[]
    createMany?: UserBuildComponentCreateManyProductInputEnvelope
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type KeyboardUpdateOneWithoutProductNestedInput = {
    create?: XOR<KeyboardCreateWithoutProductInput, KeyboardUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeyboardCreateOrConnectWithoutProductInput
    upsert?: KeyboardUpsertWithoutProductInput
    disconnect?: KeyboardWhereInput | boolean
    delete?: KeyboardWhereInput | boolean
    connect?: KeyboardWhereUniqueInput
    update?: XOR<XOR<KeyboardUpdateToOneWithWhereWithoutProductInput, KeyboardUpdateWithoutProductInput>, KeyboardUncheckedUpdateWithoutProductInput>
  }

  export type SwitchUpdateOneWithoutProductNestedInput = {
    create?: XOR<SwitchCreateWithoutProductInput, SwitchUncheckedCreateWithoutProductInput>
    connectOrCreate?: SwitchCreateOrConnectWithoutProductInput
    upsert?: SwitchUpsertWithoutProductInput
    disconnect?: SwitchWhereInput | boolean
    delete?: SwitchWhereInput | boolean
    connect?: SwitchWhereUniqueInput
    update?: XOR<XOR<SwitchUpdateToOneWithWhereWithoutProductInput, SwitchUpdateWithoutProductInput>, SwitchUncheckedUpdateWithoutProductInput>
  }

  export type KeycapUpdateOneWithoutProductNestedInput = {
    create?: XOR<KeycapCreateWithoutProductInput, KeycapUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeycapCreateOrConnectWithoutProductInput
    upsert?: KeycapUpsertWithoutProductInput
    disconnect?: KeycapWhereInput | boolean
    delete?: KeycapWhereInput | boolean
    connect?: KeycapWhereUniqueInput
    update?: XOR<XOR<KeycapUpdateToOneWithWhereWithoutProductInput, KeycapUpdateWithoutProductInput>, KeycapUncheckedUpdateWithoutProductInput>
  }

  export type AccessoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<AccessoryCreateWithoutProductInput, AccessoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: AccessoryCreateOrConnectWithoutProductInput
    upsert?: AccessoryUpsertWithoutProductInput
    disconnect?: AccessoryWhereInput | boolean
    delete?: AccessoryWhereInput | boolean
    connect?: AccessoryWhereUniqueInput
    update?: XOR<XOR<AccessoryUpdateToOneWithWhereWithoutProductInput, AccessoryUpdateWithoutProductInput>, AccessoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type BillItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<BillItemCreateWithoutProductInput, BillItemUncheckedCreateWithoutProductInput> | BillItemCreateWithoutProductInput[] | BillItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutProductInput | BillItemCreateOrConnectWithoutProductInput[]
    upsert?: BillItemUpsertWithWhereUniqueWithoutProductInput | BillItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BillItemCreateManyProductInputEnvelope
    set?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    disconnect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    delete?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    update?: BillItemUpdateWithWhereUniqueWithoutProductInput | BillItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BillItemUpdateManyWithWhereWithoutProductInput | BillItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
  }

  export type UserBuildComponentUpdateManyWithoutProductNestedInput = {
    create?: XOR<UserBuildComponentCreateWithoutProductInput, UserBuildComponentUncheckedCreateWithoutProductInput> | UserBuildComponentCreateWithoutProductInput[] | UserBuildComponentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutProductInput | UserBuildComponentCreateOrConnectWithoutProductInput[]
    upsert?: UserBuildComponentUpsertWithWhereUniqueWithoutProductInput | UserBuildComponentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: UserBuildComponentCreateManyProductInputEnvelope
    set?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    disconnect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    delete?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    update?: UserBuildComponentUpdateWithWhereUniqueWithoutProductInput | UserBuildComponentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: UserBuildComponentUpdateManyWithWhereWithoutProductInput | UserBuildComponentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type KeyboardUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<KeyboardCreateWithoutProductInput, KeyboardUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeyboardCreateOrConnectWithoutProductInput
    upsert?: KeyboardUpsertWithoutProductInput
    disconnect?: KeyboardWhereInput | boolean
    delete?: KeyboardWhereInput | boolean
    connect?: KeyboardWhereUniqueInput
    update?: XOR<XOR<KeyboardUpdateToOneWithWhereWithoutProductInput, KeyboardUpdateWithoutProductInput>, KeyboardUncheckedUpdateWithoutProductInput>
  }

  export type SwitchUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<SwitchCreateWithoutProductInput, SwitchUncheckedCreateWithoutProductInput>
    connectOrCreate?: SwitchCreateOrConnectWithoutProductInput
    upsert?: SwitchUpsertWithoutProductInput
    disconnect?: SwitchWhereInput | boolean
    delete?: SwitchWhereInput | boolean
    connect?: SwitchWhereUniqueInput
    update?: XOR<XOR<SwitchUpdateToOneWithWhereWithoutProductInput, SwitchUpdateWithoutProductInput>, SwitchUncheckedUpdateWithoutProductInput>
  }

  export type KeycapUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<KeycapCreateWithoutProductInput, KeycapUncheckedCreateWithoutProductInput>
    connectOrCreate?: KeycapCreateOrConnectWithoutProductInput
    upsert?: KeycapUpsertWithoutProductInput
    disconnect?: KeycapWhereInput | boolean
    delete?: KeycapWhereInput | boolean
    connect?: KeycapWhereUniqueInput
    update?: XOR<XOR<KeycapUpdateToOneWithWhereWithoutProductInput, KeycapUpdateWithoutProductInput>, KeycapUncheckedUpdateWithoutProductInput>
  }

  export type AccessoryUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<AccessoryCreateWithoutProductInput, AccessoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: AccessoryCreateOrConnectWithoutProductInput
    upsert?: AccessoryUpsertWithoutProductInput
    disconnect?: AccessoryWhereInput | boolean
    delete?: AccessoryWhereInput | boolean
    connect?: AccessoryWhereUniqueInput
    update?: XOR<XOR<AccessoryUpdateToOneWithWhereWithoutProductInput, AccessoryUpdateWithoutProductInput>, AccessoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type BillItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<BillItemCreateWithoutProductInput, BillItemUncheckedCreateWithoutProductInput> | BillItemCreateWithoutProductInput[] | BillItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutProductInput | BillItemCreateOrConnectWithoutProductInput[]
    upsert?: BillItemUpsertWithWhereUniqueWithoutProductInput | BillItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BillItemCreateManyProductInputEnvelope
    set?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    disconnect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    delete?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    update?: BillItemUpdateWithWhereUniqueWithoutProductInput | BillItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BillItemUpdateManyWithWhereWithoutProductInput | BillItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
  }

  export type UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<UserBuildComponentCreateWithoutProductInput, UserBuildComponentUncheckedCreateWithoutProductInput> | UserBuildComponentCreateWithoutProductInput[] | UserBuildComponentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutProductInput | UserBuildComponentCreateOrConnectWithoutProductInput[]
    upsert?: UserBuildComponentUpsertWithWhereUniqueWithoutProductInput | UserBuildComponentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: UserBuildComponentCreateManyProductInputEnvelope
    set?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    disconnect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    delete?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    update?: UserBuildComponentUpdateWithWhereUniqueWithoutProductInput | UserBuildComponentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: UserBuildComponentUpdateManyWithWhereWithoutProductInput | UserBuildComponentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type KeyboardCreateNestedOneWithoutColorInput = {
    create?: XOR<KeyboardCreateWithoutColorInput, KeyboardUncheckedCreateWithoutColorInput>
    connectOrCreate?: KeyboardCreateOrConnectWithoutColorInput
    connect?: KeyboardWhereUniqueInput
  }

  export type KeyboardUpdateOneRequiredWithoutColorNestedInput = {
    create?: XOR<KeyboardCreateWithoutColorInput, KeyboardUncheckedCreateWithoutColorInput>
    connectOrCreate?: KeyboardCreateOrConnectWithoutColorInput
    upsert?: KeyboardUpsertWithoutColorInput
    connect?: KeyboardWhereUniqueInput
    update?: XOR<XOR<KeyboardUpdateToOneWithWhereWithoutColorInput, KeyboardUpdateWithoutColorInput>, KeyboardUncheckedUpdateWithoutColorInput>
  }

  export type ProductCreateNestedOneWithoutKeyboardInput = {
    create?: XOR<ProductCreateWithoutKeyboardInput, ProductUncheckedCreateWithoutKeyboardInput>
    connectOrCreate?: ProductCreateOrConnectWithoutKeyboardInput
    connect?: ProductWhereUniqueInput
  }

  export type LayoutCreateNestedOneWithoutKeyboardInput = {
    create?: XOR<LayoutCreateWithoutKeyboardInput, LayoutUncheckedCreateWithoutKeyboardInput>
    connectOrCreate?: LayoutCreateOrConnectWithoutKeyboardInput
    connect?: LayoutWhereUniqueInput
  }

  export type ConnectionTypeCreateNestedOneWithoutKeyboardInput = {
    create?: XOR<ConnectionTypeCreateWithoutKeyboardInput, ConnectionTypeUncheckedCreateWithoutKeyboardInput>
    connectOrCreate?: ConnectionTypeCreateOrConnectWithoutKeyboardInput
    connect?: ConnectionTypeWhereUniqueInput
  }

  export type ColorCreateNestedManyWithoutKeyboardInput = {
    create?: XOR<ColorCreateWithoutKeyboardInput, ColorUncheckedCreateWithoutKeyboardInput> | ColorCreateWithoutKeyboardInput[] | ColorUncheckedCreateWithoutKeyboardInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutKeyboardInput | ColorCreateOrConnectWithoutKeyboardInput[]
    createMany?: ColorCreateManyKeyboardInputEnvelope
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
  }

  export type ColorUncheckedCreateNestedManyWithoutKeyboardInput = {
    create?: XOR<ColorCreateWithoutKeyboardInput, ColorUncheckedCreateWithoutKeyboardInput> | ColorCreateWithoutKeyboardInput[] | ColorUncheckedCreateWithoutKeyboardInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutKeyboardInput | ColorCreateOrConnectWithoutKeyboardInput[]
    createMany?: ColorCreateManyKeyboardInputEnvelope
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductUpdateOneRequiredWithoutKeyboardNestedInput = {
    create?: XOR<ProductCreateWithoutKeyboardInput, ProductUncheckedCreateWithoutKeyboardInput>
    connectOrCreate?: ProductCreateOrConnectWithoutKeyboardInput
    upsert?: ProductUpsertWithoutKeyboardInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutKeyboardInput, ProductUpdateWithoutKeyboardInput>, ProductUncheckedUpdateWithoutKeyboardInput>
  }

  export type LayoutUpdateOneRequiredWithoutKeyboardNestedInput = {
    create?: XOR<LayoutCreateWithoutKeyboardInput, LayoutUncheckedCreateWithoutKeyboardInput>
    connectOrCreate?: LayoutCreateOrConnectWithoutKeyboardInput
    upsert?: LayoutUpsertWithoutKeyboardInput
    connect?: LayoutWhereUniqueInput
    update?: XOR<XOR<LayoutUpdateToOneWithWhereWithoutKeyboardInput, LayoutUpdateWithoutKeyboardInput>, LayoutUncheckedUpdateWithoutKeyboardInput>
  }

  export type ConnectionTypeUpdateOneRequiredWithoutKeyboardNestedInput = {
    create?: XOR<ConnectionTypeCreateWithoutKeyboardInput, ConnectionTypeUncheckedCreateWithoutKeyboardInput>
    connectOrCreate?: ConnectionTypeCreateOrConnectWithoutKeyboardInput
    upsert?: ConnectionTypeUpsertWithoutKeyboardInput
    connect?: ConnectionTypeWhereUniqueInput
    update?: XOR<XOR<ConnectionTypeUpdateToOneWithWhereWithoutKeyboardInput, ConnectionTypeUpdateWithoutKeyboardInput>, ConnectionTypeUncheckedUpdateWithoutKeyboardInput>
  }

  export type ColorUpdateManyWithoutKeyboardNestedInput = {
    create?: XOR<ColorCreateWithoutKeyboardInput, ColorUncheckedCreateWithoutKeyboardInput> | ColorCreateWithoutKeyboardInput[] | ColorUncheckedCreateWithoutKeyboardInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutKeyboardInput | ColorCreateOrConnectWithoutKeyboardInput[]
    upsert?: ColorUpsertWithWhereUniqueWithoutKeyboardInput | ColorUpsertWithWhereUniqueWithoutKeyboardInput[]
    createMany?: ColorCreateManyKeyboardInputEnvelope
    set?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    disconnect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    delete?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    update?: ColorUpdateWithWhereUniqueWithoutKeyboardInput | ColorUpdateWithWhereUniqueWithoutKeyboardInput[]
    updateMany?: ColorUpdateManyWithWhereWithoutKeyboardInput | ColorUpdateManyWithWhereWithoutKeyboardInput[]
    deleteMany?: ColorScalarWhereInput | ColorScalarWhereInput[]
  }

  export type ColorUncheckedUpdateManyWithoutKeyboardNestedInput = {
    create?: XOR<ColorCreateWithoutKeyboardInput, ColorUncheckedCreateWithoutKeyboardInput> | ColorCreateWithoutKeyboardInput[] | ColorUncheckedCreateWithoutKeyboardInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutKeyboardInput | ColorCreateOrConnectWithoutKeyboardInput[]
    upsert?: ColorUpsertWithWhereUniqueWithoutKeyboardInput | ColorUpsertWithWhereUniqueWithoutKeyboardInput[]
    createMany?: ColorCreateManyKeyboardInputEnvelope
    set?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    disconnect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    delete?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    update?: ColorUpdateWithWhereUniqueWithoutKeyboardInput | ColorUpdateWithWhereUniqueWithoutKeyboardInput[]
    updateMany?: ColorUpdateManyWithWhereWithoutKeyboardInput | ColorUpdateManyWithWhereWithoutKeyboardInput[]
    deleteMany?: ColorScalarWhereInput | ColorScalarWhereInput[]
  }

  export type KeyboardCreateNestedManyWithoutLayoutInput = {
    create?: XOR<KeyboardCreateWithoutLayoutInput, KeyboardUncheckedCreateWithoutLayoutInput> | KeyboardCreateWithoutLayoutInput[] | KeyboardUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutLayoutInput | KeyboardCreateOrConnectWithoutLayoutInput[]
    createMany?: KeyboardCreateManyLayoutInputEnvelope
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
  }

  export type KeyboardUncheckedCreateNestedManyWithoutLayoutInput = {
    create?: XOR<KeyboardCreateWithoutLayoutInput, KeyboardUncheckedCreateWithoutLayoutInput> | KeyboardCreateWithoutLayoutInput[] | KeyboardUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutLayoutInput | KeyboardCreateOrConnectWithoutLayoutInput[]
    createMany?: KeyboardCreateManyLayoutInputEnvelope
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
  }

  export type KeyboardUpdateManyWithoutLayoutNestedInput = {
    create?: XOR<KeyboardCreateWithoutLayoutInput, KeyboardUncheckedCreateWithoutLayoutInput> | KeyboardCreateWithoutLayoutInput[] | KeyboardUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutLayoutInput | KeyboardCreateOrConnectWithoutLayoutInput[]
    upsert?: KeyboardUpsertWithWhereUniqueWithoutLayoutInput | KeyboardUpsertWithWhereUniqueWithoutLayoutInput[]
    createMany?: KeyboardCreateManyLayoutInputEnvelope
    set?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    disconnect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    delete?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    update?: KeyboardUpdateWithWhereUniqueWithoutLayoutInput | KeyboardUpdateWithWhereUniqueWithoutLayoutInput[]
    updateMany?: KeyboardUpdateManyWithWhereWithoutLayoutInput | KeyboardUpdateManyWithWhereWithoutLayoutInput[]
    deleteMany?: KeyboardScalarWhereInput | KeyboardScalarWhereInput[]
  }

  export type KeyboardUncheckedUpdateManyWithoutLayoutNestedInput = {
    create?: XOR<KeyboardCreateWithoutLayoutInput, KeyboardUncheckedCreateWithoutLayoutInput> | KeyboardCreateWithoutLayoutInput[] | KeyboardUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutLayoutInput | KeyboardCreateOrConnectWithoutLayoutInput[]
    upsert?: KeyboardUpsertWithWhereUniqueWithoutLayoutInput | KeyboardUpsertWithWhereUniqueWithoutLayoutInput[]
    createMany?: KeyboardCreateManyLayoutInputEnvelope
    set?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    disconnect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    delete?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    update?: KeyboardUpdateWithWhereUniqueWithoutLayoutInput | KeyboardUpdateWithWhereUniqueWithoutLayoutInput[]
    updateMany?: KeyboardUpdateManyWithWhereWithoutLayoutInput | KeyboardUpdateManyWithWhereWithoutLayoutInput[]
    deleteMany?: KeyboardScalarWhereInput | KeyboardScalarWhereInput[]
  }

  export type KeyboardCreateNestedManyWithoutConnectionTypeInput = {
    create?: XOR<KeyboardCreateWithoutConnectionTypeInput, KeyboardUncheckedCreateWithoutConnectionTypeInput> | KeyboardCreateWithoutConnectionTypeInput[] | KeyboardUncheckedCreateWithoutConnectionTypeInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutConnectionTypeInput | KeyboardCreateOrConnectWithoutConnectionTypeInput[]
    createMany?: KeyboardCreateManyConnectionTypeInputEnvelope
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
  }

  export type KeyboardUncheckedCreateNestedManyWithoutConnectionTypeInput = {
    create?: XOR<KeyboardCreateWithoutConnectionTypeInput, KeyboardUncheckedCreateWithoutConnectionTypeInput> | KeyboardCreateWithoutConnectionTypeInput[] | KeyboardUncheckedCreateWithoutConnectionTypeInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutConnectionTypeInput | KeyboardCreateOrConnectWithoutConnectionTypeInput[]
    createMany?: KeyboardCreateManyConnectionTypeInputEnvelope
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
  }

  export type KeyboardUpdateManyWithoutConnectionTypeNestedInput = {
    create?: XOR<KeyboardCreateWithoutConnectionTypeInput, KeyboardUncheckedCreateWithoutConnectionTypeInput> | KeyboardCreateWithoutConnectionTypeInput[] | KeyboardUncheckedCreateWithoutConnectionTypeInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutConnectionTypeInput | KeyboardCreateOrConnectWithoutConnectionTypeInput[]
    upsert?: KeyboardUpsertWithWhereUniqueWithoutConnectionTypeInput | KeyboardUpsertWithWhereUniqueWithoutConnectionTypeInput[]
    createMany?: KeyboardCreateManyConnectionTypeInputEnvelope
    set?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    disconnect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    delete?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    update?: KeyboardUpdateWithWhereUniqueWithoutConnectionTypeInput | KeyboardUpdateWithWhereUniqueWithoutConnectionTypeInput[]
    updateMany?: KeyboardUpdateManyWithWhereWithoutConnectionTypeInput | KeyboardUpdateManyWithWhereWithoutConnectionTypeInput[]
    deleteMany?: KeyboardScalarWhereInput | KeyboardScalarWhereInput[]
  }

  export type KeyboardUncheckedUpdateManyWithoutConnectionTypeNestedInput = {
    create?: XOR<KeyboardCreateWithoutConnectionTypeInput, KeyboardUncheckedCreateWithoutConnectionTypeInput> | KeyboardCreateWithoutConnectionTypeInput[] | KeyboardUncheckedCreateWithoutConnectionTypeInput[]
    connectOrCreate?: KeyboardCreateOrConnectWithoutConnectionTypeInput | KeyboardCreateOrConnectWithoutConnectionTypeInput[]
    upsert?: KeyboardUpsertWithWhereUniqueWithoutConnectionTypeInput | KeyboardUpsertWithWhereUniqueWithoutConnectionTypeInput[]
    createMany?: KeyboardCreateManyConnectionTypeInputEnvelope
    set?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    disconnect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    delete?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    connect?: KeyboardWhereUniqueInput | KeyboardWhereUniqueInput[]
    update?: KeyboardUpdateWithWhereUniqueWithoutConnectionTypeInput | KeyboardUpdateWithWhereUniqueWithoutConnectionTypeInput[]
    updateMany?: KeyboardUpdateManyWithWhereWithoutConnectionTypeInput | KeyboardUpdateManyWithWhereWithoutConnectionTypeInput[]
    deleteMany?: KeyboardScalarWhereInput | KeyboardScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSwitchInput = {
    create?: XOR<ProductCreateWithoutSwitchInput, ProductUncheckedCreateWithoutSwitchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSwitchInput
    connect?: ProductWhereUniqueInput
  }

  export type SwitchTypeCreateNestedOneWithoutSwitchInput = {
    create?: XOR<SwitchTypeCreateWithoutSwitchInput, SwitchTypeUncheckedCreateWithoutSwitchInput>
    connectOrCreate?: SwitchTypeCreateOrConnectWithoutSwitchInput
    connect?: SwitchTypeWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSwitchNestedInput = {
    create?: XOR<ProductCreateWithoutSwitchInput, ProductUncheckedCreateWithoutSwitchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSwitchInput
    upsert?: ProductUpsertWithoutSwitchInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSwitchInput, ProductUpdateWithoutSwitchInput>, ProductUncheckedUpdateWithoutSwitchInput>
  }

  export type SwitchTypeUpdateOneRequiredWithoutSwitchNestedInput = {
    create?: XOR<SwitchTypeCreateWithoutSwitchInput, SwitchTypeUncheckedCreateWithoutSwitchInput>
    connectOrCreate?: SwitchTypeCreateOrConnectWithoutSwitchInput
    upsert?: SwitchTypeUpsertWithoutSwitchInput
    connect?: SwitchTypeWhereUniqueInput
    update?: XOR<XOR<SwitchTypeUpdateToOneWithWhereWithoutSwitchInput, SwitchTypeUpdateWithoutSwitchInput>, SwitchTypeUncheckedUpdateWithoutSwitchInput>
  }

  export type SwitchCreateNestedManyWithoutSwitchTypeInput = {
    create?: XOR<SwitchCreateWithoutSwitchTypeInput, SwitchUncheckedCreateWithoutSwitchTypeInput> | SwitchCreateWithoutSwitchTypeInput[] | SwitchUncheckedCreateWithoutSwitchTypeInput[]
    connectOrCreate?: SwitchCreateOrConnectWithoutSwitchTypeInput | SwitchCreateOrConnectWithoutSwitchTypeInput[]
    createMany?: SwitchCreateManySwitchTypeInputEnvelope
    connect?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
  }

  export type SwitchUncheckedCreateNestedManyWithoutSwitchTypeInput = {
    create?: XOR<SwitchCreateWithoutSwitchTypeInput, SwitchUncheckedCreateWithoutSwitchTypeInput> | SwitchCreateWithoutSwitchTypeInput[] | SwitchUncheckedCreateWithoutSwitchTypeInput[]
    connectOrCreate?: SwitchCreateOrConnectWithoutSwitchTypeInput | SwitchCreateOrConnectWithoutSwitchTypeInput[]
    createMany?: SwitchCreateManySwitchTypeInputEnvelope
    connect?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
  }

  export type SwitchUpdateManyWithoutSwitchTypeNestedInput = {
    create?: XOR<SwitchCreateWithoutSwitchTypeInput, SwitchUncheckedCreateWithoutSwitchTypeInput> | SwitchCreateWithoutSwitchTypeInput[] | SwitchUncheckedCreateWithoutSwitchTypeInput[]
    connectOrCreate?: SwitchCreateOrConnectWithoutSwitchTypeInput | SwitchCreateOrConnectWithoutSwitchTypeInput[]
    upsert?: SwitchUpsertWithWhereUniqueWithoutSwitchTypeInput | SwitchUpsertWithWhereUniqueWithoutSwitchTypeInput[]
    createMany?: SwitchCreateManySwitchTypeInputEnvelope
    set?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    disconnect?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    delete?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    connect?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    update?: SwitchUpdateWithWhereUniqueWithoutSwitchTypeInput | SwitchUpdateWithWhereUniqueWithoutSwitchTypeInput[]
    updateMany?: SwitchUpdateManyWithWhereWithoutSwitchTypeInput | SwitchUpdateManyWithWhereWithoutSwitchTypeInput[]
    deleteMany?: SwitchScalarWhereInput | SwitchScalarWhereInput[]
  }

  export type SwitchUncheckedUpdateManyWithoutSwitchTypeNestedInput = {
    create?: XOR<SwitchCreateWithoutSwitchTypeInput, SwitchUncheckedCreateWithoutSwitchTypeInput> | SwitchCreateWithoutSwitchTypeInput[] | SwitchUncheckedCreateWithoutSwitchTypeInput[]
    connectOrCreate?: SwitchCreateOrConnectWithoutSwitchTypeInput | SwitchCreateOrConnectWithoutSwitchTypeInput[]
    upsert?: SwitchUpsertWithWhereUniqueWithoutSwitchTypeInput | SwitchUpsertWithWhereUniqueWithoutSwitchTypeInput[]
    createMany?: SwitchCreateManySwitchTypeInputEnvelope
    set?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    disconnect?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    delete?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    connect?: SwitchWhereUniqueInput | SwitchWhereUniqueInput[]
    update?: SwitchUpdateWithWhereUniqueWithoutSwitchTypeInput | SwitchUpdateWithWhereUniqueWithoutSwitchTypeInput[]
    updateMany?: SwitchUpdateManyWithWhereWithoutSwitchTypeInput | SwitchUpdateManyWithWhereWithoutSwitchTypeInput[]
    deleteMany?: SwitchScalarWhereInput | SwitchScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutKeycapInput = {
    create?: XOR<ProductCreateWithoutKeycapInput, ProductUncheckedCreateWithoutKeycapInput>
    connectOrCreate?: ProductCreateOrConnectWithoutKeycapInput
    connect?: ProductWhereUniqueInput
  }

  export type KeycapProfileCreateNestedOneWithoutKeycapInput = {
    create?: XOR<KeycapProfileCreateWithoutKeycapInput, KeycapProfileUncheckedCreateWithoutKeycapInput>
    connectOrCreate?: KeycapProfileCreateOrConnectWithoutKeycapInput
    connect?: KeycapProfileWhereUniqueInput
  }

  export type KeycapMaterialCreateNestedOneWithoutKeycapInput = {
    create?: XOR<KeycapMaterialCreateWithoutKeycapInput, KeycapMaterialUncheckedCreateWithoutKeycapInput>
    connectOrCreate?: KeycapMaterialCreateOrConnectWithoutKeycapInput
    connect?: KeycapMaterialWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutKeycapNestedInput = {
    create?: XOR<ProductCreateWithoutKeycapInput, ProductUncheckedCreateWithoutKeycapInput>
    connectOrCreate?: ProductCreateOrConnectWithoutKeycapInput
    upsert?: ProductUpsertWithoutKeycapInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutKeycapInput, ProductUpdateWithoutKeycapInput>, ProductUncheckedUpdateWithoutKeycapInput>
  }

  export type KeycapProfileUpdateOneRequiredWithoutKeycapNestedInput = {
    create?: XOR<KeycapProfileCreateWithoutKeycapInput, KeycapProfileUncheckedCreateWithoutKeycapInput>
    connectOrCreate?: KeycapProfileCreateOrConnectWithoutKeycapInput
    upsert?: KeycapProfileUpsertWithoutKeycapInput
    connect?: KeycapProfileWhereUniqueInput
    update?: XOR<XOR<KeycapProfileUpdateToOneWithWhereWithoutKeycapInput, KeycapProfileUpdateWithoutKeycapInput>, KeycapProfileUncheckedUpdateWithoutKeycapInput>
  }

  export type KeycapMaterialUpdateOneRequiredWithoutKeycapNestedInput = {
    create?: XOR<KeycapMaterialCreateWithoutKeycapInput, KeycapMaterialUncheckedCreateWithoutKeycapInput>
    connectOrCreate?: KeycapMaterialCreateOrConnectWithoutKeycapInput
    upsert?: KeycapMaterialUpsertWithoutKeycapInput
    connect?: KeycapMaterialWhereUniqueInput
    update?: XOR<XOR<KeycapMaterialUpdateToOneWithWhereWithoutKeycapInput, KeycapMaterialUpdateWithoutKeycapInput>, KeycapMaterialUncheckedUpdateWithoutKeycapInput>
  }

  export type KeycapCreateNestedManyWithoutProfileInput = {
    create?: XOR<KeycapCreateWithoutProfileInput, KeycapUncheckedCreateWithoutProfileInput> | KeycapCreateWithoutProfileInput[] | KeycapUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutProfileInput | KeycapCreateOrConnectWithoutProfileInput[]
    createMany?: KeycapCreateManyProfileInputEnvelope
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
  }

  export type KeycapUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<KeycapCreateWithoutProfileInput, KeycapUncheckedCreateWithoutProfileInput> | KeycapCreateWithoutProfileInput[] | KeycapUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutProfileInput | KeycapCreateOrConnectWithoutProfileInput[]
    createMany?: KeycapCreateManyProfileInputEnvelope
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
  }

  export type KeycapUpdateManyWithoutProfileNestedInput = {
    create?: XOR<KeycapCreateWithoutProfileInput, KeycapUncheckedCreateWithoutProfileInput> | KeycapCreateWithoutProfileInput[] | KeycapUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutProfileInput | KeycapCreateOrConnectWithoutProfileInput[]
    upsert?: KeycapUpsertWithWhereUniqueWithoutProfileInput | KeycapUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: KeycapCreateManyProfileInputEnvelope
    set?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    disconnect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    delete?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    update?: KeycapUpdateWithWhereUniqueWithoutProfileInput | KeycapUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: KeycapUpdateManyWithWhereWithoutProfileInput | KeycapUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: KeycapScalarWhereInput | KeycapScalarWhereInput[]
  }

  export type KeycapUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<KeycapCreateWithoutProfileInput, KeycapUncheckedCreateWithoutProfileInput> | KeycapCreateWithoutProfileInput[] | KeycapUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutProfileInput | KeycapCreateOrConnectWithoutProfileInput[]
    upsert?: KeycapUpsertWithWhereUniqueWithoutProfileInput | KeycapUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: KeycapCreateManyProfileInputEnvelope
    set?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    disconnect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    delete?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    update?: KeycapUpdateWithWhereUniqueWithoutProfileInput | KeycapUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: KeycapUpdateManyWithWhereWithoutProfileInput | KeycapUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: KeycapScalarWhereInput | KeycapScalarWhereInput[]
  }

  export type KeycapCreateNestedManyWithoutMaterialInput = {
    create?: XOR<KeycapCreateWithoutMaterialInput, KeycapUncheckedCreateWithoutMaterialInput> | KeycapCreateWithoutMaterialInput[] | KeycapUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutMaterialInput | KeycapCreateOrConnectWithoutMaterialInput[]
    createMany?: KeycapCreateManyMaterialInputEnvelope
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
  }

  export type KeycapUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<KeycapCreateWithoutMaterialInput, KeycapUncheckedCreateWithoutMaterialInput> | KeycapCreateWithoutMaterialInput[] | KeycapUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutMaterialInput | KeycapCreateOrConnectWithoutMaterialInput[]
    createMany?: KeycapCreateManyMaterialInputEnvelope
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
  }

  export type KeycapUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<KeycapCreateWithoutMaterialInput, KeycapUncheckedCreateWithoutMaterialInput> | KeycapCreateWithoutMaterialInput[] | KeycapUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutMaterialInput | KeycapCreateOrConnectWithoutMaterialInput[]
    upsert?: KeycapUpsertWithWhereUniqueWithoutMaterialInput | KeycapUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: KeycapCreateManyMaterialInputEnvelope
    set?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    disconnect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    delete?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    update?: KeycapUpdateWithWhereUniqueWithoutMaterialInput | KeycapUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: KeycapUpdateManyWithWhereWithoutMaterialInput | KeycapUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: KeycapScalarWhereInput | KeycapScalarWhereInput[]
  }

  export type KeycapUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<KeycapCreateWithoutMaterialInput, KeycapUncheckedCreateWithoutMaterialInput> | KeycapCreateWithoutMaterialInput[] | KeycapUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: KeycapCreateOrConnectWithoutMaterialInput | KeycapCreateOrConnectWithoutMaterialInput[]
    upsert?: KeycapUpsertWithWhereUniqueWithoutMaterialInput | KeycapUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: KeycapCreateManyMaterialInputEnvelope
    set?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    disconnect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    delete?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    connect?: KeycapWhereUniqueInput | KeycapWhereUniqueInput[]
    update?: KeycapUpdateWithWhereUniqueWithoutMaterialInput | KeycapUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: KeycapUpdateManyWithWhereWithoutMaterialInput | KeycapUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: KeycapScalarWhereInput | KeycapScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutAccessoryInput = {
    create?: XOR<ProductCreateWithoutAccessoryInput, ProductUncheckedCreateWithoutAccessoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAccessoryInput
    connect?: ProductWhereUniqueInput
  }

  export type AccessoryTypeCreateNestedOneWithoutAccessoryInput = {
    create?: XOR<AccessoryTypeCreateWithoutAccessoryInput, AccessoryTypeUncheckedCreateWithoutAccessoryInput>
    connectOrCreate?: AccessoryTypeCreateOrConnectWithoutAccessoryInput
    connect?: AccessoryTypeWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutAccessoryNestedInput = {
    create?: XOR<ProductCreateWithoutAccessoryInput, ProductUncheckedCreateWithoutAccessoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAccessoryInput
    upsert?: ProductUpsertWithoutAccessoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAccessoryInput, ProductUpdateWithoutAccessoryInput>, ProductUncheckedUpdateWithoutAccessoryInput>
  }

  export type AccessoryTypeUpdateOneRequiredWithoutAccessoryNestedInput = {
    create?: XOR<AccessoryTypeCreateWithoutAccessoryInput, AccessoryTypeUncheckedCreateWithoutAccessoryInput>
    connectOrCreate?: AccessoryTypeCreateOrConnectWithoutAccessoryInput
    upsert?: AccessoryTypeUpsertWithoutAccessoryInput
    connect?: AccessoryTypeWhereUniqueInput
    update?: XOR<XOR<AccessoryTypeUpdateToOneWithWhereWithoutAccessoryInput, AccessoryTypeUpdateWithoutAccessoryInput>, AccessoryTypeUncheckedUpdateWithoutAccessoryInput>
  }

  export type AccessoryCreateNestedManyWithoutTypeInput = {
    create?: XOR<AccessoryCreateWithoutTypeInput, AccessoryUncheckedCreateWithoutTypeInput> | AccessoryCreateWithoutTypeInput[] | AccessoryUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AccessoryCreateOrConnectWithoutTypeInput | AccessoryCreateOrConnectWithoutTypeInput[]
    createMany?: AccessoryCreateManyTypeInputEnvelope
    connect?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
  }

  export type AccessoryUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<AccessoryCreateWithoutTypeInput, AccessoryUncheckedCreateWithoutTypeInput> | AccessoryCreateWithoutTypeInput[] | AccessoryUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AccessoryCreateOrConnectWithoutTypeInput | AccessoryCreateOrConnectWithoutTypeInput[]
    createMany?: AccessoryCreateManyTypeInputEnvelope
    connect?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
  }

  export type AccessoryUpdateManyWithoutTypeNestedInput = {
    create?: XOR<AccessoryCreateWithoutTypeInput, AccessoryUncheckedCreateWithoutTypeInput> | AccessoryCreateWithoutTypeInput[] | AccessoryUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AccessoryCreateOrConnectWithoutTypeInput | AccessoryCreateOrConnectWithoutTypeInput[]
    upsert?: AccessoryUpsertWithWhereUniqueWithoutTypeInput | AccessoryUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: AccessoryCreateManyTypeInputEnvelope
    set?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    disconnect?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    delete?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    connect?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    update?: AccessoryUpdateWithWhereUniqueWithoutTypeInput | AccessoryUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: AccessoryUpdateManyWithWhereWithoutTypeInput | AccessoryUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: AccessoryScalarWhereInput | AccessoryScalarWhereInput[]
  }

  export type AccessoryUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<AccessoryCreateWithoutTypeInput, AccessoryUncheckedCreateWithoutTypeInput> | AccessoryCreateWithoutTypeInput[] | AccessoryUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: AccessoryCreateOrConnectWithoutTypeInput | AccessoryCreateOrConnectWithoutTypeInput[]
    upsert?: AccessoryUpsertWithWhereUniqueWithoutTypeInput | AccessoryUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: AccessoryCreateManyTypeInputEnvelope
    set?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    disconnect?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    delete?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    connect?: AccessoryWhereUniqueInput | AccessoryWhereUniqueInput[]
    update?: AccessoryUpdateWithWhereUniqueWithoutTypeInput | AccessoryUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: AccessoryUpdateManyWithWhereWithoutTypeInput | AccessoryUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: AccessoryScalarWhereInput | AccessoryScalarWhereInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCategoryInput | ProductCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCategoryInput | ProductCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductCategoryInput = {
    create?: XOR<CategoryCreateWithoutProductCategoryInput, CategoryUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductCategoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput
    upsert?: ProductUpsertWithoutProductCategoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductCategoryInput, ProductUpdateWithoutProductCategoryInput>, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type CategoryUpdateOneRequiredWithoutProductCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutProductCategoryInput, CategoryUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductCategoryInput
    upsert?: CategoryUpsertWithoutProductCategoryInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductCategoryInput, CategoryUpdateWithoutProductCategoryInput>, CategoryUncheckedUpdateWithoutProductCategoryInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type WishlistCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type BillCreateNestedManyWithoutUserInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type UserCouponCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type UserBuildCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput> | UserBuildCreateWithoutUserInput[] | UserBuildUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBuildCreateOrConnectWithoutUserInput | UserBuildCreateOrConnectWithoutUserInput[]
    createMany?: UserBuildCreateManyUserInputEnvelope
    connect?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type WishlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type UserCouponUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type UserBuildUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput> | UserBuildCreateWithoutUserInput[] | UserBuildUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBuildCreateOrConnectWithoutUserInput | UserBuildCreateOrConnectWithoutUserInput[]
    createMany?: UserBuildCreateManyUserInputEnvelope
    connect?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type WishlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type BillUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutUserInput | BillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutUserInput | BillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillUpdateManyWithWhereWithoutUserInput | BillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type UserCouponUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutUserInput | UserCouponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutUserInput | UserCouponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutUserInput | UserCouponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type UserBuildUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput> | UserBuildCreateWithoutUserInput[] | UserBuildUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBuildCreateOrConnectWithoutUserInput | UserBuildCreateOrConnectWithoutUserInput[]
    upsert?: UserBuildUpsertWithWhereUniqueWithoutUserInput | UserBuildUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBuildCreateManyUserInputEnvelope
    set?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    disconnect?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    delete?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    connect?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    update?: UserBuildUpdateWithWhereUniqueWithoutUserInput | UserBuildUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBuildUpdateManyWithWhereWithoutUserInput | UserBuildUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBuildScalarWhereInput | UserBuildScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type WishlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutUserInput | BillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutUserInput | BillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillUpdateManyWithWhereWithoutUserInput | BillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type UserCouponUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput> | UserCouponCreateWithoutUserInput[] | UserCouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutUserInput | UserCouponCreateOrConnectWithoutUserInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutUserInput | UserCouponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCouponCreateManyUserInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutUserInput | UserCouponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutUserInput | UserCouponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type UserBuildUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput> | UserBuildCreateWithoutUserInput[] | UserBuildUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBuildCreateOrConnectWithoutUserInput | UserBuildCreateOrConnectWithoutUserInput[]
    upsert?: UserBuildUpsertWithWhereUniqueWithoutUserInput | UserBuildUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBuildCreateManyUserInputEnvelope
    set?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    disconnect?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    delete?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    connect?: UserBuildWhereUniqueInput | UserBuildWhereUniqueInput[]
    update?: UserBuildUpdateWithWhereUniqueWithoutUserInput | UserBuildUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBuildUpdateManyWithWhereWithoutUserInput | UserBuildUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBuildScalarWhereInput | UserBuildScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    upsert?: UserUpsertWithoutCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>, UserUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutCartItemInput = {
    create?: XOR<CartCreateWithoutCartItemInput, CartUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: CartCreateOrConnectWithoutCartItemInput
    connect?: CartWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<CartCreateWithoutCartItemInput, CartUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: CartCreateOrConnectWithoutCartItemInput
    upsert?: CartUpsertWithoutCartItemInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutCartItemInput, CartUpdateWithoutCartItemInput>, CartUncheckedUpdateWithoutCartItemInput>
  }

  export type UserCreateNestedOneWithoutWishlistInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    connect?: UserWhereUniqueInput
  }

  export type WishlistItemCreateNestedManyWithoutWishlistInput = {
    create?: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput> | WishlistItemCreateWithoutWishlistInput[] | WishlistItemUncheckedCreateWithoutWishlistInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutWishlistInput | WishlistItemCreateOrConnectWithoutWishlistInput[]
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutWishlistInput = {
    create?: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput> | WishlistItemCreateWithoutWishlistInput[] | WishlistItemUncheckedCreateWithoutWishlistInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutWishlistInput | WishlistItemCreateOrConnectWithoutWishlistInput[]
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    upsert?: UserUpsertWithoutWishlistInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistInput, UserUpdateWithoutWishlistInput>, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type WishlistItemUpdateManyWithoutWishlistNestedInput = {
    create?: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput> | WishlistItemCreateWithoutWishlistInput[] | WishlistItemUncheckedCreateWithoutWishlistInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutWishlistInput | WishlistItemCreateOrConnectWithoutWishlistInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutWishlistInput | WishlistItemUpsertWithWhereUniqueWithoutWishlistInput[]
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutWishlistInput | WishlistItemUpdateWithWhereUniqueWithoutWishlistInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutWishlistInput | WishlistItemUpdateManyWithWhereWithoutWishlistInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput = {
    create?: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput> | WishlistItemCreateWithoutWishlistInput[] | WishlistItemUncheckedCreateWithoutWishlistInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutWishlistInput | WishlistItemCreateOrConnectWithoutWishlistInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutWishlistInput | WishlistItemUpsertWithWhereUniqueWithoutWishlistInput[]
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutWishlistInput | WishlistItemUpdateWithWhereUniqueWithoutWishlistInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutWishlistInput | WishlistItemUpdateManyWithWhereWithoutWishlistInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type WishlistCreateNestedOneWithoutWishlistItemInput = {
    create?: XOR<WishlistCreateWithoutWishlistItemInput, WishlistUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: WishlistCreateOrConnectWithoutWishlistItemInput
    connect?: WishlistWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutWishlistItemInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput
    connect?: ProductWhereUniqueInput
  }

  export type WishlistUpdateOneRequiredWithoutWishlistItemNestedInput = {
    create?: XOR<WishlistCreateWithoutWishlistItemInput, WishlistUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: WishlistCreateOrConnectWithoutWishlistItemInput
    upsert?: WishlistUpsertWithoutWishlistItemInput
    connect?: WishlistWhereUniqueInput
    update?: XOR<XOR<WishlistUpdateToOneWithWhereWithoutWishlistItemInput, WishlistUpdateWithoutWishlistItemInput>, WishlistUncheckedUpdateWithoutWishlistItemInput>
  }

  export type ProductUpdateOneRequiredWithoutWishlistItemNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput
    upsert?: ProductUpsertWithoutWishlistItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWishlistItemInput, ProductUpdateWithoutWishlistItemInput>, ProductUncheckedUpdateWithoutWishlistItemInput>
  }

  export type UserCreateNestedOneWithoutBillInput = {
    create?: XOR<UserCreateWithoutBillInput, UserUncheckedCreateWithoutBillInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillInput
    connect?: UserWhereUniqueInput
  }

  export type BillItemCreateNestedManyWithoutBillInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutBillInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BillItemUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumBillStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillStatus
  }

  export type UserUpdateOneRequiredWithoutBillNestedInput = {
    create?: XOR<UserCreateWithoutBillInput, UserUncheckedCreateWithoutBillInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillInput
    upsert?: UserUpsertWithoutBillInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBillInput, UserUpdateWithoutBillInput>, UserUncheckedUpdateWithoutBillInput>
  }

  export type BillItemUpdateManyWithoutBillNestedInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    upsert?: BillItemUpsertWithWhereUniqueWithoutBillInput | BillItemUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    set?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    disconnect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    delete?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    update?: BillItemUpdateWithWhereUniqueWithoutBillInput | BillItemUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: BillItemUpdateManyWithWhereWithoutBillInput | BillItemUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutBillNestedInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBillInput | TransactionUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBillInput | TransactionUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBillInput | TransactionUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BillItemUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput> | BillItemCreateWithoutBillInput[] | BillItemUncheckedCreateWithoutBillInput[]
    connectOrCreate?: BillItemCreateOrConnectWithoutBillInput | BillItemCreateOrConnectWithoutBillInput[]
    upsert?: BillItemUpsertWithWhereUniqueWithoutBillInput | BillItemUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: BillItemCreateManyBillInputEnvelope
    set?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    disconnect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    delete?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    connect?: BillItemWhereUniqueInput | BillItemWhereUniqueInput[]
    update?: BillItemUpdateWithWhereUniqueWithoutBillInput | BillItemUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: BillItemUpdateManyWithWhereWithoutBillInput | BillItemUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBillInput | TransactionUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBillInput | TransactionUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBillInput | TransactionUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BillCreateNestedOneWithoutBillItemInput = {
    create?: XOR<BillCreateWithoutBillItemInput, BillUncheckedCreateWithoutBillItemInput>
    connectOrCreate?: BillCreateOrConnectWithoutBillItemInput
    connect?: BillWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBillItemInput = {
    create?: XOR<ProductCreateWithoutBillItemInput, ProductUncheckedCreateWithoutBillItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBillItemInput
    connect?: ProductWhereUniqueInput
  }

  export type BillUpdateOneRequiredWithoutBillItemNestedInput = {
    create?: XOR<BillCreateWithoutBillItemInput, BillUncheckedCreateWithoutBillItemInput>
    connectOrCreate?: BillCreateOrConnectWithoutBillItemInput
    upsert?: BillUpsertWithoutBillItemInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutBillItemInput, BillUpdateWithoutBillItemInput>, BillUncheckedUpdateWithoutBillItemInput>
  }

  export type ProductUpdateOneRequiredWithoutBillItemNestedInput = {
    create?: XOR<ProductCreateWithoutBillItemInput, ProductUncheckedCreateWithoutBillItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBillItemInput
    upsert?: ProductUpsertWithoutBillItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBillItemInput, ProductUpdateWithoutBillItemInput>, ProductUncheckedUpdateWithoutBillItemInput>
  }

  export type BillCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BillCreateWithoutTransactionInput, BillUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BillCreateOrConnectWithoutTransactionInput
    connect?: BillWhereUniqueInput
  }

  export type EnumTransactionMethodFieldUpdateOperationsInput = {
    set?: $Enums.TransactionMethod
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type BillUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<BillCreateWithoutTransactionInput, BillUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BillCreateOrConnectWithoutTransactionInput
    upsert?: BillUpsertWithoutTransactionInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutTransactionInput, BillUpdateWithoutTransactionInput>, BillUncheckedUpdateWithoutTransactionInput>
  }

  export type UserCouponCreateNestedManyWithoutCouponInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type UserCouponUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
  }

  export type UserCouponUpdateManyWithoutCouponNestedInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutCouponInput | UserCouponUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutCouponInput | UserCouponUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutCouponInput | UserCouponUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type UserCouponUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput> | UserCouponCreateWithoutCouponInput[] | UserCouponUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserCouponCreateOrConnectWithoutCouponInput | UserCouponCreateOrConnectWithoutCouponInput[]
    upsert?: UserCouponUpsertWithWhereUniqueWithoutCouponInput | UserCouponUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: UserCouponCreateManyCouponInputEnvelope
    set?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    disconnect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    delete?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    connect?: UserCouponWhereUniqueInput | UserCouponWhereUniqueInput[]
    update?: UserCouponUpdateWithWhereUniqueWithoutCouponInput | UserCouponUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: UserCouponUpdateManyWithWhereWithoutCouponInput | UserCouponUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
  }

  export type CouponCreateNestedOneWithoutUserCouponInput = {
    create?: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
    connectOrCreate?: CouponCreateOrConnectWithoutUserCouponInput
    connect?: CouponWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserCouponInput = {
    create?: XOR<UserCreateWithoutUserCouponInput, UserUncheckedCreateWithoutUserCouponInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCouponInput
    connect?: UserWhereUniqueInput
  }

  export type CouponUpdateOneRequiredWithoutUserCouponNestedInput = {
    create?: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
    connectOrCreate?: CouponCreateOrConnectWithoutUserCouponInput
    upsert?: CouponUpsertWithoutUserCouponInput
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutUserCouponInput, CouponUpdateWithoutUserCouponInput>, CouponUncheckedUpdateWithoutUserCouponInput>
  }

  export type UserUpdateOneRequiredWithoutUserCouponNestedInput = {
    create?: XOR<UserCreateWithoutUserCouponInput, UserUncheckedCreateWithoutUserCouponInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCouponInput
    upsert?: UserUpsertWithoutUserCouponInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCouponInput, UserUpdateWithoutUserCouponInput>, UserUncheckedUpdateWithoutUserCouponInput>
  }

  export type UserCreateNestedOneWithoutUserBuildInput = {
    create?: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBuildInput
    connect?: UserWhereUniqueInput
  }

  export type UserBuildComponentCreateNestedManyWithoutUserBuildInput = {
    create?: XOR<UserBuildComponentCreateWithoutUserBuildInput, UserBuildComponentUncheckedCreateWithoutUserBuildInput> | UserBuildComponentCreateWithoutUserBuildInput[] | UserBuildComponentUncheckedCreateWithoutUserBuildInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutUserBuildInput | UserBuildComponentCreateOrConnectWithoutUserBuildInput[]
    createMany?: UserBuildComponentCreateManyUserBuildInputEnvelope
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
  }

  export type UserBuildComponentUncheckedCreateNestedManyWithoutUserBuildInput = {
    create?: XOR<UserBuildComponentCreateWithoutUserBuildInput, UserBuildComponentUncheckedCreateWithoutUserBuildInput> | UserBuildComponentCreateWithoutUserBuildInput[] | UserBuildComponentUncheckedCreateWithoutUserBuildInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutUserBuildInput | UserBuildComponentCreateOrConnectWithoutUserBuildInput[]
    createMany?: UserBuildComponentCreateManyUserBuildInputEnvelope
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserBuildNestedInput = {
    create?: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBuildInput
    upsert?: UserUpsertWithoutUserBuildInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserBuildInput, UserUpdateWithoutUserBuildInput>, UserUncheckedUpdateWithoutUserBuildInput>
  }

  export type UserBuildComponentUpdateManyWithoutUserBuildNestedInput = {
    create?: XOR<UserBuildComponentCreateWithoutUserBuildInput, UserBuildComponentUncheckedCreateWithoutUserBuildInput> | UserBuildComponentCreateWithoutUserBuildInput[] | UserBuildComponentUncheckedCreateWithoutUserBuildInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutUserBuildInput | UserBuildComponentCreateOrConnectWithoutUserBuildInput[]
    upsert?: UserBuildComponentUpsertWithWhereUniqueWithoutUserBuildInput | UserBuildComponentUpsertWithWhereUniqueWithoutUserBuildInput[]
    createMany?: UserBuildComponentCreateManyUserBuildInputEnvelope
    set?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    disconnect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    delete?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    update?: UserBuildComponentUpdateWithWhereUniqueWithoutUserBuildInput | UserBuildComponentUpdateWithWhereUniqueWithoutUserBuildInput[]
    updateMany?: UserBuildComponentUpdateManyWithWhereWithoutUserBuildInput | UserBuildComponentUpdateManyWithWhereWithoutUserBuildInput[]
    deleteMany?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
  }

  export type UserBuildComponentUncheckedUpdateManyWithoutUserBuildNestedInput = {
    create?: XOR<UserBuildComponentCreateWithoutUserBuildInput, UserBuildComponentUncheckedCreateWithoutUserBuildInput> | UserBuildComponentCreateWithoutUserBuildInput[] | UserBuildComponentUncheckedCreateWithoutUserBuildInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutUserBuildInput | UserBuildComponentCreateOrConnectWithoutUserBuildInput[]
    upsert?: UserBuildComponentUpsertWithWhereUniqueWithoutUserBuildInput | UserBuildComponentUpsertWithWhereUniqueWithoutUserBuildInput[]
    createMany?: UserBuildComponentCreateManyUserBuildInputEnvelope
    set?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    disconnect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    delete?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    update?: UserBuildComponentUpdateWithWhereUniqueWithoutUserBuildInput | UserBuildComponentUpdateWithWhereUniqueWithoutUserBuildInput[]
    updateMany?: UserBuildComponentUpdateManyWithWhereWithoutUserBuildInput | UserBuildComponentUpdateManyWithWhereWithoutUserBuildInput[]
    deleteMany?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
  }

  export type UserBuildCreateNestedOneWithoutUserBuildComponentInput = {
    create?: XOR<UserBuildCreateWithoutUserBuildComponentInput, UserBuildUncheckedCreateWithoutUserBuildComponentInput>
    connectOrCreate?: UserBuildCreateOrConnectWithoutUserBuildComponentInput
    connect?: UserBuildWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutUserBuildComponentInput = {
    create?: XOR<ProductCreateWithoutUserBuildComponentInput, ProductUncheckedCreateWithoutUserBuildComponentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutUserBuildComponentInput
    connect?: ProductWhereUniqueInput
  }

  export type ComponentTypeCreateNestedOneWithoutUserBuildComponentInput = {
    create?: XOR<ComponentTypeCreateWithoutUserBuildComponentInput, ComponentTypeUncheckedCreateWithoutUserBuildComponentInput>
    connectOrCreate?: ComponentTypeCreateOrConnectWithoutUserBuildComponentInput
    connect?: ComponentTypeWhereUniqueInput
  }

  export type UserBuildUpdateOneRequiredWithoutUserBuildComponentNestedInput = {
    create?: XOR<UserBuildCreateWithoutUserBuildComponentInput, UserBuildUncheckedCreateWithoutUserBuildComponentInput>
    connectOrCreate?: UserBuildCreateOrConnectWithoutUserBuildComponentInput
    upsert?: UserBuildUpsertWithoutUserBuildComponentInput
    connect?: UserBuildWhereUniqueInput
    update?: XOR<XOR<UserBuildUpdateToOneWithWhereWithoutUserBuildComponentInput, UserBuildUpdateWithoutUserBuildComponentInput>, UserBuildUncheckedUpdateWithoutUserBuildComponentInput>
  }

  export type ProductUpdateOneRequiredWithoutUserBuildComponentNestedInput = {
    create?: XOR<ProductCreateWithoutUserBuildComponentInput, ProductUncheckedCreateWithoutUserBuildComponentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutUserBuildComponentInput
    upsert?: ProductUpsertWithoutUserBuildComponentInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutUserBuildComponentInput, ProductUpdateWithoutUserBuildComponentInput>, ProductUncheckedUpdateWithoutUserBuildComponentInput>
  }

  export type ComponentTypeUpdateOneRequiredWithoutUserBuildComponentNestedInput = {
    create?: XOR<ComponentTypeCreateWithoutUserBuildComponentInput, ComponentTypeUncheckedCreateWithoutUserBuildComponentInput>
    connectOrCreate?: ComponentTypeCreateOrConnectWithoutUserBuildComponentInput
    upsert?: ComponentTypeUpsertWithoutUserBuildComponentInput
    connect?: ComponentTypeWhereUniqueInput
    update?: XOR<XOR<ComponentTypeUpdateToOneWithWhereWithoutUserBuildComponentInput, ComponentTypeUpdateWithoutUserBuildComponentInput>, ComponentTypeUncheckedUpdateWithoutUserBuildComponentInput>
  }

  export type UserBuildComponentCreateNestedManyWithoutComponentTypeInput = {
    create?: XOR<UserBuildComponentCreateWithoutComponentTypeInput, UserBuildComponentUncheckedCreateWithoutComponentTypeInput> | UserBuildComponentCreateWithoutComponentTypeInput[] | UserBuildComponentUncheckedCreateWithoutComponentTypeInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutComponentTypeInput | UserBuildComponentCreateOrConnectWithoutComponentTypeInput[]
    createMany?: UserBuildComponentCreateManyComponentTypeInputEnvelope
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
  }

  export type UserBuildComponentUncheckedCreateNestedManyWithoutComponentTypeInput = {
    create?: XOR<UserBuildComponentCreateWithoutComponentTypeInput, UserBuildComponentUncheckedCreateWithoutComponentTypeInput> | UserBuildComponentCreateWithoutComponentTypeInput[] | UserBuildComponentUncheckedCreateWithoutComponentTypeInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutComponentTypeInput | UserBuildComponentCreateOrConnectWithoutComponentTypeInput[]
    createMany?: UserBuildComponentCreateManyComponentTypeInputEnvelope
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
  }

  export type UserBuildComponentUpdateManyWithoutComponentTypeNestedInput = {
    create?: XOR<UserBuildComponentCreateWithoutComponentTypeInput, UserBuildComponentUncheckedCreateWithoutComponentTypeInput> | UserBuildComponentCreateWithoutComponentTypeInput[] | UserBuildComponentUncheckedCreateWithoutComponentTypeInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutComponentTypeInput | UserBuildComponentCreateOrConnectWithoutComponentTypeInput[]
    upsert?: UserBuildComponentUpsertWithWhereUniqueWithoutComponentTypeInput | UserBuildComponentUpsertWithWhereUniqueWithoutComponentTypeInput[]
    createMany?: UserBuildComponentCreateManyComponentTypeInputEnvelope
    set?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    disconnect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    delete?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    update?: UserBuildComponentUpdateWithWhereUniqueWithoutComponentTypeInput | UserBuildComponentUpdateWithWhereUniqueWithoutComponentTypeInput[]
    updateMany?: UserBuildComponentUpdateManyWithWhereWithoutComponentTypeInput | UserBuildComponentUpdateManyWithWhereWithoutComponentTypeInput[]
    deleteMany?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
  }

  export type UserBuildComponentUncheckedUpdateManyWithoutComponentTypeNestedInput = {
    create?: XOR<UserBuildComponentCreateWithoutComponentTypeInput, UserBuildComponentUncheckedCreateWithoutComponentTypeInput> | UserBuildComponentCreateWithoutComponentTypeInput[] | UserBuildComponentUncheckedCreateWithoutComponentTypeInput[]
    connectOrCreate?: UserBuildComponentCreateOrConnectWithoutComponentTypeInput | UserBuildComponentCreateOrConnectWithoutComponentTypeInput[]
    upsert?: UserBuildComponentUpsertWithWhereUniqueWithoutComponentTypeInput | UserBuildComponentUpsertWithWhereUniqueWithoutComponentTypeInput[]
    createMany?: UserBuildComponentCreateManyComponentTypeInputEnvelope
    set?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    disconnect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    delete?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    connect?: UserBuildComponentWhereUniqueInput | UserBuildComponentWhereUniqueInput[]
    update?: UserBuildComponentUpdateWithWhereUniqueWithoutComponentTypeInput | UserBuildComponentUpdateWithWhereUniqueWithoutComponentTypeInput[]
    updateMany?: UserBuildComponentUpdateManyWithWhereWithoutComponentTypeInput | UserBuildComponentUpdateManyWithWhereWithoutComponentTypeInput[]
    deleteMany?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductImageInput = {
    create?: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImageInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductImageNestedInput = {
    create?: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImageInput
    upsert?: ProductUpsertWithoutProductImageInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductImageInput, ProductUpdateWithoutProductImageInput>, ProductUncheckedUpdateWithoutProductImageInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type NestedEnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionMethod | EnumTransactionMethodFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionMethodFilter<$PrismaModel> | $Enums.TransactionMethod
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionMethod | EnumTransactionMethodFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionMethod[] | ListEnumTransactionMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionMethodWithAggregatesFilter<$PrismaModel> | $Enums.TransactionMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionMethodFilter<$PrismaModel>
    _max?: NestedEnumTransactionMethodFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type KeyboardCreateWithoutProductInput = {
    id?: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    layout: LayoutCreateNestedOneWithoutKeyboardInput
    connectionType: ConnectionTypeCreateNestedOneWithoutKeyboardInput
    Color?: ColorCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardUncheckedCreateWithoutProductInput = {
    id?: string
    layoutId: string
    connectionTypeId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Color?: ColorUncheckedCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardCreateOrConnectWithoutProductInput = {
    where: KeyboardWhereUniqueInput
    create: XOR<KeyboardCreateWithoutProductInput, KeyboardUncheckedCreateWithoutProductInput>
  }

  export type SwitchCreateWithoutProductInput = {
    id?: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    switchType: SwitchTypeCreateNestedOneWithoutSwitchInput
  }

  export type SwitchUncheckedCreateWithoutProductInput = {
    id?: string
    typeId: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchCreateOrConnectWithoutProductInput = {
    where: SwitchWhereUniqueInput
    create: XOR<SwitchCreateWithoutProductInput, SwitchUncheckedCreateWithoutProductInput>
  }

  export type KeycapCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: KeycapProfileCreateNestedOneWithoutKeycapInput
    material: KeycapMaterialCreateNestedOneWithoutKeycapInput
  }

  export type KeycapUncheckedCreateWithoutProductInput = {
    id?: string
    profileId: string
    materialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapCreateOrConnectWithoutProductInput = {
    where: KeycapWhereUniqueInput
    create: XOR<KeycapCreateWithoutProductInput, KeycapUncheckedCreateWithoutProductInput>
  }

  export type AccessoryCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: AccessoryTypeCreateNestedOneWithoutAccessoryInput
  }

  export type AccessoryUncheckedCreateWithoutProductInput = {
    id?: string
    typeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryCreateOrConnectWithoutProductInput = {
    where: AccessoryWhereUniqueInput
    create: XOR<AccessoryCreateWithoutProductInput, AccessoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryCreateManyProductInputEnvelope = {
    data: ProductCategoryCreateManyProductInput | ProductCategoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutProductInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wishlist: WishlistCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutProductInput = {
    id?: string
    wishlistId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemCreateManyProductInputEnvelope = {
    data: WishlistItemCreateManyProductInput | WishlistItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BillItemCreateWithoutProductInput = {
    id?: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutBillItemInput
  }

  export type BillItemUncheckedCreateWithoutProductInput = {
    id?: string
    billId: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemCreateOrConnectWithoutProductInput = {
    where: BillItemWhereUniqueInput
    create: XOR<BillItemCreateWithoutProductInput, BillItemUncheckedCreateWithoutProductInput>
  }

  export type BillItemCreateManyProductInputEnvelope = {
    data: BillItemCreateManyProductInput | BillItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserBuildComponentCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userBuild: UserBuildCreateNestedOneWithoutUserBuildComponentInput
    componentType: ComponentTypeCreateNestedOneWithoutUserBuildComponentInput
  }

  export type UserBuildComponentUncheckedCreateWithoutProductInput = {
    id?: string
    userBuildId: string
    componentTypeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentCreateOrConnectWithoutProductInput = {
    where: UserBuildComponentWhereUniqueInput
    create: XOR<UserBuildComponentCreateWithoutProductInput, UserBuildComponentUncheckedCreateWithoutProductInput>
  }

  export type UserBuildComponentCreateManyProductInputEnvelope = {
    data: UserBuildComponentCreateManyProductInput | UserBuildComponentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    id?: string
    imageUrl: string
    altText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: string
    imageUrl: string
    altText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type KeyboardUpsertWithoutProductInput = {
    update: XOR<KeyboardUpdateWithoutProductInput, KeyboardUncheckedUpdateWithoutProductInput>
    create: XOR<KeyboardCreateWithoutProductInput, KeyboardUncheckedCreateWithoutProductInput>
    where?: KeyboardWhereInput
  }

  export type KeyboardUpdateToOneWithWhereWithoutProductInput = {
    where?: KeyboardWhereInput
    data: XOR<KeyboardUpdateWithoutProductInput, KeyboardUncheckedUpdateWithoutProductInput>
  }

  export type KeyboardUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    layout?: LayoutUpdateOneRequiredWithoutKeyboardNestedInput
    connectionType?: ConnectionTypeUpdateOneRequiredWithoutKeyboardNestedInput
    Color?: ColorUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    layoutId?: StringFieldUpdateOperationsInput | string
    connectionTypeId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Color?: ColorUncheckedUpdateManyWithoutKeyboardNestedInput
  }

  export type SwitchUpsertWithoutProductInput = {
    update: XOR<SwitchUpdateWithoutProductInput, SwitchUncheckedUpdateWithoutProductInput>
    create: XOR<SwitchCreateWithoutProductInput, SwitchUncheckedCreateWithoutProductInput>
    where?: SwitchWhereInput
  }

  export type SwitchUpdateToOneWithWhereWithoutProductInput = {
    where?: SwitchWhereInput
    data: XOR<SwitchUpdateWithoutProductInput, SwitchUncheckedUpdateWithoutProductInput>
  }

  export type SwitchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    switchType?: SwitchTypeUpdateOneRequiredWithoutSwitchNestedInput
  }

  export type SwitchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapUpsertWithoutProductInput = {
    update: XOR<KeycapUpdateWithoutProductInput, KeycapUncheckedUpdateWithoutProductInput>
    create: XOR<KeycapCreateWithoutProductInput, KeycapUncheckedCreateWithoutProductInput>
    where?: KeycapWhereInput
  }

  export type KeycapUpdateToOneWithWhereWithoutProductInput = {
    where?: KeycapWhereInput
    data: XOR<KeycapUpdateWithoutProductInput, KeycapUncheckedUpdateWithoutProductInput>
  }

  export type KeycapUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: KeycapProfileUpdateOneRequiredWithoutKeycapNestedInput
    material?: KeycapMaterialUpdateOneRequiredWithoutKeycapNestedInput
  }

  export type KeycapUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryUpsertWithoutProductInput = {
    update: XOR<AccessoryUpdateWithoutProductInput, AccessoryUncheckedUpdateWithoutProductInput>
    create: XOR<AccessoryCreateWithoutProductInput, AccessoryUncheckedCreateWithoutProductInput>
    where?: AccessoryWhereInput
  }

  export type AccessoryUpdateToOneWithWhereWithoutProductInput = {
    where?: AccessoryWhereInput
    data: XOR<AccessoryUpdateWithoutProductInput, AccessoryUncheckedUpdateWithoutProductInput>
  }

  export type AccessoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: AccessoryTypeUpdateOneRequiredWithoutAccessoryNestedInput
  }

  export type AccessoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutProductInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutProductInput>
  }

  export type WishlistItemScalarWhereInput = {
    AND?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    OR?: WishlistItemScalarWhereInput[]
    NOT?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    wishlistId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    quantity?: IntFilter<"WishlistItem"> | number
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeFilter<"WishlistItem"> | Date | string
  }

  export type BillItemUpsertWithWhereUniqueWithoutProductInput = {
    where: BillItemWhereUniqueInput
    update: XOR<BillItemUpdateWithoutProductInput, BillItemUncheckedUpdateWithoutProductInput>
    create: XOR<BillItemCreateWithoutProductInput, BillItemUncheckedCreateWithoutProductInput>
  }

  export type BillItemUpdateWithWhereUniqueWithoutProductInput = {
    where: BillItemWhereUniqueInput
    data: XOR<BillItemUpdateWithoutProductInput, BillItemUncheckedUpdateWithoutProductInput>
  }

  export type BillItemUpdateManyWithWhereWithoutProductInput = {
    where: BillItemScalarWhereInput
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyWithoutProductInput>
  }

  export type BillItemScalarWhereInput = {
    AND?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
    OR?: BillItemScalarWhereInput[]
    NOT?: BillItemScalarWhereInput | BillItemScalarWhereInput[]
    id?: StringFilter<"BillItem"> | string
    billId?: StringFilter<"BillItem"> | string
    productId?: StringFilter<"BillItem"> | string
    quantity?: IntFilter<"BillItem"> | number
    priceAtPurchase?: DecimalFilter<"BillItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BillItem"> | Date | string
    updatedAt?: DateTimeFilter<"BillItem"> | Date | string
  }

  export type UserBuildComponentUpsertWithWhereUniqueWithoutProductInput = {
    where: UserBuildComponentWhereUniqueInput
    update: XOR<UserBuildComponentUpdateWithoutProductInput, UserBuildComponentUncheckedUpdateWithoutProductInput>
    create: XOR<UserBuildComponentCreateWithoutProductInput, UserBuildComponentUncheckedCreateWithoutProductInput>
  }

  export type UserBuildComponentUpdateWithWhereUniqueWithoutProductInput = {
    where: UserBuildComponentWhereUniqueInput
    data: XOR<UserBuildComponentUpdateWithoutProductInput, UserBuildComponentUncheckedUpdateWithoutProductInput>
  }

  export type UserBuildComponentUpdateManyWithWhereWithoutProductInput = {
    where: UserBuildComponentScalarWhereInput
    data: XOR<UserBuildComponentUpdateManyMutationInput, UserBuildComponentUncheckedUpdateManyWithoutProductInput>
  }

  export type UserBuildComponentScalarWhereInput = {
    AND?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
    OR?: UserBuildComponentScalarWhereInput[]
    NOT?: UserBuildComponentScalarWhereInput | UserBuildComponentScalarWhereInput[]
    id?: StringFilter<"UserBuildComponent"> | string
    userBuildId?: StringFilter<"UserBuildComponent"> | string
    productId?: StringFilter<"UserBuildComponent"> | string
    componentTypeId?: StringFilter<"UserBuildComponent"> | string
    createdAt?: DateTimeFilter<"UserBuildComponent"> | Date | string
    updatedAt?: DateTimeFilter<"UserBuildComponent"> | Date | string
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    imageUrl?: StringFilter<"ProductImage"> | string
    altText?: StringFilter<"ProductImage"> | string
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string
  }

  export type KeyboardCreateWithoutColorInput = {
    id?: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeyboardInput
    layout: LayoutCreateNestedOneWithoutKeyboardInput
    connectionType: ConnectionTypeCreateNestedOneWithoutKeyboardInput
  }

  export type KeyboardUncheckedCreateWithoutColorInput = {
    id?: string
    productId: string
    layoutId: string
    connectionTypeId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyboardCreateOrConnectWithoutColorInput = {
    where: KeyboardWhereUniqueInput
    create: XOR<KeyboardCreateWithoutColorInput, KeyboardUncheckedCreateWithoutColorInput>
  }

  export type KeyboardUpsertWithoutColorInput = {
    update: XOR<KeyboardUpdateWithoutColorInput, KeyboardUncheckedUpdateWithoutColorInput>
    create: XOR<KeyboardCreateWithoutColorInput, KeyboardUncheckedCreateWithoutColorInput>
    where?: KeyboardWhereInput
  }

  export type KeyboardUpdateToOneWithWhereWithoutColorInput = {
    where?: KeyboardWhereInput
    data: XOR<KeyboardUpdateWithoutColorInput, KeyboardUncheckedUpdateWithoutColorInput>
  }

  export type KeyboardUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeyboardNestedInput
    layout?: LayoutUpdateOneRequiredWithoutKeyboardNestedInput
    connectionType?: ConnectionTypeUpdateOneRequiredWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    layoutId?: StringFieldUpdateOperationsInput | string
    connectionTypeId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutKeyboardInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutKeyboardInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutKeyboardInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutKeyboardInput, ProductUncheckedCreateWithoutKeyboardInput>
  }

  export type LayoutCreateWithoutKeyboardInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutUncheckedCreateWithoutKeyboardInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutCreateOrConnectWithoutKeyboardInput = {
    where: LayoutWhereUniqueInput
    create: XOR<LayoutCreateWithoutKeyboardInput, LayoutUncheckedCreateWithoutKeyboardInput>
  }

  export type ConnectionTypeCreateWithoutKeyboardInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionTypeUncheckedCreateWithoutKeyboardInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectionTypeCreateOrConnectWithoutKeyboardInput = {
    where: ConnectionTypeWhereUniqueInput
    create: XOR<ConnectionTypeCreateWithoutKeyboardInput, ConnectionTypeUncheckedCreateWithoutKeyboardInput>
  }

  export type ColorCreateWithoutKeyboardInput = {
    id?: string
    hex: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUncheckedCreateWithoutKeyboardInput = {
    id?: string
    hex: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorCreateOrConnectWithoutKeyboardInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutKeyboardInput, ColorUncheckedCreateWithoutKeyboardInput>
  }

  export type ColorCreateManyKeyboardInputEnvelope = {
    data: ColorCreateManyKeyboardInput | ColorCreateManyKeyboardInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutKeyboardInput = {
    update: XOR<ProductUpdateWithoutKeyboardInput, ProductUncheckedUpdateWithoutKeyboardInput>
    create: XOR<ProductCreateWithoutKeyboardInput, ProductUncheckedCreateWithoutKeyboardInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutKeyboardInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutKeyboardInput, ProductUncheckedUpdateWithoutKeyboardInput>
  }

  export type ProductUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type LayoutUpsertWithoutKeyboardInput = {
    update: XOR<LayoutUpdateWithoutKeyboardInput, LayoutUncheckedUpdateWithoutKeyboardInput>
    create: XOR<LayoutCreateWithoutKeyboardInput, LayoutUncheckedCreateWithoutKeyboardInput>
    where?: LayoutWhereInput
  }

  export type LayoutUpdateToOneWithWhereWithoutKeyboardInput = {
    where?: LayoutWhereInput
    data: XOR<LayoutUpdateWithoutKeyboardInput, LayoutUncheckedUpdateWithoutKeyboardInput>
  }

  export type LayoutUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutUncheckedUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionTypeUpsertWithoutKeyboardInput = {
    update: XOR<ConnectionTypeUpdateWithoutKeyboardInput, ConnectionTypeUncheckedUpdateWithoutKeyboardInput>
    create: XOR<ConnectionTypeCreateWithoutKeyboardInput, ConnectionTypeUncheckedCreateWithoutKeyboardInput>
    where?: ConnectionTypeWhereInput
  }

  export type ConnectionTypeUpdateToOneWithWhereWithoutKeyboardInput = {
    where?: ConnectionTypeWhereInput
    data: XOR<ConnectionTypeUpdateWithoutKeyboardInput, ConnectionTypeUncheckedUpdateWithoutKeyboardInput>
  }

  export type ConnectionTypeUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionTypeUncheckedUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUpsertWithWhereUniqueWithoutKeyboardInput = {
    where: ColorWhereUniqueInput
    update: XOR<ColorUpdateWithoutKeyboardInput, ColorUncheckedUpdateWithoutKeyboardInput>
    create: XOR<ColorCreateWithoutKeyboardInput, ColorUncheckedCreateWithoutKeyboardInput>
  }

  export type ColorUpdateWithWhereUniqueWithoutKeyboardInput = {
    where: ColorWhereUniqueInput
    data: XOR<ColorUpdateWithoutKeyboardInput, ColorUncheckedUpdateWithoutKeyboardInput>
  }

  export type ColorUpdateManyWithWhereWithoutKeyboardInput = {
    where: ColorScalarWhereInput
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyWithoutKeyboardInput>
  }

  export type ColorScalarWhereInput = {
    AND?: ColorScalarWhereInput | ColorScalarWhereInput[]
    OR?: ColorScalarWhereInput[]
    NOT?: ColorScalarWhereInput | ColorScalarWhereInput[]
    id?: StringFilter<"Color"> | string
    keyboardId?: StringFilter<"Color"> | string
    hex?: StringFilter<"Color"> | string
    name?: StringFilter<"Color"> | string
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
  }

  export type KeyboardCreateWithoutLayoutInput = {
    id?: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeyboardInput
    connectionType: ConnectionTypeCreateNestedOneWithoutKeyboardInput
    Color?: ColorCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardUncheckedCreateWithoutLayoutInput = {
    id?: string
    productId: string
    connectionTypeId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Color?: ColorUncheckedCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardCreateOrConnectWithoutLayoutInput = {
    where: KeyboardWhereUniqueInput
    create: XOR<KeyboardCreateWithoutLayoutInput, KeyboardUncheckedCreateWithoutLayoutInput>
  }

  export type KeyboardCreateManyLayoutInputEnvelope = {
    data: KeyboardCreateManyLayoutInput | KeyboardCreateManyLayoutInput[]
    skipDuplicates?: boolean
  }

  export type KeyboardUpsertWithWhereUniqueWithoutLayoutInput = {
    where: KeyboardWhereUniqueInput
    update: XOR<KeyboardUpdateWithoutLayoutInput, KeyboardUncheckedUpdateWithoutLayoutInput>
    create: XOR<KeyboardCreateWithoutLayoutInput, KeyboardUncheckedCreateWithoutLayoutInput>
  }

  export type KeyboardUpdateWithWhereUniqueWithoutLayoutInput = {
    where: KeyboardWhereUniqueInput
    data: XOR<KeyboardUpdateWithoutLayoutInput, KeyboardUncheckedUpdateWithoutLayoutInput>
  }

  export type KeyboardUpdateManyWithWhereWithoutLayoutInput = {
    where: KeyboardScalarWhereInput
    data: XOR<KeyboardUpdateManyMutationInput, KeyboardUncheckedUpdateManyWithoutLayoutInput>
  }

  export type KeyboardScalarWhereInput = {
    AND?: KeyboardScalarWhereInput | KeyboardScalarWhereInput[]
    OR?: KeyboardScalarWhereInput[]
    NOT?: KeyboardScalarWhereInput | KeyboardScalarWhereInput[]
    id?: StringFilter<"Keyboard"> | string
    productId?: StringFilter<"Keyboard"> | string
    layoutId?: StringFilter<"Keyboard"> | string
    connectionTypeId?: StringFilter<"Keyboard"> | string
    isHotswapable?: BoolFilter<"Keyboard"> | boolean
    createdAt?: DateTimeFilter<"Keyboard"> | Date | string
    updatedAt?: DateTimeFilter<"Keyboard"> | Date | string
  }

  export type KeyboardCreateWithoutConnectionTypeInput = {
    id?: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeyboardInput
    layout: LayoutCreateNestedOneWithoutKeyboardInput
    Color?: ColorCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardUncheckedCreateWithoutConnectionTypeInput = {
    id?: string
    productId: string
    layoutId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Color?: ColorUncheckedCreateNestedManyWithoutKeyboardInput
  }

  export type KeyboardCreateOrConnectWithoutConnectionTypeInput = {
    where: KeyboardWhereUniqueInput
    create: XOR<KeyboardCreateWithoutConnectionTypeInput, KeyboardUncheckedCreateWithoutConnectionTypeInput>
  }

  export type KeyboardCreateManyConnectionTypeInputEnvelope = {
    data: KeyboardCreateManyConnectionTypeInput | KeyboardCreateManyConnectionTypeInput[]
    skipDuplicates?: boolean
  }

  export type KeyboardUpsertWithWhereUniqueWithoutConnectionTypeInput = {
    where: KeyboardWhereUniqueInput
    update: XOR<KeyboardUpdateWithoutConnectionTypeInput, KeyboardUncheckedUpdateWithoutConnectionTypeInput>
    create: XOR<KeyboardCreateWithoutConnectionTypeInput, KeyboardUncheckedCreateWithoutConnectionTypeInput>
  }

  export type KeyboardUpdateWithWhereUniqueWithoutConnectionTypeInput = {
    where: KeyboardWhereUniqueInput
    data: XOR<KeyboardUpdateWithoutConnectionTypeInput, KeyboardUncheckedUpdateWithoutConnectionTypeInput>
  }

  export type KeyboardUpdateManyWithWhereWithoutConnectionTypeInput = {
    where: KeyboardScalarWhereInput
    data: XOR<KeyboardUpdateManyMutationInput, KeyboardUncheckedUpdateManyWithoutConnectionTypeInput>
  }

  export type ProductCreateWithoutSwitchInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSwitchInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSwitchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSwitchInput, ProductUncheckedCreateWithoutSwitchInput>
  }

  export type SwitchTypeCreateWithoutSwitchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchTypeUncheckedCreateWithoutSwitchInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchTypeCreateOrConnectWithoutSwitchInput = {
    where: SwitchTypeWhereUniqueInput
    create: XOR<SwitchTypeCreateWithoutSwitchInput, SwitchTypeUncheckedCreateWithoutSwitchInput>
  }

  export type ProductUpsertWithoutSwitchInput = {
    update: XOR<ProductUpdateWithoutSwitchInput, ProductUncheckedUpdateWithoutSwitchInput>
    create: XOR<ProductCreateWithoutSwitchInput, ProductUncheckedCreateWithoutSwitchInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSwitchInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSwitchInput, ProductUncheckedUpdateWithoutSwitchInput>
  }

  export type ProductUpdateWithoutSwitchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSwitchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SwitchTypeUpsertWithoutSwitchInput = {
    update: XOR<SwitchTypeUpdateWithoutSwitchInput, SwitchTypeUncheckedUpdateWithoutSwitchInput>
    create: XOR<SwitchTypeCreateWithoutSwitchInput, SwitchTypeUncheckedCreateWithoutSwitchInput>
    where?: SwitchTypeWhereInput
  }

  export type SwitchTypeUpdateToOneWithWhereWithoutSwitchInput = {
    where?: SwitchTypeWhereInput
    data: XOR<SwitchTypeUpdateWithoutSwitchInput, SwitchTypeUncheckedUpdateWithoutSwitchInput>
  }

  export type SwitchTypeUpdateWithoutSwitchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchTypeUncheckedUpdateWithoutSwitchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchCreateWithoutSwitchTypeInput = {
    id?: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSwitchInput
  }

  export type SwitchUncheckedCreateWithoutSwitchTypeInput = {
    id?: string
    productId: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchCreateOrConnectWithoutSwitchTypeInput = {
    where: SwitchWhereUniqueInput
    create: XOR<SwitchCreateWithoutSwitchTypeInput, SwitchUncheckedCreateWithoutSwitchTypeInput>
  }

  export type SwitchCreateManySwitchTypeInputEnvelope = {
    data: SwitchCreateManySwitchTypeInput | SwitchCreateManySwitchTypeInput[]
    skipDuplicates?: boolean
  }

  export type SwitchUpsertWithWhereUniqueWithoutSwitchTypeInput = {
    where: SwitchWhereUniqueInput
    update: XOR<SwitchUpdateWithoutSwitchTypeInput, SwitchUncheckedUpdateWithoutSwitchTypeInput>
    create: XOR<SwitchCreateWithoutSwitchTypeInput, SwitchUncheckedCreateWithoutSwitchTypeInput>
  }

  export type SwitchUpdateWithWhereUniqueWithoutSwitchTypeInput = {
    where: SwitchWhereUniqueInput
    data: XOR<SwitchUpdateWithoutSwitchTypeInput, SwitchUncheckedUpdateWithoutSwitchTypeInput>
  }

  export type SwitchUpdateManyWithWhereWithoutSwitchTypeInput = {
    where: SwitchScalarWhereInput
    data: XOR<SwitchUpdateManyMutationInput, SwitchUncheckedUpdateManyWithoutSwitchTypeInput>
  }

  export type SwitchScalarWhereInput = {
    AND?: SwitchScalarWhereInput | SwitchScalarWhereInput[]
    OR?: SwitchScalarWhereInput[]
    NOT?: SwitchScalarWhereInput | SwitchScalarWhereInput[]
    id?: StringFilter<"Switch"> | string
    productId?: StringFilter<"Switch"> | string
    typeId?: StringFilter<"Switch"> | string
    actuationForce?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFilter<"Switch"> | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFilter<"Switch"> | number
    isFactoryLubed?: BoolFilter<"Switch"> | boolean
    createdAt?: DateTimeFilter<"Switch"> | Date | string
    updatedAt?: DateTimeFilter<"Switch"> | Date | string
  }

  export type ProductCreateWithoutKeycapInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutKeycapInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutKeycapInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutKeycapInput, ProductUncheckedCreateWithoutKeycapInput>
  }

  export type KeycapProfileCreateWithoutKeycapInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapProfileUncheckedCreateWithoutKeycapInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapProfileCreateOrConnectWithoutKeycapInput = {
    where: KeycapProfileWhereUniqueInput
    create: XOR<KeycapProfileCreateWithoutKeycapInput, KeycapProfileUncheckedCreateWithoutKeycapInput>
  }

  export type KeycapMaterialCreateWithoutKeycapInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapMaterialUncheckedCreateWithoutKeycapInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapMaterialCreateOrConnectWithoutKeycapInput = {
    where: KeycapMaterialWhereUniqueInput
    create: XOR<KeycapMaterialCreateWithoutKeycapInput, KeycapMaterialUncheckedCreateWithoutKeycapInput>
  }

  export type ProductUpsertWithoutKeycapInput = {
    update: XOR<ProductUpdateWithoutKeycapInput, ProductUncheckedUpdateWithoutKeycapInput>
    create: XOR<ProductCreateWithoutKeycapInput, ProductUncheckedCreateWithoutKeycapInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutKeycapInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutKeycapInput, ProductUncheckedUpdateWithoutKeycapInput>
  }

  export type ProductUpdateWithoutKeycapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutKeycapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type KeycapProfileUpsertWithoutKeycapInput = {
    update: XOR<KeycapProfileUpdateWithoutKeycapInput, KeycapProfileUncheckedUpdateWithoutKeycapInput>
    create: XOR<KeycapProfileCreateWithoutKeycapInput, KeycapProfileUncheckedCreateWithoutKeycapInput>
    where?: KeycapProfileWhereInput
  }

  export type KeycapProfileUpdateToOneWithWhereWithoutKeycapInput = {
    where?: KeycapProfileWhereInput
    data: XOR<KeycapProfileUpdateWithoutKeycapInput, KeycapProfileUncheckedUpdateWithoutKeycapInput>
  }

  export type KeycapProfileUpdateWithoutKeycapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapProfileUncheckedUpdateWithoutKeycapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapMaterialUpsertWithoutKeycapInput = {
    update: XOR<KeycapMaterialUpdateWithoutKeycapInput, KeycapMaterialUncheckedUpdateWithoutKeycapInput>
    create: XOR<KeycapMaterialCreateWithoutKeycapInput, KeycapMaterialUncheckedCreateWithoutKeycapInput>
    where?: KeycapMaterialWhereInput
  }

  export type KeycapMaterialUpdateToOneWithWhereWithoutKeycapInput = {
    where?: KeycapMaterialWhereInput
    data: XOR<KeycapMaterialUpdateWithoutKeycapInput, KeycapMaterialUncheckedUpdateWithoutKeycapInput>
  }

  export type KeycapMaterialUpdateWithoutKeycapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapMaterialUncheckedUpdateWithoutKeycapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeycapInput
    material: KeycapMaterialCreateNestedOneWithoutKeycapInput
  }

  export type KeycapUncheckedCreateWithoutProfileInput = {
    id?: string
    productId: string
    materialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapCreateOrConnectWithoutProfileInput = {
    where: KeycapWhereUniqueInput
    create: XOR<KeycapCreateWithoutProfileInput, KeycapUncheckedCreateWithoutProfileInput>
  }

  export type KeycapCreateManyProfileInputEnvelope = {
    data: KeycapCreateManyProfileInput | KeycapCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type KeycapUpsertWithWhereUniqueWithoutProfileInput = {
    where: KeycapWhereUniqueInput
    update: XOR<KeycapUpdateWithoutProfileInput, KeycapUncheckedUpdateWithoutProfileInput>
    create: XOR<KeycapCreateWithoutProfileInput, KeycapUncheckedCreateWithoutProfileInput>
  }

  export type KeycapUpdateWithWhereUniqueWithoutProfileInput = {
    where: KeycapWhereUniqueInput
    data: XOR<KeycapUpdateWithoutProfileInput, KeycapUncheckedUpdateWithoutProfileInput>
  }

  export type KeycapUpdateManyWithWhereWithoutProfileInput = {
    where: KeycapScalarWhereInput
    data: XOR<KeycapUpdateManyMutationInput, KeycapUncheckedUpdateManyWithoutProfileInput>
  }

  export type KeycapScalarWhereInput = {
    AND?: KeycapScalarWhereInput | KeycapScalarWhereInput[]
    OR?: KeycapScalarWhereInput[]
    NOT?: KeycapScalarWhereInput | KeycapScalarWhereInput[]
    id?: StringFilter<"Keycap"> | string
    productId?: StringFilter<"Keycap"> | string
    profileId?: StringFilter<"Keycap"> | string
    materialId?: StringFilter<"Keycap"> | string
    createdAt?: DateTimeFilter<"Keycap"> | Date | string
    updatedAt?: DateTimeFilter<"Keycap"> | Date | string
  }

  export type KeycapCreateWithoutMaterialInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutKeycapInput
    profile: KeycapProfileCreateNestedOneWithoutKeycapInput
  }

  export type KeycapUncheckedCreateWithoutMaterialInput = {
    id?: string
    productId: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapCreateOrConnectWithoutMaterialInput = {
    where: KeycapWhereUniqueInput
    create: XOR<KeycapCreateWithoutMaterialInput, KeycapUncheckedCreateWithoutMaterialInput>
  }

  export type KeycapCreateManyMaterialInputEnvelope = {
    data: KeycapCreateManyMaterialInput | KeycapCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type KeycapUpsertWithWhereUniqueWithoutMaterialInput = {
    where: KeycapWhereUniqueInput
    update: XOR<KeycapUpdateWithoutMaterialInput, KeycapUncheckedUpdateWithoutMaterialInput>
    create: XOR<KeycapCreateWithoutMaterialInput, KeycapUncheckedCreateWithoutMaterialInput>
  }

  export type KeycapUpdateWithWhereUniqueWithoutMaterialInput = {
    where: KeycapWhereUniqueInput
    data: XOR<KeycapUpdateWithoutMaterialInput, KeycapUncheckedUpdateWithoutMaterialInput>
  }

  export type KeycapUpdateManyWithWhereWithoutMaterialInput = {
    where: KeycapScalarWhereInput
    data: XOR<KeycapUpdateManyMutationInput, KeycapUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ProductCreateWithoutAccessoryInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAccessoryInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAccessoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAccessoryInput, ProductUncheckedCreateWithoutAccessoryInput>
  }

  export type AccessoryTypeCreateWithoutAccessoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryTypeUncheckedCreateWithoutAccessoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryTypeCreateOrConnectWithoutAccessoryInput = {
    where: AccessoryTypeWhereUniqueInput
    create: XOR<AccessoryTypeCreateWithoutAccessoryInput, AccessoryTypeUncheckedCreateWithoutAccessoryInput>
  }

  export type ProductUpsertWithoutAccessoryInput = {
    update: XOR<ProductUpdateWithoutAccessoryInput, ProductUncheckedUpdateWithoutAccessoryInput>
    create: XOR<ProductCreateWithoutAccessoryInput, ProductUncheckedCreateWithoutAccessoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAccessoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAccessoryInput, ProductUncheckedUpdateWithoutAccessoryInput>
  }

  export type ProductUpdateWithoutAccessoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAccessoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AccessoryTypeUpsertWithoutAccessoryInput = {
    update: XOR<AccessoryTypeUpdateWithoutAccessoryInput, AccessoryTypeUncheckedUpdateWithoutAccessoryInput>
    create: XOR<AccessoryTypeCreateWithoutAccessoryInput, AccessoryTypeUncheckedCreateWithoutAccessoryInput>
    where?: AccessoryTypeWhereInput
  }

  export type AccessoryTypeUpdateToOneWithWhereWithoutAccessoryInput = {
    where?: AccessoryTypeWhereInput
    data: XOR<AccessoryTypeUpdateWithoutAccessoryInput, AccessoryTypeUncheckedUpdateWithoutAccessoryInput>
  }

  export type AccessoryTypeUpdateWithoutAccessoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryTypeUncheckedUpdateWithoutAccessoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryCreateWithoutTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutAccessoryInput
  }

  export type AccessoryUncheckedCreateWithoutTypeInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryCreateOrConnectWithoutTypeInput = {
    where: AccessoryWhereUniqueInput
    create: XOR<AccessoryCreateWithoutTypeInput, AccessoryUncheckedCreateWithoutTypeInput>
  }

  export type AccessoryCreateManyTypeInputEnvelope = {
    data: AccessoryCreateManyTypeInput | AccessoryCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type AccessoryUpsertWithWhereUniqueWithoutTypeInput = {
    where: AccessoryWhereUniqueInput
    update: XOR<AccessoryUpdateWithoutTypeInput, AccessoryUncheckedUpdateWithoutTypeInput>
    create: XOR<AccessoryCreateWithoutTypeInput, AccessoryUncheckedCreateWithoutTypeInput>
  }

  export type AccessoryUpdateWithWhereUniqueWithoutTypeInput = {
    where: AccessoryWhereUniqueInput
    data: XOR<AccessoryUpdateWithoutTypeInput, AccessoryUncheckedUpdateWithoutTypeInput>
  }

  export type AccessoryUpdateManyWithWhereWithoutTypeInput = {
    where: AccessoryScalarWhereInput
    data: XOR<AccessoryUpdateManyMutationInput, AccessoryUncheckedUpdateManyWithoutTypeInput>
  }

  export type AccessoryScalarWhereInput = {
    AND?: AccessoryScalarWhereInput | AccessoryScalarWhereInput[]
    OR?: AccessoryScalarWhereInput[]
    NOT?: AccessoryScalarWhereInput | AccessoryScalarWhereInput[]
    id?: StringFilter<"Accessory"> | string
    productId?: StringFilter<"Accessory"> | string
    typeId?: StringFilter<"Accessory"> | string
    createdAt?: DateTimeFilter<"Accessory"> | Date | string
    updatedAt?: DateTimeFilter<"Accessory"> | Date | string
  }

  export type ProductCategoryCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCategoryCreateManyCategoryInputEnvelope = {
    data: ProductCategoryCreateManyCategoryInput | ProductCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutCategoryInput, ProductCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutCategoryInput, ProductCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductCreateWithoutProductCategoryInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type CategoryCreateWithoutProductCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductCategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductCategoryInput, CategoryUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpsertWithoutProductCategoryInput = {
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductCategoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryUpsertWithoutProductCategoryInput = {
    update: XOR<CategoryUpdateWithoutProductCategoryInput, CategoryUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<CategoryCreateWithoutProductCategoryInput, CategoryUncheckedCreateWithoutProductCategoryInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductCategoryInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductCategoryInput, CategoryUncheckedUpdateWithoutProductCategoryInput>
  }

  export type CategoryUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CartItem?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CartItem?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    WishlistItem?: WishlistItemCreateNestedManyWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutWishlistInput
  }

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistCreateManyUserInputEnvelope = {
    data: WishlistCreateManyUserInput | WishlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutUserInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    BillItem?: BillItemCreateNestedManyWithoutBillInput
    Transaction?: TransactionCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutUserInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    BillItem?: BillItemUncheckedCreateNestedManyWithoutBillInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutUserInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput>
  }

  export type BillCreateManyUserInputEnvelope = {
    data: BillCreateManyUserInput | BillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCouponCreateWithoutUserInput = {
    id?: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coupon: CouponCreateNestedOneWithoutUserCouponInput
  }

  export type UserCouponUncheckedCreateWithoutUserInput = {
    id?: string
    couponId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponCreateOrConnectWithoutUserInput = {
    where: UserCouponWhereUniqueInput
    create: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput>
  }

  export type UserCouponCreateManyUserInputEnvelope = {
    data: UserCouponCreateManyUserInput | UserCouponCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBuildCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutUserBuildInput
  }

  export type UserBuildUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutUserBuildInput
  }

  export type UserBuildCreateOrConnectWithoutUserInput = {
    where: UserBuildWhereUniqueInput
    create: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput>
  }

  export type UserBuildCreateManyUserInputEnvelope = {
    data: UserBuildCreateManyUserInput | UserBuildCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutUserInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type WishlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
  }

  export type WishlistUpdateManyWithWhereWithoutUserInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistScalarWhereInput = {
    AND?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    OR?: WishlistScalarWhereInput[]
    NOT?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    id?: StringFilter<"Wishlist"> | string
    userId?: StringFilter<"Wishlist"> | string
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
  }

  export type BillUpsertWithWhereUniqueWithoutUserInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutUserInput, BillUncheckedUpdateWithoutUserInput>
    create: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput>
  }

  export type BillUpdateWithWhereUniqueWithoutUserInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutUserInput, BillUncheckedUpdateWithoutUserInput>
  }

  export type BillUpdateManyWithWhereWithoutUserInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutUserInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: StringFilter<"Bill"> | string
    userId?: StringFilter<"Bill"> | string
    totalAmount?: DecimalFilter<"Bill"> | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFilter<"Bill"> | $Enums.BillStatus
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
  }

  export type UserCouponUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCouponWhereUniqueInput
    update: XOR<UserCouponUpdateWithoutUserInput, UserCouponUncheckedUpdateWithoutUserInput>
    create: XOR<UserCouponCreateWithoutUserInput, UserCouponUncheckedCreateWithoutUserInput>
  }

  export type UserCouponUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCouponWhereUniqueInput
    data: XOR<UserCouponUpdateWithoutUserInput, UserCouponUncheckedUpdateWithoutUserInput>
  }

  export type UserCouponUpdateManyWithWhereWithoutUserInput = {
    where: UserCouponScalarWhereInput
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCouponScalarWhereInput = {
    AND?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
    OR?: UserCouponScalarWhereInput[]
    NOT?: UserCouponScalarWhereInput | UserCouponScalarWhereInput[]
    id?: StringFilter<"UserCoupon"> | string
    couponId?: StringFilter<"UserCoupon"> | string
    userId?: StringFilter<"UserCoupon"> | string
    usageCount?: IntFilter<"UserCoupon"> | number
    createdAt?: DateTimeFilter<"UserCoupon"> | Date | string
    updatedAt?: DateTimeFilter<"UserCoupon"> | Date | string
  }

  export type UserBuildUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBuildWhereUniqueInput
    update: XOR<UserBuildUpdateWithoutUserInput, UserBuildUncheckedUpdateWithoutUserInput>
    create: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput>
  }

  export type UserBuildUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBuildWhereUniqueInput
    data: XOR<UserBuildUpdateWithoutUserInput, UserBuildUncheckedUpdateWithoutUserInput>
  }

  export type UserBuildUpdateManyWithWhereWithoutUserInput = {
    where: UserBuildScalarWhereInput
    data: XOR<UserBuildUpdateManyMutationInput, UserBuildUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBuildScalarWhereInput = {
    AND?: UserBuildScalarWhereInput | UserBuildScalarWhereInput[]
    OR?: UserBuildScalarWhereInput[]
    NOT?: UserBuildScalarWhereInput | UserBuildScalarWhereInput[]
    id?: StringFilter<"UserBuild"> | string
    userId?: StringFilter<"UserBuild"> | string
    name?: StringFilter<"UserBuild"> | string
    description?: StringFilter<"UserBuild"> | string
    createdAt?: DateTimeFilter<"UserBuild"> | Date | string
    updatedAt?: DateTimeFilter<"UserBuild"> | Date | string
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    Bill?: BillCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    Bill?: BillUncheckedCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserCreateWithoutCartInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    Bill?: BillCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    Bill?: BillUncheckedCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartInput = {
    update: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
  }

  export type UserUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    Bill?: BillUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    Bill?: BillUncheckedUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type CartCreateWithoutCartItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateWithoutCartItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutCartItemInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCartItemInput, CartUncheckedCreateWithoutCartItemInput>
  }

  export type CartUpsertWithoutCartItemInput = {
    update: XOR<CartUpdateWithoutCartItemInput, CartUncheckedUpdateWithoutCartItemInput>
    create: XOR<CartCreateWithoutCartItemInput, CartUncheckedCreateWithoutCartItemInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutCartItemInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutCartItemInput, CartUncheckedUpdateWithoutCartItemInput>
  }

  export type CartUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWishlistInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Cart?: CartCreateNestedManyWithoutUserInput
    Bill?: BillCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput
    Bill?: BillUncheckedCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
  }

  export type WishlistItemCreateWithoutWishlistInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutWishlistInput = {
    id?: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
  }

  export type WishlistItemCreateManyWishlistInputEnvelope = {
    data: WishlistItemCreateManyWishlistInput | WishlistItemCreateManyWishlistInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWishlistInput = {
    update: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type UserUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Cart?: CartUpdateManyWithoutUserNestedInput
    Bill?: BillUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    Bill?: BillUncheckedUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutWishlistInput, WishlistItemUncheckedUpdateWithoutWishlistInput>
    create: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutWishlistInput, WishlistItemUncheckedUpdateWithoutWishlistInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutWishlistInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutWishlistInput>
  }

  export type WishlistCreateWithoutWishlistItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutWishlistItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistCreateOrConnectWithoutWishlistItemInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutWishlistItemInput, WishlistUncheckedCreateWithoutWishlistItemInput>
  }

  export type ProductCreateWithoutWishlistItemInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWishlistItemInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWishlistItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
  }

  export type WishlistUpsertWithoutWishlistItemInput = {
    update: XOR<WishlistUpdateWithoutWishlistItemInput, WishlistUncheckedUpdateWithoutWishlistItemInput>
    create: XOR<WishlistCreateWithoutWishlistItemInput, WishlistUncheckedCreateWithoutWishlistItemInput>
    where?: WishlistWhereInput
  }

  export type WishlistUpdateToOneWithWhereWithoutWishlistItemInput = {
    where?: WishlistWhereInput
    data: XOR<WishlistUpdateWithoutWishlistItemInput, WishlistUncheckedUpdateWithoutWishlistItemInput>
  }

  export type WishlistUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutWishlistItemInput = {
    update: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWishlistItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>
  }

  export type ProductUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutBillInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Cart?: CartCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBillInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBillInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBillInput, UserUncheckedCreateWithoutBillInput>
  }

  export type BillItemCreateWithoutBillInput = {
    id?: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutBillItemInput
  }

  export type BillItemUncheckedCreateWithoutBillInput = {
    id?: string
    productId: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemCreateOrConnectWithoutBillInput = {
    where: BillItemWhereUniqueInput
    create: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput>
  }

  export type BillItemCreateManyBillInputEnvelope = {
    data: BillItemCreateManyBillInput | BillItemCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutBillInput = {
    id?: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutBillInput = {
    id?: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutBillInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput>
  }

  export type TransactionCreateManyBillInputEnvelope = {
    data: TransactionCreateManyBillInput | TransactionCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBillInput = {
    update: XOR<UserUpdateWithoutBillInput, UserUncheckedUpdateWithoutBillInput>
    create: XOR<UserCreateWithoutBillInput, UserUncheckedCreateWithoutBillInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBillInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBillInput, UserUncheckedUpdateWithoutBillInput>
  }

  export type UserUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Cart?: CartUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BillItemUpsertWithWhereUniqueWithoutBillInput = {
    where: BillItemWhereUniqueInput
    update: XOR<BillItemUpdateWithoutBillInput, BillItemUncheckedUpdateWithoutBillInput>
    create: XOR<BillItemCreateWithoutBillInput, BillItemUncheckedCreateWithoutBillInput>
  }

  export type BillItemUpdateWithWhereUniqueWithoutBillInput = {
    where: BillItemWhereUniqueInput
    data: XOR<BillItemUpdateWithoutBillInput, BillItemUncheckedUpdateWithoutBillInput>
  }

  export type BillItemUpdateManyWithWhereWithoutBillInput = {
    where: BillItemScalarWhereInput
    data: XOR<BillItemUpdateManyMutationInput, BillItemUncheckedUpdateManyWithoutBillInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutBillInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBillInput, TransactionUncheckedUpdateWithoutBillInput>
    create: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBillInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBillInput, TransactionUncheckedUpdateWithoutBillInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBillInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBillInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    billId?: StringFilter<"Transaction"> | string
    paymentMethod?: EnumTransactionMethodFilter<"Transaction"> | $Enums.TransactionMethod
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type BillCreateWithoutBillItemInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillInput
    Transaction?: TransactionCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutBillItemInput = {
    id?: string
    userId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutBillItemInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutBillItemInput, BillUncheckedCreateWithoutBillItemInput>
  }

  export type ProductCreateWithoutBillItemInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBillItemInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBillItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBillItemInput, ProductUncheckedCreateWithoutBillItemInput>
  }

  export type BillUpsertWithoutBillItemInput = {
    update: XOR<BillUpdateWithoutBillItemInput, BillUncheckedUpdateWithoutBillItemInput>
    create: XOR<BillCreateWithoutBillItemInput, BillUncheckedCreateWithoutBillItemInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutBillItemInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutBillItemInput, BillUncheckedUpdateWithoutBillItemInput>
  }

  export type BillUpdateWithoutBillItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillNestedInput
    Transaction?: TransactionUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutBillItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUncheckedUpdateManyWithoutBillNestedInput
  }

  export type ProductUpsertWithoutBillItemInput = {
    update: XOR<ProductUpdateWithoutBillItemInput, ProductUncheckedUpdateWithoutBillItemInput>
    create: XOR<ProductCreateWithoutBillItemInput, ProductUncheckedCreateWithoutBillItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBillItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBillItemInput, ProductUncheckedUpdateWithoutBillItemInput>
  }

  export type ProductUpdateWithoutBillItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBillItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BillCreateWithoutTransactionInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillInput
    BillItem?: BillItemCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutTransactionInput = {
    id?: string
    userId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    BillItem?: BillItemUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutTransactionInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutTransactionInput, BillUncheckedCreateWithoutTransactionInput>
  }

  export type BillUpsertWithoutTransactionInput = {
    update: XOR<BillUpdateWithoutTransactionInput, BillUncheckedUpdateWithoutTransactionInput>
    create: XOR<BillCreateWithoutTransactionInput, BillUncheckedCreateWithoutTransactionInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutTransactionInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutTransactionInput, BillUncheckedUpdateWithoutTransactionInput>
  }

  export type BillUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillNestedInput
    BillItem?: BillItemUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BillItem?: BillItemUncheckedUpdateManyWithoutBillNestedInput
  }

  export type UserCouponCreateWithoutCouponInput = {
    id?: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserCouponInput
  }

  export type UserCouponUncheckedCreateWithoutCouponInput = {
    id?: string
    userId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponCreateOrConnectWithoutCouponInput = {
    where: UserCouponWhereUniqueInput
    create: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput>
  }

  export type UserCouponCreateManyCouponInputEnvelope = {
    data: UserCouponCreateManyCouponInput | UserCouponCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type UserCouponUpsertWithWhereUniqueWithoutCouponInput = {
    where: UserCouponWhereUniqueInput
    update: XOR<UserCouponUpdateWithoutCouponInput, UserCouponUncheckedUpdateWithoutCouponInput>
    create: XOR<UserCouponCreateWithoutCouponInput, UserCouponUncheckedCreateWithoutCouponInput>
  }

  export type UserCouponUpdateWithWhereUniqueWithoutCouponInput = {
    where: UserCouponWhereUniqueInput
    data: XOR<UserCouponUpdateWithoutCouponInput, UserCouponUncheckedUpdateWithoutCouponInput>
  }

  export type UserCouponUpdateManyWithWhereWithoutCouponInput = {
    where: UserCouponScalarWhereInput
    data: XOR<UserCouponUpdateManyMutationInput, UserCouponUncheckedUpdateManyWithoutCouponInput>
  }

  export type CouponCreateWithoutUserCouponInput = {
    id?: string
    code: string
    discountType: string
    discountValue: string
    validFrom: Date | string
    validUntil: Date | string
    minimumOrderAmount: Decimal | DecimalJsLike | number | string
    usageLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUncheckedCreateWithoutUserCouponInput = {
    id?: string
    code: string
    discountType: string
    discountValue: string
    validFrom: Date | string
    validUntil: Date | string
    minimumOrderAmount: Decimal | DecimalJsLike | number | string
    usageLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateOrConnectWithoutUserCouponInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
  }

  export type UserCreateWithoutUserCouponInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Cart?: CartCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    Bill?: BillCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCouponInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    Bill?: BillUncheckedCreateNestedManyWithoutUserInput
    UserBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCouponInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCouponInput, UserUncheckedCreateWithoutUserCouponInput>
  }

  export type CouponUpsertWithoutUserCouponInput = {
    update: XOR<CouponUpdateWithoutUserCouponInput, CouponUncheckedUpdateWithoutUserCouponInput>
    create: XOR<CouponCreateWithoutUserCouponInput, CouponUncheckedCreateWithoutUserCouponInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutUserCouponInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutUserCouponInput, CouponUncheckedUpdateWithoutUserCouponInput>
  }

  export type CouponUpdateWithoutUserCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumOrderAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateWithoutUserCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumOrderAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usageLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUserCouponInput = {
    update: XOR<UserUpdateWithoutUserCouponInput, UserUncheckedUpdateWithoutUserCouponInput>
    create: XOR<UserCreateWithoutUserCouponInput, UserUncheckedCreateWithoutUserCouponInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCouponInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCouponInput, UserUncheckedUpdateWithoutUserCouponInput>
  }

  export type UserUpdateWithoutUserCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Cart?: CartUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    Bill?: BillUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    Bill?: BillUncheckedUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserBuildInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    Cart?: CartCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    Bill?: BillCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserBuildInput = {
    id?: string
    roleId: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Cart?: CartUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    Bill?: BillUncheckedCreateNestedManyWithoutUserInput
    UserCoupon?: UserCouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
  }

  export type UserBuildComponentCreateWithoutUserBuildInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutUserBuildComponentInput
    componentType: ComponentTypeCreateNestedOneWithoutUserBuildComponentInput
  }

  export type UserBuildComponentUncheckedCreateWithoutUserBuildInput = {
    id?: string
    productId: string
    componentTypeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentCreateOrConnectWithoutUserBuildInput = {
    where: UserBuildComponentWhereUniqueInput
    create: XOR<UserBuildComponentCreateWithoutUserBuildInput, UserBuildComponentUncheckedCreateWithoutUserBuildInput>
  }

  export type UserBuildComponentCreateManyUserBuildInputEnvelope = {
    data: UserBuildComponentCreateManyUserBuildInput | UserBuildComponentCreateManyUserBuildInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserBuildInput = {
    update: XOR<UserUpdateWithoutUserBuildInput, UserUncheckedUpdateWithoutUserBuildInput>
    create: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserBuildInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserBuildInput, UserUncheckedUpdateWithoutUserBuildInput>
  }

  export type UserUpdateWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Cart?: CartUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    Bill?: BillUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    Bill?: BillUncheckedUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserBuildComponentUpsertWithWhereUniqueWithoutUserBuildInput = {
    where: UserBuildComponentWhereUniqueInput
    update: XOR<UserBuildComponentUpdateWithoutUserBuildInput, UserBuildComponentUncheckedUpdateWithoutUserBuildInput>
    create: XOR<UserBuildComponentCreateWithoutUserBuildInput, UserBuildComponentUncheckedCreateWithoutUserBuildInput>
  }

  export type UserBuildComponentUpdateWithWhereUniqueWithoutUserBuildInput = {
    where: UserBuildComponentWhereUniqueInput
    data: XOR<UserBuildComponentUpdateWithoutUserBuildInput, UserBuildComponentUncheckedUpdateWithoutUserBuildInput>
  }

  export type UserBuildComponentUpdateManyWithWhereWithoutUserBuildInput = {
    where: UserBuildComponentScalarWhereInput
    data: XOR<UserBuildComponentUpdateManyMutationInput, UserBuildComponentUncheckedUpdateManyWithoutUserBuildInput>
  }

  export type UserBuildCreateWithoutUserBuildComponentInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserBuildInput
  }

  export type UserBuildUncheckedCreateWithoutUserBuildComponentInput = {
    id?: string
    userId: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildCreateOrConnectWithoutUserBuildComponentInput = {
    where: UserBuildWhereUniqueInput
    create: XOR<UserBuildCreateWithoutUserBuildComponentInput, UserBuildUncheckedCreateWithoutUserBuildComponentInput>
  }

  export type ProductCreateWithoutUserBuildComponentInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserBuildComponentInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserBuildComponentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserBuildComponentInput, ProductUncheckedCreateWithoutUserBuildComponentInput>
  }

  export type ComponentTypeCreateWithoutUserBuildComponentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentTypeUncheckedCreateWithoutUserBuildComponentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentTypeCreateOrConnectWithoutUserBuildComponentInput = {
    where: ComponentTypeWhereUniqueInput
    create: XOR<ComponentTypeCreateWithoutUserBuildComponentInput, ComponentTypeUncheckedCreateWithoutUserBuildComponentInput>
  }

  export type UserBuildUpsertWithoutUserBuildComponentInput = {
    update: XOR<UserBuildUpdateWithoutUserBuildComponentInput, UserBuildUncheckedUpdateWithoutUserBuildComponentInput>
    create: XOR<UserBuildCreateWithoutUserBuildComponentInput, UserBuildUncheckedCreateWithoutUserBuildComponentInput>
    where?: UserBuildWhereInput
  }

  export type UserBuildUpdateToOneWithWhereWithoutUserBuildComponentInput = {
    where?: UserBuildWhereInput
    data: XOR<UserBuildUpdateWithoutUserBuildComponentInput, UserBuildUncheckedUpdateWithoutUserBuildComponentInput>
  }

  export type UserBuildUpdateWithoutUserBuildComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBuildNestedInput
  }

  export type UserBuildUncheckedUpdateWithoutUserBuildComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutUserBuildComponentInput = {
    update: XOR<ProductUpdateWithoutUserBuildComponentInput, ProductUncheckedUpdateWithoutUserBuildComponentInput>
    create: XOR<ProductCreateWithoutUserBuildComponentInput, ProductUncheckedCreateWithoutUserBuildComponentInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutUserBuildComponentInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutUserBuildComponentInput, ProductUncheckedUpdateWithoutUserBuildComponentInput>
  }

  export type ProductUpdateWithoutUserBuildComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserBuildComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ComponentTypeUpsertWithoutUserBuildComponentInput = {
    update: XOR<ComponentTypeUpdateWithoutUserBuildComponentInput, ComponentTypeUncheckedUpdateWithoutUserBuildComponentInput>
    create: XOR<ComponentTypeCreateWithoutUserBuildComponentInput, ComponentTypeUncheckedCreateWithoutUserBuildComponentInput>
    where?: ComponentTypeWhereInput
  }

  export type ComponentTypeUpdateToOneWithWhereWithoutUserBuildComponentInput = {
    where?: ComponentTypeWhereInput
    data: XOR<ComponentTypeUpdateWithoutUserBuildComponentInput, ComponentTypeUncheckedUpdateWithoutUserBuildComponentInput>
  }

  export type ComponentTypeUpdateWithoutUserBuildComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentTypeUncheckedUpdateWithoutUserBuildComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentCreateWithoutComponentTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userBuild: UserBuildCreateNestedOneWithoutUserBuildComponentInput
    product: ProductCreateNestedOneWithoutUserBuildComponentInput
  }

  export type UserBuildComponentUncheckedCreateWithoutComponentTypeInput = {
    id?: string
    userBuildId: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentCreateOrConnectWithoutComponentTypeInput = {
    where: UserBuildComponentWhereUniqueInput
    create: XOR<UserBuildComponentCreateWithoutComponentTypeInput, UserBuildComponentUncheckedCreateWithoutComponentTypeInput>
  }

  export type UserBuildComponentCreateManyComponentTypeInputEnvelope = {
    data: UserBuildComponentCreateManyComponentTypeInput | UserBuildComponentCreateManyComponentTypeInput[]
    skipDuplicates?: boolean
  }

  export type UserBuildComponentUpsertWithWhereUniqueWithoutComponentTypeInput = {
    where: UserBuildComponentWhereUniqueInput
    update: XOR<UserBuildComponentUpdateWithoutComponentTypeInput, UserBuildComponentUncheckedUpdateWithoutComponentTypeInput>
    create: XOR<UserBuildComponentCreateWithoutComponentTypeInput, UserBuildComponentUncheckedCreateWithoutComponentTypeInput>
  }

  export type UserBuildComponentUpdateWithWhereUniqueWithoutComponentTypeInput = {
    where: UserBuildComponentWhereUniqueInput
    data: XOR<UserBuildComponentUpdateWithoutComponentTypeInput, UserBuildComponentUncheckedUpdateWithoutComponentTypeInput>
  }

  export type UserBuildComponentUpdateManyWithWhereWithoutComponentTypeInput = {
    where: UserBuildComponentScalarWhereInput
    data: XOR<UserBuildComponentUpdateManyMutationInput, UserBuildComponentUncheckedUpdateManyWithoutComponentTypeInput>
  }

  export type ProductCreateWithoutProductImageInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardCreateNestedOneWithoutProductInput
    Switch?: SwitchCreateNestedOneWithoutProductInput
    Keycap?: KeycapCreateNestedOneWithoutProductInput
    Accessory?: AccessoryCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    BillItem?: BillItemCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductImageInput = {
    id?: string
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    sku: string
    stock: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Keyboard?: KeyboardUncheckedCreateNestedOneWithoutProductInput
    Switch?: SwitchUncheckedCreateNestedOneWithoutProductInput
    Keycap?: KeycapUncheckedCreateNestedOneWithoutProductInput
    Accessory?: AccessoryUncheckedCreateNestedOneWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    BillItem?: BillItemUncheckedCreateNestedManyWithoutProductInput
    UserBuildComponent?: UserBuildComponentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductImageInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
  }

  export type ProductUpsertWithoutProductImageInput = {
    update: XOR<ProductUpdateWithoutProductImageInput, ProductUncheckedUpdateWithoutProductImageInput>
    create: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductImageInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductImageInput, ProductUncheckedUpdateWithoutProductImageInput>
  }

  export type ProductUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUpdateOneWithoutProductNestedInput
    Switch?: SwitchUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keyboard?: KeyboardUncheckedUpdateOneWithoutProductNestedInput
    Switch?: SwitchUncheckedUpdateOneWithoutProductNestedInput
    Keycap?: KeycapUncheckedUpdateOneWithoutProductNestedInput
    Accessory?: AccessoryUncheckedUpdateOneWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    BillItem?: BillItemUncheckedUpdateManyWithoutProductNestedInput
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCategoryCreateManyProductInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateManyProductInput = {
    id?: string
    wishlistId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemCreateManyProductInput = {
    id?: string
    billId: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentCreateManyProductInput = {
    id?: string
    userBuildId: string
    componentTypeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageCreateManyProductInput = {
    id?: string
    imageUrl: string
    altText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wishlist?: WishlistUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    wishlistId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    wishlistId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutBillItemNestedInput
  }

  export type BillItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBuild?: UserBuildUpdateOneRequiredWithoutUserBuildComponentNestedInput
    componentType?: ComponentTypeUpdateOneRequiredWithoutUserBuildComponentNestedInput
  }

  export type UserBuildComponentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBuildId?: StringFieldUpdateOperationsInput | string
    componentTypeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBuildId?: StringFieldUpdateOperationsInput | string
    componentTypeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorCreateManyKeyboardInput = {
    id?: string
    hex: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUncheckedUpdateWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUncheckedUpdateManyWithoutKeyboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    hex?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyboardCreateManyLayoutInput = {
    id?: string
    productId: string
    connectionTypeId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyboardUpdateWithoutLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeyboardNestedInput
    connectionType?: ConnectionTypeUpdateOneRequiredWithoutKeyboardNestedInput
    Color?: ColorUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateWithoutLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    connectionTypeId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Color?: ColorUncheckedUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateManyWithoutLayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    connectionTypeId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyboardCreateManyConnectionTypeInput = {
    id?: string
    productId: string
    layoutId: string
    isHotswapable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyboardUpdateWithoutConnectionTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeyboardNestedInput
    layout?: LayoutUpdateOneRequiredWithoutKeyboardNestedInput
    Color?: ColorUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateWithoutConnectionTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    layoutId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Color?: ColorUncheckedUpdateManyWithoutKeyboardNestedInput
  }

  export type KeyboardUncheckedUpdateManyWithoutConnectionTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    layoutId?: StringFieldUpdateOperationsInput | string
    isHotswapable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchCreateManySwitchTypeInput = {
    id?: string
    productId: string
    actuationForce?: Decimal | DecimalJsLike | number | string
    actuationPoint?: Decimal | DecimalJsLike | number | string
    totalTravel?: Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: number
    isFactoryLubed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwitchUpdateWithoutSwitchTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSwitchNestedInput
  }

  export type SwitchUncheckedUpdateWithoutSwitchTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwitchUncheckedUpdateManyWithoutSwitchTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    actuationForce?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actuationPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTravel?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keystrokeLifespan?: IntFieldUpdateOperationsInput | number
    isFactoryLubed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapCreateManyProfileInput = {
    id?: string
    productId: string
    materialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeycapNestedInput
    material?: KeycapMaterialUpdateOneRequiredWithoutKeycapNestedInput
  }

  export type KeycapUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    materialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapCreateManyMaterialInput = {
    id?: string
    productId: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeycapUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutKeycapNestedInput
    profile?: KeycapProfileUpdateOneRequiredWithoutKeycapNestedInput
  }

  export type KeycapUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeycapUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryCreateManyTypeInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessoryUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutAccessoryNestedInput
  }

  export type AccessoryUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessoryUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateManyCategoryInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillCreateManyUserInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status: $Enums.BillStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponCreateManyUserInput = {
    id?: string
    couponId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildCreateManyUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CartItem?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CartItem?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WishlistItem?: WishlistItemUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BillItem?: BillItemUpdateManyWithoutBillNestedInput
    Transaction?: TransactionUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BillItem?: BillItemUncheckedUpdateManyWithoutBillNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneRequiredWithoutUserCouponNestedInput
  }

  export type UserCouponUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserBuildComponent?: UserBuildComponentUpdateManyWithoutUserBuildNestedInput
  }

  export type UserBuildUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserBuildComponent?: UserBuildComponentUncheckedUpdateManyWithoutUserBuildNestedInput
  }

  export type UserBuildUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    address: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    Bill?: BillUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Cart?: CartUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    Bill?: BillUncheckedUpdateManyWithoutUserNestedInput
    UserCoupon?: UserCouponUncheckedUpdateManyWithoutUserNestedInput
    UserBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateManyWishlistInput = {
    id?: string
    productId: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutWishlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemCreateManyBillInput = {
    id?: string
    productId: string
    quantity?: number
    priceAtPurchase?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyBillInput = {
    id?: string
    paymentMethod: $Enums.TransactionMethod
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.TransactionStatus
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillItemUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutBillItemNestedInput
  }

  export type BillItemUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillItemUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceAtPurchase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumTransactionMethodFieldUpdateOperationsInput | $Enums.TransactionMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponCreateManyCouponInput = {
    id?: string
    userId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCouponUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserCouponNestedInput
  }

  export type UserCouponUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCouponUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentCreateManyUserBuildInput = {
    id?: string
    productId: string
    componentTypeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentUpdateWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutUserBuildComponentNestedInput
    componentType?: ComponentTypeUpdateOneRequiredWithoutUserBuildComponentNestedInput
  }

  export type UserBuildComponentUncheckedUpdateWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    componentTypeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentUncheckedUpdateManyWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    componentTypeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentCreateManyComponentTypeInput = {
    id?: string
    userBuildId: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBuildComponentUpdateWithoutComponentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBuild?: UserBuildUpdateOneRequiredWithoutUserBuildComponentNestedInput
    product?: ProductUpdateOneRequiredWithoutUserBuildComponentNestedInput
  }

  export type UserBuildComponentUncheckedUpdateWithoutComponentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBuildId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBuildComponentUncheckedUpdateManyWithoutComponentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBuildId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}